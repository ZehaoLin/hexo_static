<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Linzh's Blog" type="application/atom+xml" />






<meta name="description" content="Standing on Shoulders of Giants">
<meta property="og:type" content="website">
<meta property="og:title" content="Linzh's Blog">
<meta property="og:url" content="http://linzhs.cm/page/2/index.html">
<meta property="og:site_name" content="Linzh's Blog">
<meta property="og:description" content="Standing on Shoulders of Giants">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linzh's Blog">
<meta name="twitter:description" content="Standing on Shoulders of Giants">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linzhs.cm/page/2/"/>





  <title>Linzh's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Linzh's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Standing on Shoulders of Giants</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-view-def/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-view-def/" itemprop="url">Android自定义View和ViewGroup</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:05:33+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android自定义View和ViewGroup"><a href="#Android自定义View和ViewGroup" class="headerlink" title="Android自定义View和ViewGroup"></a>Android自定义View和ViewGroup</h1><blockquote>
<p>Android中提供了丰富、复杂的视图系统，widget类的组件：Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner都是直接或间接继承于super类View，布局类：LinearLayout, FrameLayout, RelativeLayout等则继承于ViewGroup， ViewGroup则继承于View。</p>
<p>所以，要设计构建自己的视图或者布局，就要去继承View或者ViewGroup。本文从使用的角度来总结自定制View和ViewGroup。</p>
</blockquote>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>自定义View，最基本的就是继承Android提供的基本视图类View。<br>自定义步骤：</p>
<ul>
<li>自定义View的属性 编写attr.xml文件 </li>
<li>在layout布局文件中引用，同时引用命名空间 </li>
<li>在View的构造方法中获得我们自定义的属性，在自定义控件中进行读取（构造方法拿到attr.xml文件值） </li>
<li>重写onMesure </li>
<li>重写onDraw</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyView extends View &#123;</div><div class="line">    public MyView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承了View类，还需要重写2个以上的构造方法（以上示例为常用重写构造方法）和onMeasure(), onDraw()方法，在View继承中，onLayout()是非必须的。</p>
<h3 id="拓展onMeasure"><a href="#拓展onMeasure" class="headerlink" title="拓展onMeasure()"></a>拓展onMeasure()</h3><p>自定义View都要自己来测量控制宽高尺寸，算出自己需要占用多大的面积。我们常在xml布局文件中用match_parent和wrap_content，这两属性都是依赖于父布局的，没有父布局就没法正确定位宽高。</p>
<p>这里存在一个疑问，就是如果我们在activity_main.xml中的代码如下，layout_width和layout_height指定的值也都为match_parent，其父布局又在哪呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:id=&quot;@+id/main_layout&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>我们在MainActivity.java中进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private LinearLayout linearLayout;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        linearLayout = (LinearLayout)findViewById(R.id.main_layout);</div><div class="line">        LayoutInflater layoutInflater = LayoutInflater.from(this);</div><div class="line">        View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null);</div><div class="line">        linearLayout.addView(buttonLayout);</div><div class="line"></div><div class="line">        ViewParent viewParent = linearLayout.getParent();//获取父布局的名字</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;The parent of main linear layout is &quot; + viewParent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上App，可以在logcat中打印出如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The parent of main linear layout is android.support.v7.widget.ContentFrameLayout&#123;2ef2e36 V.E...... ......I. 0,0-0,0 #1020002 android:id/content&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：以上运行API level 为25</p>
</blockquote>
<p>从logcat的信息可知，我们在每个xml文件的布局的最外层，Android还自动帮我们加了一个FrameLayout/ContentFrameLayout，在自动嵌套的父布局里，有一部分是content，就是默认放label的地方，对应setContentView方法，在此之下才是我们自己定义的布局文件的内容。</p>
<p>onMeasure方法的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div></pre></td></tr></table></figure></p>
<p>在参数中，widthMeasureSpec和heightMeasureSpec都为int，但是每个int都包含着两个信息，分别是尺寸和测量模式，一般情况下，int是32位的，Android把其中的30位用做尺寸大小存储，2bit用做测量模式存储。</p>
<p>2bit来存测量模式信息，也就是最多有4种模式，Android提供了3种测量模式，如下：</p>
<table>
<thead>
<tr>
<th>测量模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNSPECIFIED</td>
<td>父容器没有对当前View有任何限制，当前View可以任意取尺寸 极少用</td>
</tr>
<tr>
<td>EXACTLY</td>
<td>父布局要求的精确尺寸，必须用这个尺寸作为View尺寸</td>
</tr>
<tr>
<td>AT_MOST</td>
<td>父布局给予View最大的尺寸，当前的View能取的尺寸为这个</td>
</tr>
</tbody>
</table>
<p>测量模式和实际布局应用的属性值的关系：</p>
<ul>
<li>match_parent  -&gt;  EXACTLY</li>
<li>wrap_content  -&gt;  AT_MOST</li>
<li>指定尺寸      -&gt;  EXACTLY</li>
</ul>
<p>如何获取widthMeasureSpec和heightMeasureSpec中的测量模式和尺寸大小？Android库中提供了两个方法，用来提取这两个信息，其实现细节就是进行了位运算，将前2-bit当做测量模式，后30-bit作为尺寸大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div></pre></td></tr></table></figure></p>
<p>重写onMeasure方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size</div><div class="line">                //我们将大小取最大值,你也可以取其他值</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mySize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        int width = getMySize(100, widthMeasureSpec);</div><div class="line">        int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);//设置测量尺寸</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成自定义类的继承拓展后，就可以使用该View了，在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;[package name].MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:background=&quot;#ff0000&quot; /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="拓展onDraw"><a href="#拓展onDraw" class="headerlink" title="拓展onDraw()"></a>拓展onDraw()</h3><p>onDraw方法用于绘制效果图，super类默认提供了Canvas对象，其具备基本的绘图功能，比如绘制背景颜色、背景图片等，可以直接使用。</p>
<p>若是在上面的onMeasure例子上，在正方形的基础上画圆，可以重写onDraw方法为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        //调用父View的onDraw函数，因为View这个类帮我们实现了一些</div><div class="line">        // 基本的而绘制功能，比如绘制背景颜色、背景图片等</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了</div><div class="line">        int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径</div><div class="line">        int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        canvas.drawCircle(centerX, centerY, radius, paint);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义布局属性"><a href="#自定义布局属性" class="headerlink" title="自定义布局属性"></a>自定义布局属性</h3><p>可以在res/values/styles.xml文件中定义自己的属性（或者新建attr.xml文件），在需要用户来指定某些属性的值的时候，这个是很有用的。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line"></div><div class="line">    &lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt;</div><div class="line">    &lt;declare-styleable name=&quot;MyView&quot;&gt;</div><div class="line">        &lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt;</div><div class="line">        &lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;[package name].MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        hc:default_size=&quot;100dp&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>在Java文件中解析获取该属性的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private int defalutSize;</div><div class="line">  public MyView(Context context, AttributeSet attrs) &#123;</div><div class="line">      super(context, attrs);</div><div class="line">      //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</div><div class="line">        //即属性集合的标签，在R文件中名称为R.styleable+name</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);</div><div class="line"></div><div class="line">        //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</div><div class="line">        //第二个参数为，如果没有设置这个属性，则设置的默认的值</div><div class="line">        defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</div><div class="line"></div><div class="line">        //最后记得将TypedArray对象回收</div><div class="line">        a.recycle();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义View完整示例代码"><a href="#自定义View完整示例代码" class="headerlink" title="自定义View完整示例代码"></a>自定义View完整示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">package com.example.linzh.myview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by linzh on 2017/3/28.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyView extends View &#123;//继承View至少实现两个构造方法</div><div class="line"></div><div class="line">    private int defaultSize;</div><div class="line"></div><div class="line">    public MyView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</div><div class="line">        //即属性集合的标签，在R文件中名称为R.styleable+name</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);</div><div class="line"></div><div class="line">        //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</div><div class="line">        //第二个参数为，如果没有设置这个属性，则设置的默认的值</div><div class="line">        defaultSize = typedArray.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</div><div class="line"></div><div class="line">        typedArray.recycle();//回收</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = getMySize(100, widthMeasureSpec);</div><div class="line">        int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        //调用父View的onDraw函数，因为View这个类帮我们实现了一些</div><div class="line">        // 基本的而绘制功能，比如绘制背景颜色、背景图片等</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了</div><div class="line">        int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径</div><div class="line">        int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        canvas.drawCircle(centerX, centerY, radius, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            case MeasureSpec.UNSPECIFIED://如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.AT_MOST://如果测量模式是最大取值为size 类似于wrap_content</div><div class="line">                mySize = size;//这里把值去最大，也可以取其他值</div><div class="line">                break;</div><div class="line">            case MeasureSpec.EXACTLY://如果是固定大小，拿就不要去改变它， 类似于match_parent</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return mySize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><p>ViewGroup是一到多个View的容器，ViewGroup多大也是要测量好的，而且要根据View来测量。</p>
<h3 id="重写onMeasure"><a href="#重写onMeasure" class="headerlink" title="重写onMeasure"></a>重写onMeasure</h3><p>逐个测量View的大小，并且设定ViewGroup的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       //将所有的子View进行测量，这会触发每个子View的onMeasure函数</div><div class="line">       //注意要与measureChild区分，measureChild是对单个view进行测量</div><div class="line">       measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">       int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">       int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">       int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">       int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">       int childCount = getChildCount();</div><div class="line"></div><div class="line">       if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间</div><div class="line">           setMeasuredDimension(0, 0);</div><div class="line">       &#125; else &#123;</div><div class="line">           //如果宽高都是包裹内容</div><div class="line">           if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">               //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</div><div class="line">               int height = getTotleHeight();</div><div class="line">               int width = getMaxChildWidth();</div><div class="line">               setMeasuredDimension(width, height);</div><div class="line"></div><div class="line">           &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</div><div class="line">               //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</div><div class="line">               setMeasuredDimension(widthSize, getTotleHeight());</div><div class="line">           &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</div><div class="line">               //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</div><div class="line">               setMeasuredDimension(getMaxChildWidth(), heightSize);</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   /***</div><div class="line">    * 获取子View中宽度最大的值</div><div class="line">    */</div><div class="line">   private int getMaxChildWidth() &#123;</div><div class="line">       int childCount = getChildCount();</div><div class="line">       int maxWidth = 0;</div><div class="line">       for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">           View childView = getChildAt(i);</div><div class="line">           if (childView.getMeasuredWidth() &gt; maxWidth)</div><div class="line">               maxWidth = childView.getMeasuredWidth();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return maxWidth;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /***</div><div class="line">    * 将所有子View的高度相加</div><div class="line">    **/</div><div class="line">   private int getTotleHeight() &#123;</div><div class="line">       int childCount = getChildCount();</div><div class="line">       int height = 0;</div><div class="line">       for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">           View childView = getChildAt(i);</div><div class="line">           height += childView.getMeasuredHeight();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return height;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="重写onLayout"><a href="#重写onLayout" class="headerlink" title="重写onLayout"></a>重写onLayout</h3><p>自定义ViewGroup，重写onLayout方法是有用的，在此方法我们将View逐个摆放到设定好大小的ViewGroup中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    int count = getChildCount();</div><div class="line">    //记录当前的高度位置</div><div class="line">    int curHeight = t;</div><div class="line">    //将子View逐个摆放</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        int height = child.getMeasuredHeight();</div><div class="line">        int width = child.getMeasuredWidth();</div><div class="line">        //摆放子View，参数分别是子View矩形区域的左、上、右、下边</div><div class="line">        child.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">        curHeight += height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成Java代码的定制，即可在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.example.linzh.myview.MyViewGroup</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:background=&quot;#ff9900&quot;&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;200dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;/com.example.linzh.myview.MyViewGroup&gt;</div><div class="line"></div><div class="line">    &lt;com.example.linzh.myview.MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        linzh:default_size=&quot;100dp&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<h3 id="自定制ViewGroup完成示例代码"><a href="#自定制ViewGroup完成示例代码" class="headerlink" title="自定制ViewGroup完成示例代码"></a>自定制ViewGroup完成示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">package com.example.linzh.myview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by linzh on 2017/3/28.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyViewGroup extends ViewGroup &#123;//至少实现两个Super类的构造器</div><div class="line"></div><div class="line"></div><div class="line">    public MyViewGroup(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyViewGroup(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        //将所有的子View进行测量，这会触发每个子View的onMeasure函数</div><div class="line">        //注意要与measureChild区分，measureChild是对单个view进行测量</div><div class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        int childCount = getChildCount();</div><div class="line">        if (childCount == 0) &#123;//如果没有子view，当前ViewGroup没有存在的意义，不用占用空间</div><div class="line">            setMeasuredDimension(0, 0);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//如果宽高都是包裹内容</div><div class="line">                //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</div><div class="line">                int height = getTotleHeight();</div><div class="line">                int width = getMaxChildWidth();</div><div class="line">                setMeasuredDimension(width, height);</div><div class="line">            &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</div><div class="line">                //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</div><div class="line">                setMeasuredDimension(widthSize, getTotleHeight());</div><div class="line">            &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</div><div class="line">                //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</div><div class="line">                setMeasuredDimension(getMaxChildWidth(), heightSize);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        int curHeight = t;//记录当前的高度位置</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;//将View逐个摆放</div><div class="line">            View view = getChildAt(i);</div><div class="line">            int height = view.getMeasuredHeight();</div><div class="line">            int width = view.getMeasuredWidth();</div><div class="line">            //摆放子View，参数分别是子View矩形区域的左、上、右、下边</div><div class="line">            view.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">            curHeight += height;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取子View中宽度最大的值</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private int getMaxChildWidth() &#123;</div><div class="line">        int childCount = getChildCount();</div><div class="line">        int maxWidth = 0;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            if (childView.getMeasuredWidth() &gt; maxWidth) &#123;</div><div class="line">                maxWidth = childView.getMeasuredWidth();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return maxWidth;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 将所有子View的高度相加</div><div class="line">     **/</div><div class="line">    private int getTotleHeight() &#123;</div><div class="line">        int childCount = getChildCount();</div><div class="line">        int height = 0;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            height += childView.getMeasuredHeight();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/guide/topics/ui/custom-components.html#custom" target="_blank" rel="external">Android API指南 Custom Components</a></li>
<li><a href="http://www.jianshu.com/p/c84693096e41" target="_blank" rel="external">自定义View，有这一篇就够了</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-data-save/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-data-save/" itemprop="url">Android的数据储存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:04:00+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android的数据存储与共享"><a href="#Android的数据存储与共享" class="headerlink" title="Android的数据存储与共享"></a>Android的数据存储与共享</h1><blockquote>
<p>Android提供了多种数据储存与共享的方式，其中文件存储、SharedPreferences、数据库等只能用于当前应用程序中，而Content Provider不仅可以在应用程序内部进行数据存储和共享，还可以跨程序数据共享，而且是更加安全可靠的。</p>
</blockquote>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储数据是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。</p>
<p>文件储存是不可以包含文件目录的，默认存储在/data/data/<package name="">/files下。</package></p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>使用Context的openFileOutput()方法，有两个参数：</p>
<ul>
<li>文件名</li>
<li>文件操作模式 默认为MODE_PRIVATE，表示当指定文件名的时候，所写入内容覆盖源文件内容。还可以指定MODE_APPEND模式，即表示源文件存在的时候追加内容，不存在的时候创建</li>
</ul>
<blockquote>
<p>MODE_WORLD_READAVLE和MODE_WORLD_WRITEABLE模式已被弃用，使用存在风险</p>
</blockquote>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">String data = &quot;Data to save&quot;;</div><div class="line">FileOutputStream out = null;</div><div class="line">BufferWriter writer = null;</div><div class="line">try &#123;</div><div class="line">    out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);</div><div class="line">    writer = new BufferWriter(new OutputStreamWriter(out));</div><div class="line">    writer.write(data);</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">    try &#123;</div><div class="line">        if (writer != null) &#123;</div><div class="line">            writer.close();</div><div class="line">        &#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>使用Context的openFileInput()方法，接收一个文件名字符串参数。</p>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">FileInputStream in = null;</div><div class="line">BufferReader reader = null;</div><div class="line">StringBuffer content = new StringBuffer();</div><div class="line">try &#123;</div><div class="line">    in = openFileInput(&quot;data&quot;);</div><div class="line">    reader = new BufferWirter(new InputStreamWriter(in));</div><div class="line">    String line = &quot;&quot;;</div><div class="line">    while ((line = reader.readLine() != null) &#123;</div><div class="line">        content.append(line);</div><div class="line">    &#125;</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">    try &#123;</div><div class="line">        if (reader != null) &#123;</div><div class="line">            reader.close();</div><div class="line">        &#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(content.toString());</div></pre></td></tr></table></figure></p>
<h2 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h2><p>SharedPreferences是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据以键值对的形式存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。</p>
<p>SharedPreferences的默认文件位置是/data/data/<package name="">/shared_prefs/，Android提供了3种用于获取SharedPreferences对象的方法。</package></p>
<ul>
<li>Context.getSharedPreferences()</li>
</ul>
<p>此方法接收两个参数，第一个为文件名，不存在就创建。第二个参数为操作模式，Android6.0开始只有一个默认操作模式，为MODE_PRIVATE，也就是指定为0。</p>
<ul>
<li>Activity.getPreferences()</li>
</ul>
<p>这个方法是getSharedPreferences()方法的特殊形式，只有一个操作模式参数，文件名自动设置为当前活动类名。</p>
<ul>
<li>PreferenceManager.getDefaultSharedPreferences()</li>
</ul>
<p>这是一个静态方法，接收一个Context参数，并自动使用当前应用程序的报名作为前缀来命名SharedPreference文件。</p>
<h3 id="存储数据步骤"><a href="#存储数据步骤" class="headerlink" title="存储数据步骤"></a>存储数据步骤</h3><p>首选根据以上三种方法中的一种获取SharedPreferences对象，然后：</p>
<ul>
<li>调用SharedPreferences.edit()方法获取一个SharedPreferences.Editor对象；</li>
<li>想SharedPreferences.Editor对象添加数据，以putXXX的形式；</li>
<li>调用apply()方法将添加的数据提交完成保存。</li>
</ul>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();</div><div class="line">editor.putString(&quot;name&quot;, &quot;Tom&quot;);</div><div class="line">editor.putInt(&quot;age&quot;, 28);</div><div class="line">editor.putBoolean(&quot;married&quot;, false);</div><div class="line">editor.apply();</div></pre></td></tr></table></figure></p>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SharedPreferences pref = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);</div><div class="line">String name = pref.getString(&quot;name&quot;, &quot;&quot;);//第二参数为键没有对应的值时会以这个参数的数据返回</div><div class="line">int age = pref.getInt(&quot;age&quot;, 0);</div><div class="line">boolean married = pref.getBoolean(&quot;married&quot;, false);</div></pre></td></tr></table></figure></p>
<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。</p>
<p>Android提供了一个抽象类，SQLiteOpenHelper帮助类来更加方便地管理数据库，借助这个类可以轻松地对数据库进行创建和升级。</p>
<p>SQLiteOpenHelper抽象类有两个抽象方法：</p>
<ul>
<li>onCreate()</li>
<li>onUpgrade()</li>
</ul>
<p>另外还提供了两个实例方法：</p>
<ul>
<li>getReadableDataBase() </li>
<li>getWritableDatavase()</li>
</ul>
<p>这两个方法都可以创建或者打开一个现有的数据库，没有则创建，并返回一个可对数据库进行读写操作的对象。若磁盘已满，则R方法只能读，W方法则会抛出异常。</p>
<p>SQLiteOpenHelper提供了两个可重写构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public SQLiteOpenHelper(Context context, String name, CursorFactory factory, int version)</div><div class="line">public SQLiteOpenHelper(Context context, String name, CursorFactory factory, int version,DatabaseErrorHandler errorHandler)</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>context</li>
<li>name  数据库名 默认存放在/dat/data/<package name="">/databases/</package></li>
<li>factory 查询数据返回的Cursor，一般为null</li>
<li>version 数据库版本号，可用于升级数据库</li>
</ul>
<p>执行数据库语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.execSQL(string);</div></pre></td></tr></table></figure></p>
<p>实现模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MyDatabaseHelper extends SQLiteOpenHelper &#123;</div><div class="line"> </div><div class="line">    public static final String CREATE_BOOK = &quot;create table Book (&quot;</div><div class="line">            + &quot;id integer primary key autoincrement, &quot;</div><div class="line">            + &quot;author text, &quot;</div><div class="line">            + &quot;price real, &quot;</div><div class="line">            + &quot;pages integer, &quot;</div><div class="line">            + &quot;name text)&quot;;   </div><div class="line">            </div><div class="line">    private Context mContext;</div><div class="line"></div><div class="line">    public MyDatabaseHelper(Context context, String name,</div><div class="line">                            SQLiteDatabase.CursorFactory factory, int version) &#123;</div><div class="line">        super(context, name, factory, version);</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onCreate(SQLiteDatabase db) &#123;</div><div class="line">        db.execSQL(CREATE_BOOK);</div><div class="line">        Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyDatabaseHelper dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 1);</div><div class="line">dbHelper.getWritableDatabase();</div></pre></td></tr></table></figure>
<h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static final String CREATE_CATEGORY = &quot;create table Category (&quot;</div><div class="line">            + &quot;id integer primary key autoincrement, &quot;</div><div class="line">            + &quot;category_name text, &quot;</div><div class="line">            + &quot;category_code integer)&quot;;</div><div class="line">            </div><div class="line">@Override</div><div class="line">public void onCreate(SQLiteDatabase db) &#123;</div><div class="line">    db.execSQL(CREATE_BOOK);</div><div class="line">    db.execSQL(CREATE_CATEGORY);</div><div class="line">    Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class="line">    db.execSQL(&quot;drop table if exists Book&quot;);</div><div class="line">    db.execSQL(&quot;drop table if exists Category&quot;);</div><div class="line">    onCreate(db);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyDatabaseHelper dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2);</div><div class="line">dbHelper.getWritableDatabase();</div></pre></td></tr></table></figure>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">ContentValues values = new ContentValues();</div><div class="line">// 开始组装第一条数据</div><div class="line">values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;);</div><div class="line">values.put(&quot;author&quot;, &quot;Dan Brown&quot;);</div><div class="line">values.put(&quot;pages&quot;, 454);</div><div class="line">values.put(&quot;price&quot;, 16.96);</div><div class="line">db.insert(&quot;Book&quot;, null, values); // 插入第一条数据</div><div class="line">values.clear();</div><div class="line">// 开始组装第二条数据</div><div class="line">values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;);</div><div class="line">values.put(&quot;author&quot;, &quot;Dan Brown&quot;);</div><div class="line">values.put(&quot;pages&quot;, 510);</div><div class="line">values.put(&quot;price&quot;, 19.95);</div><div class="line">db.insert(&quot;Book&quot;, null, values); // 插入第二条数据</div></pre></td></tr></table></figure>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">ContentValues values = new ContentValues();</div><div class="line">values.put(&quot;price&quot;, 10.99);</div><div class="line">db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] &#123; &quot;The Da Vinci Code&quot; &#125;);</div></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[] &#123; &quot;500&quot; &#125;);</div></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">// 查询Book表中所有的数据</div><div class="line">Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null);</div><div class="line">if (cursor.moveToFirst()) &#123;</div><div class="line">    do &#123;</div><div class="line">        // 遍历Cursor对象，取出数据并打印</div><div class="line">        String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</div><div class="line">        String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;));</div><div class="line">        int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));</div><div class="line">        double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name);</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author);</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages);</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price);</div><div class="line">    &#125; while (cursor.moveToNext());</div><div class="line">&#125;</div><div class="line">cursor.close();</div></pre></td></tr></table></figure>
<h2 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h2><p>Content Provider是Android的四大组件之一，主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。</p>
<p>内容提供器有两种用法：</p>
<ul>
<li>使用现用内容提供器来读取或者操作相应程序中的数据</li>
<li>创建自己的内容提供器供程序使用的外部接口</li>
</ul>
<p>访问内容提供器共享数据，必须使用Context.getContentResolver()静态方法获取ContentResolver对象实例来进行数据的CRUD操作。</p>
<ul>
<li>insert()</li>
<li>delete()</li>
<li>query()</li>
<li>update()</li>
</ul>
<p>不同于数据库，内容提供器的访问是安全的，其需要提供一个指定的uri才能够访问。</p>
<h3 id="访问现有内容提供器"><a href="#访问现有内容提供器" class="headerlink" title="访问现有内容提供器"></a>访问现有内容提供器</h3><p>查询现有的联系人内容提供器demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; contactsList = new ArrayList&lt;&gt;();</div><div class="line">Cursor cursor = null;</div><div class="line">try &#123;</div><div class="line">    // 查询联系人数据</div><div class="line">    cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);</div><div class="line">    if (cursor != null) &#123;</div><div class="line">        while (cursor.moveToNext()) &#123;</div><div class="line">            // 获取联系人姓名</div><div class="line">            String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));</div><div class="line">            // 获取联系人手机号</div><div class="line">            String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</div><div class="line">            contactsList.add(displayName + &quot;\n&quot; + number);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">    if (cursor != null) &#123;</div><div class="line">        cursor.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定制内容提供器"><a href="#定制内容提供器" class="headerlink" title="定制内容提供器"></a>定制内容提供器</h3><p>创建自己的内容提供器，需要去继承抽象类ContentProvider，并实现6个抽象方法，以下为模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class MyProvider extends ContentProvider &#123;</div><div class="line">    @Overrride</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        return fasle;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public Uri insert(Uri uri, ContentValues values) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public int delete(Uri uri, String selection, String[] selectionArgs) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public String getType(Uri uri) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>返回值boolean 创建是否成功</li>
<li>projection 用于确定查询哪些列</li>
<li>selection和selectionArgs用于约束查询哪些行</li>
<li>sortOder 用于对结果进行排序</li>
<li>Cursor查询结果对象</li>
<li>getType返回相应的MIME类型</li>
</ul>
<p>Uri通配符</p>
<ul>
<li>*：表示匹配任意长度的任意字符</li>
<li>#：表示匹配任意长度的数字</li>
</ul>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">public class DatabaseProvider extends ContentProvider &#123;</div><div class="line"></div><div class="line">    public static final int BOOK_DIR = 0;</div><div class="line"></div><div class="line">    public static final int BOOK_ITEM = 1;</div><div class="line"></div><div class="line">    public static final int CATEGORY_DIR = 2;</div><div class="line"></div><div class="line">    public static final int CATEGORY_ITEM = 3;</div><div class="line"></div><div class="line">    public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;;</div><div class="line"></div><div class="line">    private static UriMatcher uriMatcher;</div><div class="line"></div><div class="line">    private MyDatabaseHelper dbHelper;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);</div><div class="line">        uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR);</div><div class="line">        uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM);</div><div class="line">        uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR);</div><div class="line">        uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;</div><div class="line">        // 查询数据</div><div class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</div><div class="line">        Cursor cursor = null;</div><div class="line">        switch (uriMatcher.match(uri)) &#123;</div><div class="line">            case BOOK_DIR:</div><div class="line">                cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder);</div><div class="line">                break;</div><div class="line">            case BOOK_ITEM:</div><div class="line">                String bookId = uri.getPathSegments().get(1);</div><div class="line">                cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] &#123; bookId &#125;, null, null, sortOrder);</div><div class="line">                break;</div><div class="line">            case CATEGORY_DIR:</div><div class="line">                cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder);</div><div class="line">                break;</div><div class="line">            case CATEGORY_ITEM:</div><div class="line">                String categoryId = uri.getPathSegments().get(1);</div><div class="line">                cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;, null, null, sortOrder);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return cursor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Uri insert(Uri uri, ContentValues values) &#123;</div><div class="line">        // 添加数据</div><div class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">        Uri uriReturn = null;</div><div class="line">        switch (uriMatcher.match(uri)) &#123;</div><div class="line">            case BOOK_DIR:</div><div class="line">            case BOOK_ITEM:</div><div class="line">                long newBookId = db.insert(&quot;Book&quot;, null, values);</div><div class="line">                uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId);</div><div class="line">                break;</div><div class="line">            case CATEGORY_DIR:</div><div class="line">            case CATEGORY_ITEM:</div><div class="line">                long newCategoryId = db.insert(&quot;Category&quot;, null, values);</div><div class="line">                uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return uriReturn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123;</div><div class="line">        // 更新数据</div><div class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">        int updatedRows = 0;</div><div class="line">        switch (uriMatcher.match(uri)) &#123;</div><div class="line">            case BOOK_DIR:</div><div class="line">                updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs);</div><div class="line">                break;</div><div class="line">            case BOOK_ITEM:</div><div class="line">                String bookId = uri.getPathSegments().get(1);</div><div class="line">                updatedRows = db.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] &#123; bookId &#125;);</div><div class="line">                break;</div><div class="line">            case CATEGORY_DIR:</div><div class="line">                updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs);</div><div class="line">                break;</div><div class="line">            case CATEGORY_ITEM:</div><div class="line">                String categoryId = uri.getPathSegments().get(1);</div><div class="line">                updatedRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return updatedRows;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int delete(Uri uri, String selection, String[] selectionArgs) &#123;</div><div class="line">        // 删除数据</div><div class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</div><div class="line">        int deletedRows = 0;</div><div class="line">        switch (uriMatcher.match(uri)) &#123;</div><div class="line">            case BOOK_DIR:</div><div class="line">                deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs);</div><div class="line">                break;</div><div class="line">            case BOOK_ITEM:</div><div class="line">                String bookId = uri.getPathSegments().get(1);</div><div class="line">                deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] &#123; bookId &#125;);</div><div class="line">                break;</div><div class="line">            case CATEGORY_DIR:</div><div class="line">                deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs);</div><div class="line">                break;</div><div class="line">            case CATEGORY_ITEM:</div><div class="line">                String categoryId = uri.getPathSegments().get(1);</div><div class="line">                deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return deletedRows;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getType(Uri uri) &#123;</div><div class="line">        switch (uriMatcher.match(uri)) &#123;</div><div class="line">            case BOOK_DIR:</div><div class="line">                return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.book&quot;;</div><div class="line">            case BOOK_ITEM:</div><div class="line">                return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.book&quot;;</div><div class="line">            case CATEGORY_DIR:</div><div class="line">                return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.category&quot;;</div><div class="line">            case CATEGORY_ITEM:</div><div class="line">                return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.category&quot;;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/30/ble-helper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/30/ble-helper/" itemprop="url">Android的BLE简易收发助手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-30T11:41:48+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android简易蓝牙BLE收发助手"><a href="#Android简易蓝牙BLE收发助手" class="headerlink" title="Android简易蓝牙BLE收发助手"></a>Android简易蓝牙BLE收发助手</h1><blockquote>
<p>本文参考<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html" target="_blank" rel="external">Android开发者说明文档</a>，<br>通过制作一个简易的BLE收发助手，和外置BLE模块进行通信，来学习Android的BLE开发基础知识。</p>
<p>GitHub源码：<a href="https://github.com/ZehaoLin/BluetoothLeHelper" target="_blank" rel="external">Android简易BLE收发助手</a>、<a href="https://github.com/googlesamples/android-BluetoothLeGatt" target="_blank" rel="external">Android官方BluetoothLeGatt源码</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从Android4.3（API 18）开始，Android开始支持低功耗蓝牙（Bluetooth Low Energy, BLE）<br>功能，也就是Bluetooth 4.0版本，相比之前的蓝牙功能，BLE最显著的特点是功耗更低。基于Android<br>系统API开发的App，可以通过BLE查找其他设备、查询服务、读写特征值（Characterstic）。现<br>在BLE已基本取代了旧版本的蓝牙，特别是现在嵌入式设备（智能手表手环、无线耳机等）越来越多，<br>基本用的都是BLE。最近蓝牙协议已经升级到5.0版本，效率等大幅度提高。目前三星S8和小米6已支持蓝牙5.0。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="抽象概念"><a href="#抽象概念" class="headerlink" title="抽象概念"></a>抽象概念</h3><p>在进行开发之前，需要对蓝牙协议栈的构架有一定的了解，特别是一些关键性名词。可以参考笔者简陋的总结：<a href="">BLE协议栈简析</a>。</p>
<p>BLE协议栈有三个层次，分别是物理层Controller、主机协议封装Host、应用Apps。</p>
<p>三个层次中，对于开发来说比较重要的是Host，里面主要包含：</p>
<ul>
<li><p>ATT（Attibute Protocal）</p>
<p>  属性协议，是BLE通信的基础，ATT封装数据，向外暴露为“属性”，提供“属性”的为服务端，读取“属性”的为客户端。</p>
</li>
<li><p>GATT（Generic Attribute Profile）</p>
<p>  通用属性配置文件，建立在ATT的基础上，对ATT做进一步的逻辑封装，定义数据的交互方式和含义。每个GATT里面包含3个层次：服务（service）、特征（Characteristic）、描述（Descriptor）。</p>
</li>
<li><p>GAP（Generic Access Profile）</p>
<p>  停用访问控制配置文件。它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。</p>
</li>
</ul>
<p>GATT最外层是Profile配置文件，里面又包含了服务（service）、特征（Characteristic）、描述（Descriptor），他们之间的关系是一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。</p>
<p>GATT里面包含的服务、特征和描述都是多个的，BLE通过UUID来标识区分。</p>
<p>UID 是全球唯一标识符，它是 128bit 的值，为了便于识别和阅读，一般写成8-4-4-12 的16进制形式。如123e4567-e89b-12d3-a456-426655440000。16-bit的蓝牙基本UUID形式为 0000XXXX-0000-1000-8000-00805f9b34fb。实际UUID为128位，但是除了XXXX部分需要更改，其他的基本一致，这样对于BLE的数据非常受限的设备使用起来更加方便。Android中为了避免UUID的冲突，可以使用UUID.randomUUID()方法来生成一个随机的UUID。</p>
<h3 id="外设模块"><a href="#外设模块" class="headerlink" title="外设模块"></a>外设模块</h3><p>笔者在完成低功耗蓝牙收发助手的程序测试的时候，采用的BLE透传模块为CC2541（可在某宝上搜索），基于蓝牙4.0，对于玩单片机或者嵌入式的爱好者来说，这个是很常见的，可以用于蓝牙小车，小四轴飞行器等小智能硬件设备。</p>
<p>在透传模块给出的AT指令集里，指明了可以通过串口助手向BLE模块发送AT指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 开发正文</div><div class="line">先看一下简易的主界面图</div><div class="line">![image](http://linzhs.cn/img/ble_helper_main_activity.png) 。</div><div class="line"></div><div class="line">主界面中上半部分为数据的接收区，下半部分为发送数据编辑框，发送按钮（其实应该加入字符和hex格式的数据接收或发送方式的选择的）。点击工具单栏上的菜单选项可进行蓝牙设备搜索和连接。</div><div class="line"></div><div class="line">程序的运行思路是：主界面启动的时候，去建立自定义BLE后台服务链接，服务和MainActivity之间通过Broadcast来通信，所以还需要在MainActivity的生命周期中注册、BroadcastReceiver。完成服务、广播、界面的初始化工作后，点击链接BLE设备启动ScanActivity来搜索蓝牙设备，将识别到的外设（当前只能识别Android以外的BLE模块）显示在Activity的RecyclerView中，若点击其中一个蓝牙，则自动获取BLE的名称地址，然后退出扫描活动，将BLE的名称和地址返回主活动建立链接，接下来根据主界面的命令，向后台蓝牙服务发出读写Characteristic操作来完成与外部设备的通信，这个读写操作中需要用到UUID。</div><div class="line"></div><div class="line">Android使用BLE需要开启以下两个权限：</div></pre></td></tr></table></figure></p>
<!-- 使用蓝牙的权限 -->
<p><uses-permission android:name="android.permission.BLUETOOTH"><br><!-- 修改配置蓝牙属性的权限，相当于获取蓝牙管理员身份 --></uses-permission></p>
<p><uses-permission android:name="android.permission.BLUETOOTH_ADMIN"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">MainActivity中建立、断开绑定BLE服务，注册、注销通信广播：</div></pre></td></tr></table></figure></uses-permission></p>
<p>@Override<br>protected void onCreate(Bundle savedInstanceState) {<br>    super.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_main);</p>
<pre><code>// initial View...

//绑定BLE收发服务
Intent gattServiceIntent = new Intent(this, BluetoothLeService.class);
bindService(gattServiceIntent, mServiceConnection, BIND_AUTO_CREATE);
</code></pre><p>}</p>
<p>@Override<br>protected void onResume() {<br>    super.onResume();</p>
<pre><code>//注册BLE收发服务广播接收器mGattUpdateReceiver
registerReceiver(mGattUpdateReceiver, makeGattUpdateIntentFilter());
if (mBluetoothLeService != null) {
    Log.d(TAG, &quot;onResume: mBluetoothLeService NOT null&quot;);
}
</code></pre><p>}</p>
<p>@Override<br>protected void onPause() {<br>    super.onPause();</p>
<pre><code>//注销BLE收发服务广播接收器
unregisterReceiver(mGattUpdateReceiver);
</code></pre><p>}</p>
<p>@Override<br>protected void onDestroy() {<br>    super.onDestroy();</p>
<pre><code>//解绑BLE收发服务
unbindService(mServiceConnection);
mBluetoothLeService = null;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">后台BluetoothLeService连接后的回调和广播通信接受者：</div></pre></td></tr></table></figure></p>
<p>// Code to manage Service lifecycle.<br>// 管理BLE数据收发服务整个生命周期<br>private final ServiceConnection mServiceConnection = new ServiceConnection() {<br>    @Override<br>    public void onServiceConnected(ComponentName name, IBinder service) {<br>        mBluetoothLeService = ((BluetoothLeService.LocalBinder) service).getService();<br>        if (!mBluetoothLeService.initialize()) {<br>            Log.e(TAG, “onServiceConnected: Unable to initialize Bluetooth”);<br>            finish();<br>        }<br>    }</p>
<pre><code>@Override
public void onServiceDisconnected(ComponentName name) {
    mBluetoothLeService = null;
}
</code></pre><p>};</p>
<p>// Handles various events fired by the Service.<br>// ACTION_GATT_CONNECTED: connected to a GATT server.<br>// ACTION_GATT_DISCONNECTED: disconnected from a GATT server.<br>// ACTION_GATT_SERVICES_DISCOVERED: discovered GATT services.<br>// ACTION_DATA_AVAILABLE: received data from the device.  This can be a result of read<br>//                        or notification operations.<br>// 定义处理BLE收发服务的各类事件接收机mGattUpdateReceiver，主要包括下面几种：<br>// ACTION_GATT_CONNECTED: 连接到GATT<br>// ACTION_GATT_DISCONNECTED: 断开GATT<br>// ACTION_GATT_SERVICES_DISCOVERED: 发现GATT下的服务<br>// ACTION_DATA_AVAILABLE: BLE收到数据<br>private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() {<br>    @Override<br>    public void onReceive(Context context, Intent intent) {<br>        final String action = intent.getAction();</p>
<pre><code>    if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) {
        mConnected = true;
    } else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) {
        mConnected = false;
    } else if (BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
        // Show all the supported services and characteristics on the user interface.
        // 获得所有的GATT服务，对于BLE透传模块，包括GAP（General Access Profile），
        // GATT（General Attribute Profile），还有Unknown（用于数据读取）
        mBluetoothLeService.getSupportedGattServices();
    } else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) {
           bleReceiveText.setText(intent.getStringExtra(BluetoothLeService.EXTRA_DATA));
        }
    }
}
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">广播中有四种隐式意图，都是在BluetoothLeService，也就是自定义后台服务中定义的，分别为链接到GATT、断开GATT、搜索到GATT服务、BLE收到数据，根据四个不同的广播状态来完成相应的标志位或者显示操作。</div><div class="line"></div><div class="line">以上的工作只是初始化，还需要建立扫描蓝牙的界面操作工作，选择菜单栏上的选项，来完成蓝牙的连接和断开。</div></pre></td></tr></table></figure></p>
<p>@Override<br>public boolean onOptionsItemSelected(MenuItem item) {<br>    switch (item.getItemId()) {<br>        case R.id.menu_connect_ble:<br>            if (!mConnected) {// 若未连接蓝牙，则进入蓝牙扫描连接activity<br>                Intent serverIntent = new Intent(this, DeviceScanActivity.class);<br>                startActivityForResult(serverIntent, REQUEST_CONNECT_DEVICE);<br>            } else {<br>                mBluetoothLeService.disconnect();<br>            }<br>            break;<br>    }</p>
<pre><code>return true;
</code></pre><p>}</p>
<p>@Override<br>protected void onActivityResult(int requestCode, int resultCode, Intent data) {<br>    switch (requestCode) {<br>        case REQUEST_CONNECT_DEVICE:<br>            if (resultCode == Activity.RESULT_OK) {<br>                // 获取准备建立连接的蓝牙设备地址和名字<br>                mDeviceName = data.getExtras().getString(EXTRAS_DEVICE_NAME);<br>                mDeviceAddress = data.getExtras().getString(EXTRAS_DEVICE_ADDRESS);</p>
<pre><code>            Log.i(TAG, &quot;onActivityResult: &quot; + &quot;mDeviceName: &quot; + mDeviceName + &quot;, mDeviceAddress:&quot; + mDeviceAddress);

            //连接该BLE模块
            if (mBluetoothLeService != null) {
                final boolean result = mBluetoothLeService.connect(mDeviceAddress);
                Log.d(TAG, &quot;onActivityResult: Connect request result = &quot; + result);
            }
        }
        break;
    default:
        break;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">蓝牙设备的扫描工作都放置在DeviceScanActivity中，从主活动切换到这个活动中，在完成前台显示前，先完成Android设备的蓝牙检测和初始化工作，在onPause中还需要去检查Android是否还在进行扫描，若是则关闭扫描操作，整个生命周期的操作:</div></pre></td></tr></table></figure></p>
<p>@Override<br>protected void onCreate(Bundle savedInstanceState) {<br>    super.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_device_scan);</p>
<pre><code>ActionBar actionBar = getSupportActionBar();
if (actionBar != null) {
    actionBar.setTitle(&quot;Scan Bluetooth Device&quot;);
    actionBar.setDisplayHomeAsUpEnabled(true);
}

// Initializes recycler view adapter.
RecyclerView recyclerView = (RecyclerView)findViewById(R.id.le_device_recycler_view);
LinearLayoutManager layoutManager = new LinearLayoutManager(this);
recyclerView.setLayoutManager(layoutManager);
mLeDeviceListAdapter = new LeDeviceListAdapter();
recyclerView.setAdapter(mLeDeviceListAdapter);

mLeDeviceListAdapter.setOnItemClickListener(new LeDeviceListAdapter.OnItemClickListener() {
    @Override
    public void onItemClick(View view, int position) {
        final BluetoothDevice device = mLeDeviceListAdapter.getDevice(position);
        if (device == null) return;
        final Intent intent = new Intent();
        intent.putExtra(MainActivity.EXTRAS_DEVICE_NAME, device.getName());
        intent.putExtra(MainActivity.EXTRAS_DEVICE_ADDRESS, device.getAddress());
        if (isScanning) {
            mBluetoothLeScanner.stopScan(mLeScanCallback);
            //mBluetoothAdapter.stopLeScan(mLeScanCallback);
            isScanning = false;
        }
        Log.d(TAG, &quot;onItemClick: start bluetooth control activity.&quot;);

        //设置返回值并结束程序
        setResult(RESULT_OK, intent);
        finish();
    }
});

mHandler = new Handler();

// Use this check to determine whether BLE is supported on the device.  Then you can
// selectively disable BLE-related features.
if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
    Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
    finish();
}

// Initializes a Bluetooth adapter.  For API level 18 and above, get a reference to
// BluetoothAdapter through BluetoothManager.
final BluetoothManager bluetoothManager =
        (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
mBluetoothAdapter = bluetoothManager.getAdapter();

// Checks if Bluetooth is supported on the device.
if (mBluetoothAdapter == null) {
    Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
    finish();
    return;
}
</code></pre><p>}</p>
<p>@Override<br>protected void onResume() {<br>    super.onResume();</p>
<pre><code>// Ensures Bluetooth is enabled on the device.  If Bluetooth is not currently enabled,
// fire an intent to display a dialog asking the user to grant permission to enable it.
if (!mBluetoothAdapter.isEnabled()) {
    if (!mBluetoothAdapter.isEnabled()) {
        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
    }
}

mBluetoothLeScanner = mBluetoothAdapter.getBluetoothLeScanner();//获取蓝牙扫描器实例
scanLeDevice(true);
</code></pre><p>}</p>
<p>@Override<br>protected void onPause() {<br>    super.onPause();</p>
<pre><code>scanLeDevice(false);
mLeDeviceListAdapter.clear();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BLE的扫描从API21 开始就不太一样了，之前使用BluetoothAdapter.startLeScan和BluetoothAdapter.stopLeScan来完成，API21开始弃用这两个方法，改成由```BluetoothAdapter.getBluetoothLeScanner()```来获取BLE扫描器，用这个对象来完成扫描的工作。</div><div class="line"></div><div class="line">扫描方法和扫描结果回调：</div></pre></td></tr></table></figure></p>
<p>//扫描蓝牙设备<br>private void scanLeDevice(final boolean enable) {<br>    if (enable) {//使能扫描<br>        //将Runnable接口对象装入消息队列(message queue)每隔一段时间(SCAN_PERIOD)执行Runnable的run方法<br>        mHandler.postDelayed(new Runnable() {<br>            @Override<br>            public void run() {//循环周期到，标志位复位，关闭扫描<br>                isScanning = false;<br>                mBluetoothLeScanner.stopScan(mLeScanCallback);<br>                //mBluetoothAdapter.stopLeScan(mLeScanCallback);//此方法API21开始已被弃用<br>                invalidateOptionsMenu();<br>            }<br>        }, SCAN_PERIOD);</p>
<pre><code>    isScanning = true;
    mBluetoothLeScanner.startScan(mLeScanCallback);
    //mBluetoothAdapter.startLeScan(mLeScanCallback);
} else {//关闭扫描
    isScanning = false;
    mBluetoothLeScanner.stopScan(mLeScanCallback);
    //mBluetoothAdapter.stopLeScan(mLeScanCallback);
}
invalidateOptionsMenu();
</code></pre><p>}</p>
<p>// 扫描结果回调<br>private ScanCallback mLeScanCallback = new ScanCallback() {<br>    @Override<br>    public void onScanResult(int callbackType, ScanResult result) {//扫描结果<br>        //super.onScanResult(callbackType, result);<br>        final BluetoothDevice device = result.getDevice();<br>        runOnUiThread(new Runnable() {<br>            @Override<br>            public void run() {<br>                mLeDeviceListAdapter.addDevice(device);<br>                //刷新RecyclerView<br>                mLeDeviceListAdapter.notifyDataSetChanged();<br>            }<br>        });<br>    }</p>
<pre><code>@Override
public void onBatchScanResults(List&lt;ScanResult&gt; results) {//批量结果
    super.onBatchScanResults(results);
}

@Override
public void onScanFailed(int errorCode) {//扫描失败
    super.onScanFailed(errorCode);
}
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## BLE后台服务</div><div class="line">UUID的设置：</div></pre></td></tr></table></figure></p>
<p>//用于数据接收、发送的service和character对应的UUID，由改ble透传模块决定<br>public final static UUID UUID_NOTIFY =<br>        UUID.fromString(“0000ffe1-0000-1000-8000-00805f9b34fb”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BLE通信管理对象初始化：</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>Initializes a reference to the local Bluetooth adapter.<br>*</li>
<li><p>@return Return true if the initialization is successful.<br>*/<br>public boolean initialize() {<br> // For API level 18 and above, get a reference to BluetoothAdapter through<br> // BluetoothManager.<br> if (mBluetoothManager == null) {</p>
<pre><code>mBluetoothManager = (BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);
if (mBluetoothManager == null) {
    Log.e(TAG, &quot;initialize: Unable to initialize BluetoothManager&quot;);
    return false;
}
</code></pre><p> }</p>
<p> mBluetoothAdapter = mBluetoothManager.getAdapter();<br> if (mBluetoothAdapter == null) {</p>
<pre><code>Log.e(TAG, &quot;initialize: Unable to obtain a BluetoothAdapter&quot;);
return false;
</code></pre><p> }</p>
<p> return true;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">建立BLE链接和断开链接：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>Connects to the GATT server hosted on the Bluetooth LE device.<br>*</li>
<li>@param address The device address of the destination device.<br>*</li>
<li>@return Return true if the connection is initiated successfully. The connection result</li>
<li>is reported asynchronously through the</li>
<li>{@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}</li>
<li><p>callback.<br>*/<br>public boolean connect(final String address) {<br>if (mBluetoothAdapter == null || address == null) {<br>Log.w(TAG, “connect: BluetoothAdapter not initialized or unspecified address”);<br>return false;<br>}</p>
<p>// Previously connected device.  Try to reconnect.<br>if (mBluetoothDeviceAddress != null &amp;&amp; address.equals(mBluetoothDeviceAddress)<br> &amp;&amp; mBluetoothGatt != null) {<br>Log.d(TAG, “Trying to use an existing mBluetoothGatt for connection.”);<br>if (mBluetoothGatt.connect()) {<br> mConnectionState = STATE_CONNECTING;<br> return true;<br>} else {<br> return false;<br>}<br>}</p>
<p>final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);<br>if (device == null) {<br>Log.w(TAG, “Device not found.  Unable to connect.”);<br>return false;<br>}<br>// We want to directly connect to the device, so we are setting the autoConnect<br>// parameter to false.<br>mBluetoothGatt = device.connectGatt(this, false, mGattCallback);<br>Log.d(TAG, “Trying to create a new connection.”);<br>mBluetoothDeviceAddress = address;<br>mConnectionState = STATE_CONNECTING;</p>
<p>return true;<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>Disconnects an existing connection or cancel a pending connection. The disconnection result</li>
<li>is reported asynchronously through the</li>
<li>{@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}</li>
<li><p>callback.<br>*/<br>public void disconnect() {<br> if (mBluetoothAdapter == null || mBluetoothGatt == null) {</p>
<pre><code>Log.w(TAG, &quot;BluetoothAdapter not initialized&quot;);
return;
</code></pre><p> }</p>
<p> mBluetoothGatt.disconnect();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">建立GATT服务后，数据、链接变动的回调，根据不同的回调结果，将要处理的信息以广播的形式发送给主活动：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>// Implements callback methods for GATT events that the app cares about.  For example,<br>    // connection change and services discovered.<br>private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {<br>    @Override<br>    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {<br>        String intentAction;<br>        if (newState == BluetoothProfile.STATE_CONNECTED) {<br>            intentAction = ACTION_GATT_CONNECTED;<br>            mConnectionState = STATE_CONNECTED;<br>            broadcastUpdate(intentAction);</p>
<pre><code>        Log.i(TAG, &quot;Connected to GATT server.&quot;);
        // Attempts to discover services after successful connection.
        Log.i(TAG, &quot;Attempting to start service discovery:&quot; +
                mBluetoothGatt.discoverServices());
    } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
        intentAction = ACTION_GATT_DISCONNECTED;
        mConnectionState = STATE_DISCONNECTED;
        Log.i(TAG, &quot;Disconnected from GATT server.&quot;);
        broadcastUpdate(intentAction);
    }
}

@Override
public void onServicesDiscovered(BluetoothGatt gatt, int status) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
        broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);
    } else {
        Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status);
    }
}

@Override
public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
        broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
    }
}

@Override
public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
    broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
}
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其中，需要携带接收到数据的广播如下，接收到的是byte数组，需要进行数据处理，这里将其装换为hex，十六进制。</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>发送携带数据广播</li>
<li>@param action</li>
<li><p>@param characteristic<br>*/<br>private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) {<br> final Intent intent = new Intent(action);</p>
<p> final byte[] data = characteristic.getValue();//读取BLE接收到的数据</p>
<p> if (data != null &amp;&amp; data.length &gt; 0) {</p>
<pre><code>final StringBuilder stringBuilder = new StringBuilder(data.length);
for(byte byteChar : data)
    stringBuilder.append(String.format(&quot;%02X &quot;, byteChar));
intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString());

Log.i(TAG, &quot;broadcastUpdate: RX Data is &quot; + stringBuilder);
</code></pre><p> }</p>
<p> //intent.putExtra(EXTRA_DATA, data);<br> sendBroadcast(intent);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">发送数据到BLE外设，则是向Characteristic中写入数据，BLE会将其自动发出。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>写入数据到Characteristic 从BLE发送出去</li>
<li><p>@param data<br>*/<br>public void writeCharacteristic(byte[] data)<br>{<br> if (mBluetoothAdapter == null || mBluetoothGatt == null) {</p>
<pre><code>Log.w(TAG, &quot;BluetoothAdapter not initialized&quot;);
return;
</code></pre><p> }</p>
<p> mNotifyCharacteristic.setValue(data);<br> mBluetoothGatt.writeCharacteristic(mNotifyCharacteristic);<br>}<br>```</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/30/ble-protocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/30/ble-protocal/" itemprop="url">BLE协议栈简析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-30T11:36:45+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BLE协议栈简析"><a href="#BLE协议栈简析" class="headerlink" title="BLE协议栈简析"></a>BLE协议栈简析</h1><blockquote>
<p>本文针对蓝牙4.0，也就是低功耗蓝牙BLE的协议栈进行简单分析。</p>
</blockquote>
<h2 id="Arch图"><a href="#Arch图" class="headerlink" title="Arch图"></a>Arch图</h2><p>以下为蓝牙协议栈架构图：<br><img src="http://7rf9ir.com1.z0.glb.clouddn.com/Android-BLE-in-Action.005.jpeg" alt=""></p>
<p>蓝牙协议栈分为三个层次，从底层到顶层的名字和其所起到的作用分别如下：</p>
<ul>
<li><p>Controller</p>
<p>  这一层主要是物理层，定义了蓝牙工作的频段（2.4GHz）和频段的通道、广播等。Host层和Controller层之间有个接口层，这个接口建立了Host和Controller之间的交互，也是顶层的应用和芯片的交互关键通道。</p>
</li>
<li><p>Host</p>
<p>  这一层相对比较复杂，包含了裸机链路控制、适配协议、安全管理、GATT、ATT、GAP等。</p>
<p>  ATT（Attibute Protocal），属性协议，是BLE通信的基础，ATT封装数据，向外暴露为“属性”，提供“属性”的为服务端，读取“属性”的为客户端。</p>
<p>  GATT（Generic Attribute Profile），通用属性配置文件，建立在ATT的基础上，对ATT做进一步的逻辑封装，定义数据的交互方式和含义。每个GATT里面包含3个层次：服务（service）、特征（Characteristic）、描述（Descriptor）。</p>
<p>  GAP（Generic Access Profile），停用访问控制配置文件。它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。</p>
</li>
<li><p>Applications</p>
<p>  这一层为BLE的应用层，可分为两大类，分别为基于连接和非连接。</p>
<p>  基于非连接的也叫Beacon，依赖于BLE的广播，常用语BLE搜索其他设备。这里的BLE存在两种角色，发送广播方为Broadcaster，监听广播方为Observer。</p>
<p>  基于连接的需要通过GATT连接来收发数据。这里的BLE也存在两种角色，分别是中心主机设备Central，和被连接的从机外设Peripheral。</p>
</li>
</ul>
<h2 id="GATT内部层次"><a href="#GATT内部层次" class="headerlink" title="GATT内部层次"></a>GATT内部层次</h2><p>GATT内部抽象图：<br><img src="http://7rf9ir.com1.z0.glb.clouddn.com/Android-BLE-in-Action.008.jpeg" alt="image"><br>GATT最外层是Profile配置文件，里面又包含了服务（service）、特征（Characteristic）、描述（Descriptor），他们之间的关系是一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。</p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>Service、Characteristic 还有 Descriptor 之间都是使用 UUID 唯一标识来区分的。</p>
<p>UID 是全球唯一标识符，它是 128bit 的值，为了便于识别和阅读，一般写成8-4-4-12 的16进制形式。如123e4567-e89b-12d3-a456-426655440000。</p>
<p>16-bit的蓝牙基本UUID形式为 0000XXXX-0000-1000-8000-00805f9b34fb。实际UUID为18位，但是除了XXXX部分需要更改，其他的基本一致，这样对于BLE的数据非常受限的设备使用起来更加方便。</p>
<p>Android中为了避免UUID的冲突，可以使用UUID.randomUUID()方法来生成一个随机的UUID。</p>
<p>16-bit的UUID数量只有65536个，数量远不如128-bit的，所以官方事先保留了一些UIID，若是16-bit的基本UUID不够用，可以选择购买。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="https://race604.com/android-ble-in-action/" target="_blank" rel="external">Android 上的低功耗蓝牙实践</a></p>
</li>
<li><p><a href="https://race604.com/gatt-profile-intro/" target="_blank" rel="external">GATT Profile 简介</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/21/android-activity-startmode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/21/android-activity-startmode/" itemprop="url">Android中Activity的启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T01:16:52+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android中Activity的启动模式"><a href="#Android中Activity的启动模式" class="headerlink" title="Android中Activity的启动模式"></a>Android中Activity的启动模式</h2><p>在Android中，每一个任务（应用程序）都有一个放回栈（back stack），每一个应用都有一到多个Activity，返回栈就是来存储这些活动的，当Activity处于栈顶的时候，该Activity也是正显示在手机屏幕上的。若用户按下“返回”按钮后，一个Activity将会被弹出栈，也就等于被销毁，而前一个Activity也将被执行。返回栈中永远不会重新排序，而是根据入栈和出栈的顺序来排列的。</p>
<p>在没有设置Activity的启动模式的时候，栈是可以被重复创建的，比如一个应用有很多个Activity，这些Activity大部分都可以创建同一个Activity，那么每次创建都会被推入栈中，返回栈也就有了多次被实例化的Activity。</p>
<p>Activity和任务的默认行为如下：</p>
<ul>
<li>当 Activity A 启动 Activity B 时，Activity A 将会停止，但系统会保留其状态（例如，滚动位置和已输入表单中的文本）。如果用户处于Activity B时按“返回”按钮，则Activity A将恢复其状态，继续运行。（活动与活动之间如何进行数据交流，活动怎么在一个应用程序的生命周期中保存好自己的关键数据，以防中途活动被销毁后，又要从头开始加载，丢失关键数据？这些问题将在另一篇随笔上做总结）</li>
<li>用户通过按下Home键按钮离开任务时，当前Activity将停止运行，并且任务会将入后台。系统将保留任务中的每个Activity的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务又会回到前台并恢复当前任务返回栈栈顶的Activity继续执行。</li>
<li>如果用户按“返回”按钮，则当前 Activity 会从堆栈弹出并被销毁。 堆栈中的前一个 Activity 恢复执行。销毁 Activity 时，系统不会保留该 Activity 的状态。</li>
<li>当前任务的Activity也可以被其他任务多次实例化。</li>
</ul>
<h3 id="自定义Activity的启动模式"><a href="#自定义Activity的启动模式" class="headerlink" title="自定义Activity的启动模式"></a>自定义Activity的启动模式</h3><p>我们可以为每个Activity定义一种启动模式，注册的方法就是在<a href="">AndroidManifest.xml</a>文件声明时，为相应的Activity元素加上launchMode属性，并且指定该属性为如下一种：</p>
<ul>
<li>“standard”（默认标准模式）</li>
</ul>
<p>这个标准模式是默认的启动模式。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。默认模式下的Activity可以被多次实例化，而且每个实例都可以属于不用的任务，并且一个任务可以拥有多个实例，举个例子，比如我们现在界面上有个按钮，点击按钮就会启动一个新的活动，这个活动是默认模式的，新的活动里也有一个按钮，这个新的按钮还是启动这个新的界面，所以每个当我们点击按钮后，同一个Activity将会多多次实例化，实例化了多少次，就要按下“返回”按钮来销毁多少次。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>在“singleTop”模式下，如果当前的任务的栈顶已经存在此种模式的Activity实例，那么系统会通过调用该实例的<a href="">onNewIntent()</a>方法向其传输intent，而不是创建Activity新的实例。也就是说，在“singleTop”模式下，如果活动位于栈顶，那么此活动只会被实例化一次，若不是在栈顶，那么还是会被多次实例化。</p>
<p>例如，假设任务的返回栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈是 A-B-C-D；D 位于顶部）。收到针对 D 类 Activity 的 Intent。如果 D 具有默认的 “standard” 启动模式，则会启动该类的新实例，且堆栈会变成 A-B-C-D-D。但是，如果 D 的启动模式是 “singleTop”，则 D 的现有实例会通过 onNewIntent() 接收 Intent，因为它位于堆栈的顶部；而堆栈仍为 A-B-C-D。但是，如果收到针对 B 类 Activity 的 Intent，则会向堆栈添加 B 的新实例，即便其启动模式为 “singleTop” 也是如此。</p>
<blockquote>
<p>注：为某个 Activity 创建新实例时，用户可以按“返回”按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 onNewIntent() 之前，用户无法按“返回”按钮返回到 Activity 的状态。</p>
</blockquote>
<ul>
<li>“singleTask”</li>
</ul>
<p>当前活动的模式如果是“singleTask”模式，拿每次启动该活动时系统首先会在返回栈中检查是否存在该实例，如果发现先已经存在则不会重新实例化，而是使用已经存在的，则系统会通过调用现有实例的 <a href="">onNewIntent()</a> 方法向其传送 Intent，并把这个活动统统出栈，让这个活动处于栈顶，如果返回栈中没有该活动的实例，则会创建一个新的实例。</p>
<ul>
<li>“singleInstance”</li>
</ul>
<p>“singleInstance”模式下的活动比较特别，该活动会被系统单独放在一个返回栈上去管理，这个活动在整个应用程序的生命里面只有一个实例，这个和单例模式很像了。在这种模式下，这个活动是共享的，也可以被其他应用程序调用。</p>
<h3 id="动态设置Activity启动模式"><a href="#动态设置Activity启动模式" class="headerlink" title="动态设置Activity启动模式"></a>动态设置Activity启动模式</h3><p>在程序中用startActivity()启动Activity的时候，可以在Intent中加入相应的标志来修改Activity与其他任务的默认关联方式。可用于修改的标志如下所示：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。这个状态与”singlTask”模式是一样的。</p>
<ul>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。这种模式与“singleTop”模式一致。</p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
</ul>
<p>如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP 通常与 FLAG_ACTIVITY_NEW_TASK 结合使用。一起使用时，通过这些标志，可以找到其他任务中的现有 Activity，并将其放入可从中响应 Intent 的位置。</p>
<h3 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h3><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。 当用户再次返回到任务时，仅恢复根 Activity。系统这样做的原因是，经过很长一段时间后，用户可能已经放弃之前执行的操作，返回到任务是要开始执行新的操作。</p>
<p>可以使用下列几个 Activity 属性修改此行为：</p>
<ul>
<li>alwaysRetainTaskState</li>
</ul>
<p>如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。</p>
<ul>
<li>clearTaskOnLaunch</li>
</ul>
<p>如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。</p>
<ul>
<li>finishOnTaskLaunch</li>
</ul>
<p>此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/21/android-lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/21/android-lifecycle/" itemprop="url">Android中Activity、Fragment、Service的生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T01:15:48+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android中Activity、Fragment、Service的生命周期"><a href="#Android中Activity、Fragment、Service的生命周期" class="headerlink" title="Android中Activity、Fragment、Service的生命周期"></a>Android中Activity、Fragment、Service的生命周期</h1><blockquote>
<p>在Android系统中，常见的应用组件都有它的生命周期，以便于系统对内存的管理，接下来总结一下Activity，Fragment，Service这三个常见、重要的组件的生命周期。</p>
</blockquote>
<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p>用回调方法的方式来管理Activity的生命周期对于开发强大、灵活的应用来说那是至关重要的。Activity的生命周期会直接影响到其他Activity、其任务和返回栈。</p>
<p>Activity有三种状态存在：</p>
<ul>
<li>运行状态</li>
</ul>
<p>此时Activity处于屏幕的前台，可以与用户进行交互，具有用户焦点。</p>
<ul>
<li>暂停状态</li>
</ul>
<p>我们经常会遇到这种情况：屏幕上出现一个对话框，或者加载动画框，从屏幕下面弹出不会沾满屏幕的一个选项卡，而且在屏幕里面还能看到另一个界面。对于这种情况，另一个Activity位于屏幕前台并且具有用户焦点，但在背后的Activity仍然可见。也就是说，另一个Activity显示在此Activity的上方，并且Activity部分透明或者未被覆盖整个屏幕，我们把这个时候的Activity成为暂停状态。</p>
<p>暂停状态的Activity仍然处于完全活动的状态（Activity对象保留在内存中，它保留了所有状态和成员信息，并与窗口管理器 保持连接），但是这个状态的Activity在内存不足的时候，也会被系统终止并且回收。处于此状态的Activity一般不要做太多事情，在正常切换的时候如果有太多占用时间的任务完成，那么有可能会导致卡顿的情况，影响了用户体验。</p>
<ul>
<li>停止状态</li>
</ul>
<p>当一个Activity被另一个Activity完全覆盖的时候，也就进入了后台。已停止的 Activity 同样仍处于活动状态（Activity 对象保留在内存中，它保留了所有状态和成员信息，但未与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。</p>
<p>如果 Activity 处于暂停或停止状态，系统可通过要求其结束（调用其 finish() 方法）或直接终止其进程，将其从内存中删除。（将其结束或终止后）再次打开 Activity 时，必须重建。</p>
<h3 id="生命周期对应的回调"><a href="#生命周期对应的回调" class="headerlink" title="生命周期对应的回调"></a>生命周期对应的回调</h3><p>当一个Activity转入或者转出不同的状态的时候，会有相应的回调方法被调用，也就是向Activity发出通知。我们可以在不同的状态回调方法中加入不同的操作任务，来完成相应的行为，比如实例化的时候初始化一些信息，暂停或者停止状态的时候可能Activity会被销毁，在此状态做信息状态保留等。</p>
<p>以下框架 Activity 包括每一个基本生命周期方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ExampleActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        // The activity is being created.</div><div class="line">        // 在创建Activity的时候，这个回调必须重写</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        // The activity is about to become visible.</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        // The activity has become visible (it is now &quot;resumed&quot;).</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onPause() &#123;</div><div class="line">        super.onPause();</div><div class="line">        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        // The activity is no longer visible (it is now &quot;stopped&quot;)</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        // The activity is about to be destroyed.</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>onCreate()</li>
</ul>
<p>首次创建Activity的时候调用（Activity被销毁后重建也是首次创建）。该回调方法传入一个Bundle对象，这个对象很重要，用于保存上一次Activity被创建后的状态。-&gt; onStart()</p>
<ul>
<li>onStart()</li>
</ul>
<p>在Activity对用户可见之前被调用。如果Activity转入前台可见，则接下来调用onResume()，若是转入隐藏状态，则接下来调用onStop()。</p>
<ul>
<li>onResume()</li>
</ul>
<p>在 Activity 即将开始与用户进行交互之前调用。 此时，Activity 处于 Activity 堆栈的顶层，并具有用户输入焦点。-&gt; onPause()</p>
<ul>
<li>onPause()</li>
</ul>
<p>当系统要去执行另一个Activity的时候被调用，此时Activity还处于可见的状态，不过已经有一些界面已被另一个Activity覆盖。此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。 它应该非常迅速地执行所需操作，因为它返回后，下一个 Activity 才能继续执行。</p>
<p>如果 Activity 返回前台，则后接 onResume()，如果 Activity 转入对用户不可见状态，则后接 onStop()。</p>
<ul>
<li>onStop()</li>
</ul>
<p>在 Activity 对用户不再可见时调用。如果 Activity 被销毁，或另一个 Activity（一个现有 Activity 或新 Activity）继续执行并将其覆盖，就可能发生这种情况。</p>
<p>如果 Activity 恢复与用户的交互，则后接 onRestart()，如果 Activity 被销毁，则后接 onDestroy()。</p>
<ul>
<li>onRestart()</li>
</ul>
<p>在 Activity 已停止并即将再次启动前调用。始终后接 onStart()</p>
<ul>
<li>onDestroy()</li>
</ul>
<p>在 Activity 被销毁前调用。这是 Activity 将收到的最后调用。 当 Activity 结束（有人对 Activity 调用了 finish()），或系统为节省空间而暂时销毁该 Activity 实例时，可能会调用它。 您可以通过 isFinishing() 方法区分这两种情形。</p>
<p>这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环：</p>
<ul>
<li>完整生命周期</li>
</ul>
<p>在 onCreate() 调用与 onDestroy() 调用之间。</p>
<p>您的 Activity 应在 onCreate() 中执行“全局”状态设置（例如定义布局），并释放 onDestroy() 中的所有其余资源。例如，如果您的 Activity有一个在后台运行的线程，用于从网络上下载数据，它可能会在 onCreate() 中创建该线程，然后在 onDestroy() 中停止该线程。</p>
<ul>
<li>可见生命周期</li>
</ul>
<p>在 onStart() 调用与 onStop() 调用之间。</p>
<p>在这段时间，用户可以在屏幕上看到 Activity 并与其交互。 例如，当一个新 Activity 启动，并且此 Activity 不再可见时，系统会调用 onStop()。您可以在调用这两个方法之间保留向用户显示 Activity 所需的资源。 例如，您可以在 onStart() 中注册一个 BroadcastReceiver 以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop() 中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 onStart() 和 onStop()。</p>
<ul>
<li>前台声明周期</li>
</ul>
<p>在 onResume() 调用与 onPause() 调用之间。</p>
<p>在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。</p>
<h3 id="实例：旋转屏幕Activity的生命周期变化（带保存状态）"><a href="#实例：旋转屏幕Activity的生命周期变化（带保存状态）" class="headerlink" title="实例：旋转屏幕Activity的生命周期变化（带保存状态）"></a>实例：旋转屏幕Activity的生命周期变化（带保存状态）</h3><p>假设一开始是竖屏状态，旋转后为横屏。</p>
<p>横屏状态下：onCreate() -&gt; onStart() -&gt; onResume()</p>
<p>旋转屏幕：onSavaInstanceState() -&gt; onPause() -&gt; onStop() -&gt; onDestroy() - &gt;onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p>管理片段生命周期与管理 Activity 生命周期很相似。和 Activity 一样，片段也以三种状态存在：</p>
<ul>
<li>运行状态</li>
</ul>
<p>片段在运行中的 Activity 中可见。</p>
<ul>
<li>暂停状态</li>
</ul>
<p>另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。</p>
<ul>
<li>停止状态</li>
<li>片段不可见。宿主 Activity 已停止，或片段已从 Activity中移除，但已添加到返回栈。</li>
</ul>
<p>停止片段仍然处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。同样与 Activity 一样，假使 Activity 的进程被终止，而需要在重建 Activity 时恢复片段状态，也可以使用 Bundle 保留片段的状态。可以在片段的 onSaveInstanceState() 回调期间保存状态，并可在 onCreate()、onCreateView() 或 onActivityCreated() 期间恢复状态。</p>
<p>Activity 生命周期与片段生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。 默认情况下，Activity 停止时会被放入由系统管理的 Activity返回栈（以便用户通过返回按钮回退到Activity，任务和返回栈对此做了阐述）。不过，仅当您在移除片段的事务执行期间通过调用 addToBackStack()显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。</p>
<p>在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似。 因此，管理 Activity 生命周期的做法同样适用于片段。</p>
<h3 id="Fragment结合Activity的生命周期一起运行"><a href="#Fragment结合Activity的生命周期一起运行" class="headerlink" title="Fragment结合Activity的生命周期一起运行"></a>Fragment结合Activity的生命周期一起运行</h3><ul>
<li>onAttach()  Fragment和Activity建立关联</li>
<li>onCreate()</li>
<li>onCreateView() 调用它可创建与片段关联的视图层次结构</li>
<li>onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用</li>
<li>onStart()</li>
<li>onResume()</li>
<li>onPause()</li>
<li>onStop()</li>
<li>onDestroyView() 在移除与片段关联的视图层次结构时调用</li>
<li>onDestroy() </li>
<li>onDetach() 在取消片段与 Activity 的关联时调用</li>
</ul>
<h2 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h2><p>服务基本上分为两种形式：</p>
<ul>
<li>启动</li>
</ul>
<p>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</p>
<ul>
<li>绑定</li>
</ul>
<p>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<p>虽然本文档是分开概括讨论这两种服务，但是您的服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。</p>
<p>无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/21/android-system-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/21/android-system-architecture/" itemprop="url">Android系统的体系架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T01:13:30+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android系统的体系架构"><a href="#Android系统的体系架构" class="headerlink" title="Android系统的体系架构"></a>Android系统的体系架构</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Android 5.0 （API 21）开始，Android开发者官网给出的平台架构层次稍微有些不一样，从原先的四层结构变成五层，更加易懂。Android系统的平台架构从下至上分为：</p>
<p>Linux内核层 -&gt; 硬件抽象层（HAL） -&gt; 原生C/C++层 + Android Runtime层 -&gt; Java API框架层 -&gt; 系统应用程序层</p>
</blockquote>
<h3 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h3><p>众所周知，Android是基于Linux内核构建的，所以最底层肯定是Linux的内核，Android Runtime也需要依靠Linux内核来执行底层任务，比如线程和内存的管理，当然，这一层还包含了嵌入式的硬件驱动程序，包括蓝牙、WiFi、摄像头等等。</p>
<h3 id="硬件抽象层（Hardware-Abstract-Layout-HAL）"><a href="#硬件抽象层（Hardware-Abstract-Layout-HAL）" class="headerlink" title="硬件抽象层（Hardware Abstract Layout, HAL）"></a>硬件抽象层（Hardware Abstract Layout, HAL）</h3><p>硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。</p>
<h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p>这一层包含两部分，一部分是原生的C/C++库，另一部分是Android Runtime，也就是Android的虚拟机。</p>
<ul>
<li><p>Android Runtime</p>
<p>Android 5.0（API 21）开始，ART（Android Runtime）取代了之前的Dalvik虚拟机。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如 Jack）将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。</p>
</li>
</ul>
<p>ART的部分主要功能包括：</p>
<ul>
<li>预先 (AOT) 和即时 (JIT) 编译</li>
<li>优化的垃圾回收 (GC)</li>
<li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段</li>
</ul>
<p>Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能，包括一些 Java 8 语言功能。</p>
<ul>
<li>原生C/C++库</li>
</ul>
<p>很多Android的系统组件和服务都由C/C++构建，Android也将原生的开发提供给开发者。开发者可以 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。</p>
<h3 id="Java-API-框架层"><a href="#Java-API-框架层" class="headerlink" title="Java API 框架层"></a>Java API 框架层</h3><p>这个层提供了用Java编写的API，这些API是Android系统的整个功能集，开发者可以根据这些API来开发不同的App。核心的模块组件和服务如下：</p>
<ul>
<li>View系统。可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器</li>
<li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件</li>
<li>通知管理器，可让所有应用在状态栏中显示自定义提醒</li>
<li>Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈</li>
<li>内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据</li>
</ul>
<h3 id="系统应用层"><a href="#系统应用层" class="headerlink" title="系统应用层"></a>系统应用层</h3><p>系统中内置的应用和开发者开发的应用程序，都归属系统的应用层，主要是和用户进行交互，这一层都是用Java来发开的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/21/java-innerclass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/21/java-innerclass/" itemprop="url">Java随笔 - 内部类和闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T01:11:22+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java随笔-内部类和闭包"><a href="#Java随笔-内部类和闭包" class="headerlink" title="Java随笔 - 内部类和闭包"></a>Java随笔 - 内部类和闭包</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>内部类（inner class），就是类中类，与其对应的就是外部类。接下来将学习内部类的各种形式，内部类和外部类的联系，还Java中的闭包。</p>
</blockquote>
<h3 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h3><p>每一项技术的诞生都有它的用处，内部类的出现，我们为什么要使用内部类，主要有以下三点：</p>
<ul>
<li>内部类作为外部类的成员，其方法可以访问外部类作用域中的数据，包括私有数据，这个是很重要的一点</li>
<li>内部类可以实现进一步的封装，在Java中，常规类默认是包可见的，或者公有可见，只有内部类可以对同一个包中的其他类不可见，即隐藏起来</li>
<li>当想要定义一个回调函数，又不想编写太多的代码时，使用匿名的内部类可以比较便捷地实现</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>在普通的类内部放置一个类，外层的我们称之为外部类，在外部类里面的为内部类，相当于内部类成为了外部类的一个成员，成员内部类是包不可见的，成员内部类可以无条件访问外部类的作用域，包括数据和方法，private的也可以。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class OutterClass &#123;//外部类</div><div class="line">	private int intValue = 0;</div><div class="line">	private static int staticValue = 0;</div><div class="line">	public OutterClass(int intValue) &#123;</div><div class="line">		this.intValue = intValue;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	class InnerClass &#123;//内部类</div><div class="line">		int a = intValue;</div><div class="line">		public void output() &#123;</div><div class="line">			System.out.println(intValue);</div><div class="line">			System.out.println(staticValue);</div><div class="line">			</div><div class="line">			intValue++;</div><div class="line">			System.out.println(intValue);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中，实现内部类能够访问外部类成员的思路是，内部类的对象总有一个隐式的引用，它指向了创建它的外部类的对象，假设这个引用为outer（实际不是Java的关键字），那么上面例子的内部类可以等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class InnerClass &#123;//内部类</div><div class="line">		int a = outer.intValue;</div><div class="line">		public void output() &#123;</div><div class="line">			System.out.println(outer.intValue);</div><div class="line">			System.out.println(outer.staticValue);</div><div class="line">			</div><div class="line">			outer.intValue++;</div><div class="line">			System.out.println(outer.intValue);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="内部类的特殊语法"><a href="#内部类的特殊语法" class="headerlink" title="内部类的特殊语法"></a>内部类的特殊语法</h3><p>Java的语法当中，变量名的命名除了使用下划线、数字、字母外，还可以使用$来命名，但是一般不推荐使用，因为这个美刀字符，只要是用于对内部类的命名，上面的例子中，编译器编译过后，内部类所形成的类名实际为OutterClass$InnerClass。<br>内部类正规的引用外部类的成员是使用如下形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutterClass.this</div></pre></td></tr></table></figure></p>
<p>这种表达方式中的this限定词很多时候可能是累赘，没什么作用，但是如果内部类中的方法和数据与外部的相同时，作用就很大了，就像在类的构造方法中经常用到的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(OutterClass.this.intValue);//调用外部类的intValue成员</div></pre></td></tr></table></figure></p>
<p>外部类是没法直接访问内部类的，要访问内部类，就必须在外部类中实例化一个内部类对象，通过这个对象引用到访问内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class OutterClass &#123;//外部类</div><div class="line">	private int intValue = 0;</div><div class="line">	private static int staticValue = 0;</div><div class="line">	private InnerClass inner;</div><div class="line">	public OutterClass(int intValue) &#123;</div><div class="line">		this.intValue = intValue;</div><div class="line">		Inner = new InnerClass();//实例化一个内部类对象</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	class InnerClass &#123;//内部类</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内部类也是有所限制的，它必须依附于外部类存在的，如果需要创建一个内部类对象，那就必须存在一个外部类对象，通过这个外部类对象来实例化一个内部类对象。创建内部类对象的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OutterClass out = new OutterClass(...);</div><div class="line">OutterClass.InnerClass in = out.new InnerClass();</div></pre></td></tr></table></figure></p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>有时候会遇到这种情况：我们需要在一个方法当中去回调一个实现了相应操作接口的类的方法，对应创建的对象只使用一次，如果在外部类中内置一个内部类，那么每个外部类对象都会有这个内部类。但是，Java给我们提供一个便捷的方式，让程序员更加“懒惰”，我们可以在方法中定义一个局部的内部类，从而实现该对象只使用一次就被GC回收，例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public OutterClass() &#123;</div><div class="line">    class InnerClass &#123;</div><div class="line">        private int i = 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    InnerClass in = new InnerClass();</div><div class="line">    System.out.println(in.i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在方法中的局部类，和定义变量一样，不能用private、public等修饰符来声明，它的作用域仅限于这个块中。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类比较好理解，就是创建一个没有名字的内部类，这个是非常常见的，举一个Android中按钮点击触发的事件例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(new View.OnClickListener &#123; </div><div class="line">   @Override</div><div class="line">   public void onClick(View v) &#123;</div><div class="line">       //do something...</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>Java中，只有内部类可以声明为static，若是声明为static的内部类，我们称之为静态内部类。静态内部类的对象不具备对生成它的外部类对象的引用特权，其他的基本是普通内部类一致。静态内部类无法访问外部类的非静态成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class OutterClass &#123;//外部类</div><div class="line">    private int intValue = 0;</div><div class="line">    private static int staticValue = 0;</div><div class="line">    static class StaticInnerClass &#123;</div><div class="line">        public int a = staticValue;</div><div class="line">        //public int b = intValue;//error</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class InnerClassTest &#123;</div><div class="line">  public static void main(String[] args)&#123;</div><div class="line">      OutterClass.StaticInnerClass in = new OutterClass.StaticInnerClass();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>Java没有像C#中的委托机制，但是Java引入了闭包，非显式地支持闭包。Java中的闭包一般和回调关联在一起，可以通过接口和内部类来实现。上面谈到，非静态内部类可以理解为外部类的一个对象引用，内部类可以访问外部类的详细信息，所以可以把非静态内部类当做面向对象领域的闭包。</p>
<p>例子：存在一个类Teacher，表示教师，它有一个成员方法work<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Teacher &#123;</div><div class="line">    public void work() &#123;</div><div class="line">        //do something...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>存在一个接口Programmable，表示具备编程能力的人，它提供一个方法work<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Programmable &#123;</div><div class="line">    void work();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两者都提供了work方法，方法的签名是一样的，但是功能不一样。<br>现在有这么一个人，他是老师，教的是编程课，那么我们既要实现Programmable接口，也要继承教师类。现在的问题是实现的这个类只能定义一个work方法，怎么来实现？采用闭包可以有效解决这个问题。</p>
<p>code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public Man extends Teacher &#123;</div><div class="line">    @Override </div><div class="line">    public void work() &#123;</div><div class="line">        //do something...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void coding() &#123;</div><div class="line">        //program</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    class Programmer implements Programmabele &#123;</div><div class="line">        @Override</div><div class="line">        public void work() &#123;</div><div class="line">            coding();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/21/java-enum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/21/java-enum/" itemprop="url">Java随笔 - 枚举类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T01:10:21+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java随笔-枚举类"><a href="#Java随笔-枚举类" class="headerlink" title="Java随笔 - 枚举类"></a>Java随笔 - 枚举类</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>枚举类是JDK 5开始引入的，其知识点比较少，又较C/C++中的枚举类型不一样，在这里，枚举以类的形式存在，下面学习枚举类的常见语法和在单例模式（设计模式）中的应用。</p>
</blockquote>
<h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><p>先看一个典型例子，在C/C++/C#中都是很常见的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum Week &#123;</div><div class="line">	Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所有的枚举类都继承于Enum，Enum有一些比较好用的方法，比如toString()，ordinal()，compareTo()，下面为使用例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">System.out.println(Week.Friday);// print &quot;Friday&quot; 直接输出枚举常量</div><div class="line">Week week = Enum.valueOf(Week.class, &quot;Friday&quot;);//获取指定类和名字的枚举常量</div><div class="line">System.out.println(week);// print &quot;Friday&quot;</div><div class="line">System.out.println(Week.Friday.ordinal());//获取当前枚举常量的位置  print 4</div><div class="line">Week[] values = Week.values();//values()为静态方法，将包含的全部枚举常量以数组的形式返回 </div><div class="line">for (Week w : values) &#123;// print Monday Tuesday Wednesday Thursday Friday Saturday Sunday</div><div class="line">	System.out.print(w + &quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>枚举强调常量这个概念，可以理解为静态的，不要试图去构造一个枚举对象，这样是不允许的，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Week week = new Week();// error</div></pre></td></tr></table></figure></p>
<p>在比较两个枚举类型的值的时候，永远不需要调用equals方法，虽然有实现，直接用==就可以。</p>
<p>有需要的话，可以在枚举类中添加一些构造器、方法和数据域。当然，其中的构造器只能在构造枚举常量的时候被调用。以下为例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">enum Size &#123;</div><div class="line">	SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;);</div><div class="line">	</div><div class="line">	private String abbreviation;</div><div class="line">	</div><div class="line">	private Size(String abbreviation) &#123;</div><div class="line">		this.abbreviation = abbreviation;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String getAbbreviation() &#123;</div><div class="line">		return abbreviation;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(Size.SMALL.getAbbreviation());</div><div class="line">Size size = Enum.valueOf(Size.class, &quot;SMALL&quot;);//print &quot;S&quot;</div><div class="line">System.out.println(size.equals(Size.SMALL));//true</div><div class="line">System.out.println(size == Size.SMALL);//true</div><div class="line">System.out.println(size == Size.LARGE);//false</div></pre></td></tr></table></figure></p>
<h3 id="单例模式的枚举实现"><a href="#单例模式的枚举实现" class="headerlink" title="单例模式的枚举实现"></a>单例模式的枚举实现</h3><p>用枚举来实现单例模式是最佳方法。它更简洁，不仅可以避免多线程同步问题，自动支持序列化机制，也可以绝对防止多次被实例化。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    public void whateverMethod() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/04/21/java-interface-abstract/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/21/java-interface-abstract/" itemprop="url">Java随笔 - 接口和抽象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T01:08:54+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java随笔-接口和抽象类"><a href="#Java随笔-接口和抽象类" class="headerlink" title="Java随笔 - 接口和抽象类"></a>Java随笔 - 接口和抽象类</h2><blockquote>
<p>接口和抽象类有着相似和不同的地方，相似的地方在于都是为了在继承层次中，让上层更加通用的类更好地将数据隔离、封装、抽象出来，不同之处是两者使用的一些特性。</p>
</blockquote>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在继承的层次中，处在上层的类更具通用性，也就是通用的超类，让此类作为抽象类，抽象类中的通用的方法进行抽象，在类中起到占位的作用，自己不去实现它，而让继承它的之类去实现它。</p>
<p>抽象类的修饰词是abstract，不仅仅可以修饰类，还可以修饰方法。为了提高程序的清晰度，在一个类中，包含一到多个抽象方法的类，其本身必须被声明为抽象类。也就是说，具备一到多个方法的类一定是抽象类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class Person &#123;</div><div class="line">    public abstract String getDescription();//抽象方法必须为public或者default</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Student extends Person &#123;</div><div class="line">    public String getDescription() &#123;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在抽象类中，除了可以拥有抽象方法，还可以有具体的数据和具体方法，子类继承抽象类时，可以不用去重写具体方法。</p>
<p>抽象类中，可以包含具体的数据域和具体方法，还可以不包含抽象方法。也就是说，类即使不包含抽象方法，也可以被声明为抽象类。但是！抽象类是不能被实例化的，下面的例子就是错误的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person p = new Person();//error</div><div class="line">Person p = new Student();//ok</div></pre></td></tr></table></figure></p>
<p>抽象类可以定义对象变量，但是其只能引用非抽象子类的对象。</p>
<blockquote>
<p>在抽象类中尽量不要包含具体方法，不管是不是抽象的，都应该将通用的域和方法尽量放在super类中。</p>
</blockquote>
<h3 id="拓展抽象类的方式"><a href="#拓展抽象类的方式" class="headerlink" title="拓展抽象类的方式"></a>拓展抽象类的方式</h3><ul>
<li>在抽象中定义部分抽象类方法或者不定义抽象方法，这样子类就必须声明为抽象类，去定义剩余部分的抽象方法或者去定义没有定义的抽象方法</li>
<li>在抽象类中定义全部的抽象方法，这样子类就不是抽象的了</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口，修饰符为interface，声明方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Comparable&lt;T&gt; &#123;</div><div class="line">    int compareTo(T other);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口不是类，而是一种特殊的类，其意义在于描述了类的行为，具有什么功能，这些行为和功能往往具备通用性。接口只是“描述”，而不去实现。一个类只能继承一个类，在Java和C#中都是单继承的，但是对于接口来说，一个类可以实现多继承，也就是一个类可以继承多个接口，其含义是一个类可以具备多种通用的行为。</p>
<p>Java库中内置的Comparable接口，也就是上面的例子，对于实现了这个接口的类，都必须是实现comparaTo方法，从而拥有这个方法，而且这个方法必须和接口中声明的一致，包括参数和返回类型。</p>
<p>接口中的所有方法都是public的，所以在接口声明中写不写public修饰符都是一样的。但是！在实现类中，必须有public修饰符。因为在实现的具体类中，若不写明为public，那么编译器会认为此方法为default，也就是默认包可见的，从而引发后面的一系列警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person implements Comparable&lt;Person&gt; &#123;</div><div class="line">    public compareTo(Person other) &#123;</div><div class="line">        return age - other.age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口可以包含多个方法，但是在设计模式的六大原则中，职责单一原则建议实现接口的职责单一，而不是将所有不同功能的接口都放在一个接口中，最好是一个接口一个方法。</p>
<p>在接口中，是绝对不能有具体的实例域和具体方法或者静态方法的，这个有别于抽象类。提供实例域和方法的实现的任务应该交由实现接口的类来完成。但是，接口可以具备常量，且接口中的域会被自动设置为public static final。接口是没有构造方法的。</p>
<p>因此，我们可以把接口看成是没有实例域的抽象类。</p>
<p>和抽象类一样，接口是不能被实例化的，但是可以声明接口对象变量，去引用实现了这个接口的类的对象，这也体现了类的多态性。</p>
<h3 id="接口的其他特性"><a href="#接口的其他特性" class="headerlink" title="接口的其他特性"></a>接口的其他特性</h3><ul>
<li>静态方法</li>
</ul>
<p>Java8开始，允许在接口中增加静态方法。理论上讲，这是合乎常理的，只是这由位于将接口作为抽象规范的初衷。</p>
<ul>
<li>默认方法</li>
</ul>
<p>可以为接口方法提供一个默认的实现，但必须用default修饰符来标记。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Comparable&lt;T&gt; &#123;</div><div class="line">    default int compareTo(T other) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，添加这个默认的实现意义不大，因为在实现这个接口的同时，这个方法也会被重写，也就是被覆盖。意义不大，还是有些意义的，在过多类似的回调接口实现中，有些没有去实现，那就可以拿默认的来用。</p>
<h3 id="接口的默认方法冲突"><a href="#接口的默认方法冲突" class="headerlink" title="接口的默认方法冲突"></a>接口的默认方法冲突</h3><p>接口的默认方法出现冲突的情况是这样的：先是在一个接口中将一个方法定义为默认方法，然后又在超类或者另一个接口中定义了同样的方法。</p>
<p>Java为解决此问题，指定了如下规则：</p>
<ul>
<li>超类优先。如果超类提供了一个具体的方法，同名而且有相同参数类型的默认方法都会被忽略。</li>
<li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（无论是否是默认参数）相同的方法，拿就必须覆盖这个方法来解决冲突。</li>
</ul>
<blockquote>
<p>如果两个接口都没有为共享方法提供默认的实现，实现类可以选择两者都实现，也可以选择干脆都不实现。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Linzh</p>
              <p class="site-description motion-element" itemprop="description">Standing on Shoulders of Giants</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linzh</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
