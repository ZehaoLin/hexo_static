<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linzh&#39;s Blog</title>
  <subtitle>Standing on Shoulders of Giants</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linzhs.cm/"/>
  <updated>2017-04-30T03:36:45.043Z</updated>
  <id>http://linzhs.cm/</id>
  
  <author>
    <name>Linzh</name>
    <email>lzh_547590520@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BLE协议栈简析</title>
    <link href="http://linzhs.cm/2017/04/30/ble-protocal/"/>
    <id>http://linzhs.cm/2017/04/30/ble-protocal/</id>
    <published>2017-04-30T03:36:45.000Z</published>
    <updated>2017-04-30T03:36:45.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BLE协议栈简析"><a href="#BLE协议栈简析" class="headerlink" title="BLE协议栈简析"></a>BLE协议栈简析</h1><blockquote>
<p>本文针对蓝牙4.0，也就是低功耗蓝牙BLE的协议栈进行简单分析。</p>
</blockquote>
<h2 id="Arch图"><a href="#Arch图" class="headerlink" title="Arch图"></a>Arch图</h2><p>以下为蓝牙协议栈架构图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7rf9ir.com1.z0.glb.clouddn.com/Android-BLE-in-Action.005.jpeg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>蓝牙协议栈分为三个层次，从底层到顶层的名字和其所起到的作用分别如下：</p>
<ul>
<li><p>Controller</p>
<p>  这一层主要是物理层，定义了蓝牙工作的频段（2.4GHz）和频段的通道、广播等。Host层和Controller层之间有个接口层，这个接口建立了Host和Controller之间的交互，也是顶层的应用和芯片的交互关键通道。</p>
</li>
<li><p>Host</p>
<p>  这一层相对比较复杂，包含了裸机链路控制、适配协议、安全管理、GATT、ATT、GAP等。</p>
<p>  ATT（Attibute Protocal），属性协议，是BLE通信的基础，ATT封装数据，向外暴露为“属性”，提供“属性”的为服务端，读取“属性”的为客户端。</p>
<p>  GATT（Generic Attribute Profile），通用属性配置文件，建立在ATT的基础上，对ATT做进一步的逻辑封装，定义数据的交互方式和含义。每个GATT里面包含3个层次：服务（service）、特征（Characteristic）、描述（Descriptor）。</p>
<p>  GAP（Generic Access Profile），停用访问控制配置文件。它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。</p>
</li>
<li><p>Applications</p>
<p>  这一层为BLE的应用层，可分为两大类，分别为基于连接和非连接。</p>
<p>  基于非连接的也叫Beacon，依赖于BLE的广播，常用语BLE搜索其他设备。这里的BLE存在两种角色，发送广播方为Broadcaster，监听广播方为Observer。</p>
<p>  基于连接的需要通过GATT连接来收发数据。这里的BLE也存在两种角色，分别是中心主机设备Central，和被连接的从机外设Peripheral。</p>
</li>
</ul>
<h2 id="GATT内部层次"><a href="#GATT内部层次" class="headerlink" title="GATT内部层次"></a>GATT内部层次</h2><p>GATT内部抽象图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7rf9ir.com1.z0.glb.clouddn.com/Android-BLE-in-Action.008.jpeg" alt="image" title="">
                </div>
                <div class="image-caption">image</div>
            </figure><br>GATT最外层是Profile配置文件，里面又包含了服务（service）、特征（Characteristic）、描述（Descriptor），他们之间的关系是一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。</p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>Service、Characteristic 还有 Descriptor 之间都是使用 UUID 唯一标识来区分的。</p>
<p>UID 是全球唯一标识符，它是 128bit 的值，为了便于识别和阅读，一般写成8-4-4-12 的16进制形式。如123e4567-e89b-12d3-a456-426655440000。</p>
<p>16-bit的蓝牙基本UUID形式为 0000XXXX-0000-1000-8000-00805f9b34fb。实际UUID为18位，但是除了XXXX部分需要更改，其他的基本一致，这样对于BLE的数据非常受限的设备使用起来更加方便。</p>
<p>Android中为了避免UUID的冲突，可以使用UUID.randomUUID()方法来生成一个随机的UUID。</p>
<p>16-bit的UUID数量只有65536个，数量远不如128-bit的，所以官方事先保留了一些UIID，若是16-bit的基本UUID不够用，可以选择购买。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="https://race604.com/android-ble-in-action/" target="_blank" rel="external">Android 上的低功耗蓝牙实践</a></p>
</li>
<li><p><a href="https://race604.com/gatt-profile-intro/" target="_blank" rel="external">GATT Profile 简介</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BLE协议栈简析&quot;&gt;&lt;a href=&quot;#BLE协议栈简析&quot; class=&quot;headerlink&quot; title=&quot;BLE协议栈简析&quot;&gt;&lt;/a&gt;BLE协议栈简析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文针对蓝牙4.0，也就是低功耗蓝牙BLE的协议栈进行简单分析。&lt;
    
    </summary>
    
    
      <category term="BLE" scheme="http://linzhs.cm/tags/BLE/"/>
    
  </entry>
  
  <entry>
    <title>Android中Activity的启动模式</title>
    <link href="http://linzhs.cm/2017/04/21/android-activity-startmode/"/>
    <id>http://linzhs.cm/2017/04/21/android-activity-startmode/</id>
    <published>2017-04-20T17:16:52.000Z</published>
    <updated>2017-04-20T17:16:52.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android中Activity的启动模式"><a href="#Android中Activity的启动模式" class="headerlink" title="Android中Activity的启动模式"></a>Android中Activity的启动模式</h2><p>在Android中，每一个任务（应用程序）都有一个放回栈（back stack），每一个应用都有一到多个Activity，返回栈就是来存储这些活动的，当Activity处于栈顶的时候，该Activity也是正显示在手机屏幕上的。若用户按下“返回”按钮后，一个Activity将会被弹出栈，也就等于被销毁，而前一个Activity也将被执行。返回栈中永远不会重新排序，而是根据入栈和出栈的顺序来排列的。</p>
<p>在没有设置Activity的启动模式的时候，栈是可以被重复创建的，比如一个应用有很多个Activity，这些Activity大部分都可以创建同一个Activity，那么每次创建都会被推入栈中，返回栈也就有了多次被实例化的Activity。</p>
<p>Activity和任务的默认行为如下：</p>
<ul>
<li>当 Activity A 启动 Activity B 时，Activity A 将会停止，但系统会保留其状态（例如，滚动位置和已输入表单中的文本）。如果用户处于Activity B时按“返回”按钮，则Activity A将恢复其状态，继续运行。（活动与活动之间如何进行数据交流，活动怎么在一个应用程序的生命周期中保存好自己的关键数据，以防中途活动被销毁后，又要从头开始加载，丢失关键数据？这些问题将在另一篇随笔上做总结）</li>
<li>用户通过按下Home键按钮离开任务时，当前Activity将停止运行，并且任务会将入后台。系统将保留任务中的每个Activity的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务又会回到前台并恢复当前任务返回栈栈顶的Activity继续执行。</li>
<li>如果用户按“返回”按钮，则当前 Activity 会从堆栈弹出并被销毁。 堆栈中的前一个 Activity 恢复执行。销毁 Activity 时，系统不会保留该 Activity 的状态。</li>
<li>当前任务的Activity也可以被其他任务多次实例化。</li>
</ul>
<h3 id="自定义Activity的启动模式"><a href="#自定义Activity的启动模式" class="headerlink" title="自定义Activity的启动模式"></a>自定义Activity的启动模式</h3><p>我们可以为每个Activity定义一种启动模式，注册的方法就是在<a href="">AndroidManifest.xml</a>文件声明时，为相应的Activity元素加上launchMode属性，并且指定该属性为如下一种：</p>
<ul>
<li>“standard”（默认标准模式）</li>
</ul>
<p>这个标准模式是默认的启动模式。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。默认模式下的Activity可以被多次实例化，而且每个实例都可以属于不用的任务，并且一个任务可以拥有多个实例，举个例子，比如我们现在界面上有个按钮，点击按钮就会启动一个新的活动，这个活动是默认模式的，新的活动里也有一个按钮，这个新的按钮还是启动这个新的界面，所以每个当我们点击按钮后，同一个Activity将会多多次实例化，实例化了多少次，就要按下“返回”按钮来销毁多少次。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>在“singleTop”模式下，如果当前的任务的栈顶已经存在此种模式的Activity实例，那么系统会通过调用该实例的<a href="">onNewIntent()</a>方法向其传输intent，而不是创建Activity新的实例。也就是说，在“singleTop”模式下，如果活动位于栈顶，那么此活动只会被实例化一次，若不是在栈顶，那么还是会被多次实例化。</p>
<p>例如，假设任务的返回栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈是 A-B-C-D；D 位于顶部）。收到针对 D 类 Activity 的 Intent。如果 D 具有默认的 “standard” 启动模式，则会启动该类的新实例，且堆栈会变成 A-B-C-D-D。但是，如果 D 的启动模式是 “singleTop”，则 D 的现有实例会通过 onNewIntent() 接收 Intent，因为它位于堆栈的顶部；而堆栈仍为 A-B-C-D。但是，如果收到针对 B 类 Activity 的 Intent，则会向堆栈添加 B 的新实例，即便其启动模式为 “singleTop” 也是如此。</p>
<blockquote>
<p>注：为某个 Activity 创建新实例时，用户可以按“返回”按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 onNewIntent() 之前，用户无法按“返回”按钮返回到 Activity 的状态。</p>
</blockquote>
<ul>
<li>“singleTask”</li>
</ul>
<p>当前活动的模式如果是“singleTask”模式，拿每次启动该活动时系统首先会在返回栈中检查是否存在该实例，如果发现先已经存在则不会重新实例化，而是使用已经存在的，则系统会通过调用现有实例的 <a href="">onNewIntent()</a> 方法向其传送 Intent，并把这个活动统统出栈，让这个活动处于栈顶，如果返回栈中没有该活动的实例，则会创建一个新的实例。</p>
<ul>
<li>“singleInstance”</li>
</ul>
<p>“singleInstance”模式下的活动比较特别，该活动会被系统单独放在一个返回栈上去管理，这个活动在整个应用程序的生命里面只有一个实例，这个和单例模式很像了。在这种模式下，这个活动是共享的，也可以被其他应用程序调用。</p>
<h3 id="动态设置Activity启动模式"><a href="#动态设置Activity启动模式" class="headerlink" title="动态设置Activity启动模式"></a>动态设置Activity启动模式</h3><p>在程序中用startActivity()启动Activity的时候，可以在Intent中加入相应的标志来修改Activity与其他任务的默认关联方式。可用于修改的标志如下所示：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。这个状态与”singlTask”模式是一样的。</p>
<ul>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。这种模式与“singleTop”模式一致。</p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
</ul>
<p>如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP 通常与 FLAG_ACTIVITY_NEW_TASK 结合使用。一起使用时，通过这些标志，可以找到其他任务中的现有 Activity，并将其放入可从中响应 Intent 的位置。</p>
<h3 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h3><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。 当用户再次返回到任务时，仅恢复根 Activity。系统这样做的原因是，经过很长一段时间后，用户可能已经放弃之前执行的操作，返回到任务是要开始执行新的操作。</p>
<p>可以使用下列几个 Activity 属性修改此行为：</p>
<ul>
<li>alwaysRetainTaskState</li>
</ul>
<p>如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。</p>
<ul>
<li>clearTaskOnLaunch</li>
</ul>
<p>如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。</p>
<ul>
<li>finishOnTaskLaunch</li>
</ul>
<p>此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android中Activity的启动模式&quot;&gt;&lt;a href=&quot;#Android中Activity的启动模式&quot; class=&quot;headerlink&quot; title=&quot;Android中Activity的启动模式&quot;&gt;&lt;/a&gt;Android中Activity的启动模式&lt;/
    
    </summary>
    
    
      <category term="Android" scheme="http://linzhs.cm/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中Activity、Fragment、Service的生命周期</title>
    <link href="http://linzhs.cm/2017/04/21/android-lifecycle/"/>
    <id>http://linzhs.cm/2017/04/21/android-lifecycle/</id>
    <published>2017-04-20T17:15:48.000Z</published>
    <updated>2017-04-20T17:15:48.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中Activity、Fragment、Service的生命周期"><a href="#Android中Activity、Fragment、Service的生命周期" class="headerlink" title="Android中Activity、Fragment、Service的生命周期"></a>Android中Activity、Fragment、Service的生命周期</h1><blockquote>
<p>在Android系统中，常见的应用组件都有它的生命周期，以便于系统对内存的管理，接下来总结一下Activity，Fragment，Service这三个常见、重要的组件的生命周期。</p>
</blockquote>
<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p>用回调方法的方式来管理Activity的生命周期对于开发强大、灵活的应用来说那是至关重要的。Activity的生命周期会直接影响到其他Activity、其任务和返回栈。</p>
<p>Activity有三种状态存在：</p>
<ul>
<li>运行状态</li>
</ul>
<p>此时Activity处于屏幕的前台，可以与用户进行交互，具有用户焦点。</p>
<ul>
<li>暂停状态</li>
</ul>
<p>我们经常会遇到这种情况：屏幕上出现一个对话框，或者加载动画框，从屏幕下面弹出不会沾满屏幕的一个选项卡，而且在屏幕里面还能看到另一个界面。对于这种情况，另一个Activity位于屏幕前台并且具有用户焦点，但在背后的Activity仍然可见。也就是说，另一个Activity显示在此Activity的上方，并且Activity部分透明或者未被覆盖整个屏幕，我们把这个时候的Activity成为暂停状态。</p>
<p>暂停状态的Activity仍然处于完全活动的状态（Activity对象保留在内存中，它保留了所有状态和成员信息，并与窗口管理器 保持连接），但是这个状态的Activity在内存不足的时候，也会被系统终止并且回收。处于此状态的Activity一般不要做太多事情，在正常切换的时候如果有太多占用时间的任务完成，那么有可能会导致卡顿的情况，影响了用户体验。</p>
<ul>
<li>停止状态</li>
</ul>
<p>当一个Activity被另一个Activity完全覆盖的时候，也就进入了后台。已停止的 Activity 同样仍处于活动状态（Activity 对象保留在内存中，它保留了所有状态和成员信息，但未与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。</p>
<p>如果 Activity 处于暂停或停止状态，系统可通过要求其结束（调用其 finish() 方法）或直接终止其进程，将其从内存中删除。（将其结束或终止后）再次打开 Activity 时，必须重建。</p>
<h3 id="生命周期对应的回调"><a href="#生命周期对应的回调" class="headerlink" title="生命周期对应的回调"></a>生命周期对应的回调</h3><p>当一个Activity转入或者转出不同的状态的时候，会有相应的回调方法被调用，也就是向Activity发出通知。我们可以在不同的状态回调方法中加入不同的操作任务，来完成相应的行为，比如实例化的时候初始化一些信息，暂停或者停止状态的时候可能Activity会被销毁，在此状态做信息状态保留等。</p>
<p>以下框架 Activity 包括每一个基本生命周期方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ExampleActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        // The activity is being created.</div><div class="line">        // 在创建Activity的时候，这个回调必须重写</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        // The activity is about to become visible.</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        // The activity has become visible (it is now &quot;resumed&quot;).</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onPause() &#123;</div><div class="line">        super.onPause();</div><div class="line">        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        // The activity is no longer visible (it is now &quot;stopped&quot;)</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        // The activity is about to be destroyed.</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>onCreate()</li>
</ul>
<p>首次创建Activity的时候调用（Activity被销毁后重建也是首次创建）。该回调方法传入一个Bundle对象，这个对象很重要，用于保存上一次Activity被创建后的状态。-&gt; onStart()</p>
<ul>
<li>onStart()</li>
</ul>
<p>在Activity对用户可见之前被调用。如果Activity转入前台可见，则接下来调用onResume()，若是转入隐藏状态，则接下来调用onStop()。</p>
<ul>
<li>onResume()</li>
</ul>
<p>在 Activity 即将开始与用户进行交互之前调用。 此时，Activity 处于 Activity 堆栈的顶层，并具有用户输入焦点。-&gt; onPause()</p>
<ul>
<li>onPause()</li>
</ul>
<p>当系统要去执行另一个Activity的时候被调用，此时Activity还处于可见的状态，不过已经有一些界面已被另一个Activity覆盖。此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。 它应该非常迅速地执行所需操作，因为它返回后，下一个 Activity 才能继续执行。</p>
<p>如果 Activity 返回前台，则后接 onResume()，如果 Activity 转入对用户不可见状态，则后接 onStop()。</p>
<ul>
<li>onStop()</li>
</ul>
<p>在 Activity 对用户不再可见时调用。如果 Activity 被销毁，或另一个 Activity（一个现有 Activity 或新 Activity）继续执行并将其覆盖，就可能发生这种情况。</p>
<p>如果 Activity 恢复与用户的交互，则后接 onRestart()，如果 Activity 被销毁，则后接 onDestroy()。</p>
<ul>
<li>onRestart()</li>
</ul>
<p>在 Activity 已停止并即将再次启动前调用。始终后接 onStart()</p>
<ul>
<li>onDestroy()</li>
</ul>
<p>在 Activity 被销毁前调用。这是 Activity 将收到的最后调用。 当 Activity 结束（有人对 Activity 调用了 finish()），或系统为节省空间而暂时销毁该 Activity 实例时，可能会调用它。 您可以通过 isFinishing() 方法区分这两种情形。</p>
<p>这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环：</p>
<ul>
<li>完整生命周期</li>
</ul>
<p>在 onCreate() 调用与 onDestroy() 调用之间。</p>
<p>您的 Activity 应在 onCreate() 中执行“全局”状态设置（例如定义布局），并释放 onDestroy() 中的所有其余资源。例如，如果您的 Activity有一个在后台运行的线程，用于从网络上下载数据，它可能会在 onCreate() 中创建该线程，然后在 onDestroy() 中停止该线程。</p>
<ul>
<li>可见生命周期</li>
</ul>
<p>在 onStart() 调用与 onStop() 调用之间。</p>
<p>在这段时间，用户可以在屏幕上看到 Activity 并与其交互。 例如，当一个新 Activity 启动，并且此 Activity 不再可见时，系统会调用 onStop()。您可以在调用这两个方法之间保留向用户显示 Activity 所需的资源。 例如，您可以在 onStart() 中注册一个 BroadcastReceiver 以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop() 中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 onStart() 和 onStop()。</p>
<ul>
<li>前台声明周期</li>
</ul>
<p>在 onResume() 调用与 onPause() 调用之间。</p>
<p>在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。</p>
<h3 id="实例：旋转屏幕Activity的生命周期变化（带保存状态）"><a href="#实例：旋转屏幕Activity的生命周期变化（带保存状态）" class="headerlink" title="实例：旋转屏幕Activity的生命周期变化（带保存状态）"></a>实例：旋转屏幕Activity的生命周期变化（带保存状态）</h3><p>假设一开始是竖屏状态，旋转后为横屏。</p>
<p>横屏状态下：onCreate() -&gt; onStart() -&gt; onResume()</p>
<p>旋转屏幕：onSavaInstanceState() -&gt; onPause() -&gt; onStop() -&gt; onDestroy() - &gt;onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p>管理片段生命周期与管理 Activity 生命周期很相似。和 Activity 一样，片段也以三种状态存在：</p>
<ul>
<li>运行状态</li>
</ul>
<p>片段在运行中的 Activity 中可见。</p>
<ul>
<li>暂停状态</li>
</ul>
<p>另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。</p>
<ul>
<li>停止状态</li>
<li>片段不可见。宿主 Activity 已停止，或片段已从 Activity中移除，但已添加到返回栈。</li>
</ul>
<p>停止片段仍然处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。同样与 Activity 一样，假使 Activity 的进程被终止，而需要在重建 Activity 时恢复片段状态，也可以使用 Bundle 保留片段的状态。可以在片段的 onSaveInstanceState() 回调期间保存状态，并可在 onCreate()、onCreateView() 或 onActivityCreated() 期间恢复状态。</p>
<p>Activity 生命周期与片段生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。 默认情况下，Activity 停止时会被放入由系统管理的 Activity返回栈（以便用户通过返回按钮回退到Activity，任务和返回栈对此做了阐述）。不过，仅当您在移除片段的事务执行期间通过调用 addToBackStack()显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。</p>
<p>在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似。 因此，管理 Activity 生命周期的做法同样适用于片段。</p>
<h3 id="Fragment结合Activity的生命周期一起运行"><a href="#Fragment结合Activity的生命周期一起运行" class="headerlink" title="Fragment结合Activity的生命周期一起运行"></a>Fragment结合Activity的生命周期一起运行</h3><ul>
<li>onAttach()  Fragment和Activity建立关联</li>
<li>onCreate()</li>
<li>onCreateView() 调用它可创建与片段关联的视图层次结构</li>
<li>onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用</li>
<li>onStart()</li>
<li>onResume()</li>
<li>onPause()</li>
<li>onStop()</li>
<li>onDestroyView() 在移除与片段关联的视图层次结构时调用</li>
<li>onDestroy() </li>
<li>onDetach() 在取消片段与 Activity 的关联时调用</li>
</ul>
<h2 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h2><p>服务基本上分为两种形式：</p>
<ul>
<li>启动</li>
</ul>
<p>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</p>
<ul>
<li>绑定</li>
</ul>
<p>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<p>虽然本文档是分开概括讨论这两种服务，但是您的服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。</p>
<p>无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中Activity、Fragment、Service的生命周期&quot;&gt;&lt;a href=&quot;#Android中Activity、Fragment、Service的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Android中Activity
    
    </summary>
    
    
      <category term="Android" scheme="http://linzhs.cm/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android系统的体系架构</title>
    <link href="http://linzhs.cm/2017/04/21/android-system-architecture/"/>
    <id>http://linzhs.cm/2017/04/21/android-system-architecture/</id>
    <published>2017-04-20T17:13:30.000Z</published>
    <updated>2017-04-20T17:13:30.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android系统的体系架构"><a href="#Android系统的体系架构" class="headerlink" title="Android系统的体系架构"></a>Android系统的体系架构</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Android 5.0 （API 21）开始，Android开发者官网给出的平台架构层次稍微有些不一样，从原先的四层结构变成五层，更加易懂。Android系统的平台架构从下至上分为：</p>
<p>Linux内核层 -&gt; 硬件抽象层（HAL） -&gt; 原生C/C++层 + Android Runtime层 -&gt; Java API框架层 -&gt; 系统应用程序层</p>
</blockquote>
<h3 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h3><p>众所周知，Android是基于Linux内核构建的，所以最底层肯定是Linux的内核，Android Runtime也需要依靠Linux内核来执行底层任务，比如线程和内存的管理，当然，这一层还包含了嵌入式的硬件驱动程序，包括蓝牙、WiFi、摄像头等等。</p>
<h3 id="硬件抽象层（Hardware-Abstract-Layout-HAL）"><a href="#硬件抽象层（Hardware-Abstract-Layout-HAL）" class="headerlink" title="硬件抽象层（Hardware Abstract Layout, HAL）"></a>硬件抽象层（Hardware Abstract Layout, HAL）</h3><p>硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。</p>
<h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p>这一层包含两部分，一部分是原生的C/C++库，另一部分是Android Runtime，也就是Android的虚拟机。</p>
<ul>
<li><p>Android Runtime</p>
<p>Android 5.0（API 21）开始，ART（Android Runtime）取代了之前的Dalvik虚拟机。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如 Jack）将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。</p>
</li>
</ul>
<p>ART的部分主要功能包括：</p>
<ul>
<li>预先 (AOT) 和即时 (JIT) 编译</li>
<li>优化的垃圾回收 (GC)</li>
<li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段</li>
</ul>
<p>Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能，包括一些 Java 8 语言功能。</p>
<ul>
<li>原生C/C++库</li>
</ul>
<p>很多Android的系统组件和服务都由C/C++构建，Android也将原生的开发提供给开发者。开发者可以 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。</p>
<h3 id="Java-API-框架层"><a href="#Java-API-框架层" class="headerlink" title="Java API 框架层"></a>Java API 框架层</h3><p>这个层提供了用Java编写的API，这些API是Android系统的整个功能集，开发者可以根据这些API来开发不同的App。核心的模块组件和服务如下：</p>
<ul>
<li>View系统。可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器</li>
<li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件</li>
<li>通知管理器，可让所有应用在状态栏中显示自定义提醒</li>
<li>Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈</li>
<li>内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据</li>
</ul>
<h3 id="系统应用层"><a href="#系统应用层" class="headerlink" title="系统应用层"></a>系统应用层</h3><p>系统中内置的应用和开发者开发的应用程序，都归属系统的应用层，主要是和用户进行交互，这一层都是用Java来发开的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android系统的体系架构&quot;&gt;&lt;a href=&quot;#Android系统的体系架构&quot; class=&quot;headerlink&quot; title=&quot;Android系统的体系架构&quot;&gt;&lt;/a&gt;Android系统的体系架构&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
    
    </summary>
    
    
      <category term="Android" scheme="http://linzhs.cm/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java随笔 - 内部类和闭包</title>
    <link href="http://linzhs.cm/2017/04/21/java-innerclass/"/>
    <id>http://linzhs.cm/2017/04/21/java-innerclass/</id>
    <published>2017-04-20T17:11:22.000Z</published>
    <updated>2017-04-20T17:11:22.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java随笔-内部类和闭包"><a href="#Java随笔-内部类和闭包" class="headerlink" title="Java随笔 - 内部类和闭包"></a>Java随笔 - 内部类和闭包</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>内部类（inner class），就是类中类，与其对应的就是外部类。接下来将学习内部类的各种形式，内部类和外部类的联系，还Java中的闭包。</p>
</blockquote>
<h3 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h3><p>每一项技术的诞生都有它的用处，内部类的出现，我们为什么要使用内部类，主要有以下三点：</p>
<ul>
<li>内部类作为外部类的成员，其方法可以访问外部类作用域中的数据，包括私有数据，这个是很重要的一点</li>
<li>内部类可以实现进一步的封装，在Java中，常规类默认是包可见的，或者公有可见，只有内部类可以对同一个包中的其他类不可见，即隐藏起来</li>
<li>当想要定义一个回调函数，又不想编写太多的代码时，使用匿名的内部类可以比较便捷地实现</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>在普通的类内部放置一个类，外层的我们称之为外部类，在外部类里面的为内部类，相当于内部类成为了外部类的一个成员，成员内部类是包不可见的，成员内部类可以无条件访问外部类的作用域，包括数据和方法，private的也可以。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class OutterClass &#123;//外部类</div><div class="line">	private int intValue = 0;</div><div class="line">	private static int staticValue = 0;</div><div class="line">	public OutterClass(int intValue) &#123;</div><div class="line">		this.intValue = intValue;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	class InnerClass &#123;//内部类</div><div class="line">		int a = intValue;</div><div class="line">		public void output() &#123;</div><div class="line">			System.out.println(intValue);</div><div class="line">			System.out.println(staticValue);</div><div class="line">			</div><div class="line">			intValue++;</div><div class="line">			System.out.println(intValue);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中，实现内部类能够访问外部类成员的思路是，内部类的对象总有一个隐式的引用，它指向了创建它的外部类的对象，假设这个引用为outer（实际不是Java的关键字），那么上面例子的内部类可以等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class InnerClass &#123;//内部类</div><div class="line">		int a = outer.intValue;</div><div class="line">		public void output() &#123;</div><div class="line">			System.out.println(outer.intValue);</div><div class="line">			System.out.println(outer.staticValue);</div><div class="line">			</div><div class="line">			outer.intValue++;</div><div class="line">			System.out.println(outer.intValue);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="内部类的特殊语法"><a href="#内部类的特殊语法" class="headerlink" title="内部类的特殊语法"></a>内部类的特殊语法</h3><p>Java的语法当中，变量名的命名除了使用下划线、数字、字母外，还可以使用$来命名，但是一般不推荐使用，因为这个美刀字符，只要是用于对内部类的命名，上面的例子中，编译器编译过后，内部类所形成的类名实际为OutterClass$InnerClass。<br>内部类正规的引用外部类的成员是使用如下形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutterClass.this</div></pre></td></tr></table></figure></p>
<p>这种表达方式中的this限定词很多时候可能是累赘，没什么作用，但是如果内部类中的方法和数据与外部的相同时，作用就很大了，就像在类的构造方法中经常用到的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(OutterClass.this.intValue);//调用外部类的intValue成员</div></pre></td></tr></table></figure></p>
<p>外部类是没法直接访问内部类的，要访问内部类，就必须在外部类中实例化一个内部类对象，通过这个对象引用到访问内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class OutterClass &#123;//外部类</div><div class="line">	private int intValue = 0;</div><div class="line">	private static int staticValue = 0;</div><div class="line">	private InnerClass inner;</div><div class="line">	public OutterClass(int intValue) &#123;</div><div class="line">		this.intValue = intValue;</div><div class="line">		Inner = new InnerClass();//实例化一个内部类对象</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	class InnerClass &#123;//内部类</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内部类也是有所限制的，它必须依附于外部类存在的，如果需要创建一个内部类对象，那就必须存在一个外部类对象，通过这个外部类对象来实例化一个内部类对象。创建内部类对象的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OutterClass out = new OutterClass(...);</div><div class="line">OutterClass.InnerClass in = out.new InnerClass();</div></pre></td></tr></table></figure></p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>有时候会遇到这种情况：我们需要在一个方法当中去回调一个实现了相应操作接口的类的方法，对应创建的对象只使用一次，如果在外部类中内置一个内部类，那么每个外部类对象都会有这个内部类。但是，Java给我们提供一个便捷的方式，让程序员更加“懒惰”，我们可以在方法中定义一个局部的内部类，从而实现该对象只使用一次就被GC回收，例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public OutterClass() &#123;</div><div class="line">    class InnerClass &#123;</div><div class="line">        private int i = 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    InnerClass in = new InnerClass();</div><div class="line">    System.out.println(in.i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在方法中的局部类，和定义变量一样，不能用private、public等修饰符来声明，它的作用域仅限于这个块中。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类比较好理解，就是创建一个没有名字的内部类，这个是非常常见的，举一个Android中按钮点击触发的事件例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(new View.OnClickListener &#123; </div><div class="line">   @Override</div><div class="line">   public void onClick(View v) &#123;</div><div class="line">       //do something...</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>Java中，只有内部类可以声明为static，若是声明为static的内部类，我们称之为静态内部类。静态内部类的对象不具备对生成它的外部类对象的引用特权，其他的基本是普通内部类一致。静态内部类无法访问外部类的非静态成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class OutterClass &#123;//外部类</div><div class="line">    private int intValue = 0;</div><div class="line">    private static int staticValue = 0;</div><div class="line">    static class StaticInnerClass &#123;</div><div class="line">        public int a = staticValue;</div><div class="line">        //public int b = intValue;//error</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class InnerClassTest &#123;</div><div class="line">  public static void main(String[] args)&#123;</div><div class="line">      OutterClass.StaticInnerClass in = new OutterClass.StaticInnerClass();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>Java没有像C#中的委托机制，但是Java引入了闭包，非显式地支持闭包。Java中的闭包一般和回调关联在一起，可以通过接口和内部类来实现。上面谈到，非静态内部类可以理解为外部类的一个对象引用，内部类可以访问外部类的详细信息，所以可以把非静态内部类当做面向对象领域的闭包。</p>
<p>例子：存在一个类Teacher，表示教师，它有一个成员方法work<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Teacher &#123;</div><div class="line">    public void work() &#123;</div><div class="line">        //do something...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>存在一个接口Programmable，表示具备编程能力的人，它提供一个方法work<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Programmable &#123;</div><div class="line">    void work();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两者都提供了work方法，方法的签名是一样的，但是功能不一样。<br>现在有这么一个人，他是老师，教的是编程课，那么我们既要实现Programmable接口，也要继承教师类。现在的问题是实现的这个类只能定义一个work方法，怎么来实现？采用闭包可以有效解决这个问题。</p>
<p>code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public Man extends Teacher &#123;</div><div class="line">    @Override </div><div class="line">    public void work() &#123;</div><div class="line">        //do something...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void coding() &#123;</div><div class="line">        //program</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    class Programmer implements Programmabele &#123;</div><div class="line">        @Override</div><div class="line">        public void work() &#123;</div><div class="line">            coding();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java随笔-内部类和闭包&quot;&gt;&lt;a href=&quot;#Java随笔-内部类和闭包&quot; class=&quot;headerlink&quot; title=&quot;Java随笔 - 内部类和闭包&quot;&gt;&lt;/a&gt;Java随笔 - 内部类和闭包&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
    
    </summary>
    
    
      <category term="Java" scheme="http://linzhs.cm/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java随笔 - 枚举类</title>
    <link href="http://linzhs.cm/2017/04/21/java-enum/"/>
    <id>http://linzhs.cm/2017/04/21/java-enum/</id>
    <published>2017-04-20T17:10:21.000Z</published>
    <updated>2017-04-20T17:10:21.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java随笔-枚举类"><a href="#Java随笔-枚举类" class="headerlink" title="Java随笔 - 枚举类"></a>Java随笔 - 枚举类</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>枚举类是JDK 5开始引入的，其知识点比较少，又较C/C++中的枚举类型不一样，在这里，枚举以类的形式存在，下面学习枚举类的常见语法和在单例模式（设计模式）中的应用。</p>
</blockquote>
<h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><p>先看一个典型例子，在C/C++/C#中都是很常见的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum Week &#123;</div><div class="line">	Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所有的枚举类都继承于Enum，Enum有一些比较好用的方法，比如toString()，ordinal()，compareTo()，下面为使用例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">System.out.println(Week.Friday);// print &quot;Friday&quot; 直接输出枚举常量</div><div class="line">Week week = Enum.valueOf(Week.class, &quot;Friday&quot;);//获取指定类和名字的枚举常量</div><div class="line">System.out.println(week);// print &quot;Friday&quot;</div><div class="line">System.out.println(Week.Friday.ordinal());//获取当前枚举常量的位置  print 4</div><div class="line">Week[] values = Week.values();//values()为静态方法，将包含的全部枚举常量以数组的形式返回 </div><div class="line">for (Week w : values) &#123;// print Monday Tuesday Wednesday Thursday Friday Saturday Sunday</div><div class="line">	System.out.print(w + &quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>枚举强调常量这个概念，可以理解为静态的，不要试图去构造一个枚举对象，这样是不允许的，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Week week = new Week();// error</div></pre></td></tr></table></figure></p>
<p>在比较两个枚举类型的值的时候，永远不需要调用equals方法，虽然有实现，直接用==就可以。</p>
<p>有需要的话，可以在枚举类中添加一些构造器、方法和数据域。当然，其中的构造器只能在构造枚举常量的时候被调用。以下为例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">enum Size &#123;</div><div class="line">	SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;);</div><div class="line">	</div><div class="line">	private String abbreviation;</div><div class="line">	</div><div class="line">	private Size(String abbreviation) &#123;</div><div class="line">		this.abbreviation = abbreviation;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String getAbbreviation() &#123;</div><div class="line">		return abbreviation;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(Size.SMALL.getAbbreviation());</div><div class="line">Size size = Enum.valueOf(Size.class, &quot;SMALL&quot;);//print &quot;S&quot;</div><div class="line">System.out.println(size.equals(Size.SMALL));//true</div><div class="line">System.out.println(size == Size.SMALL);//true</div><div class="line">System.out.println(size == Size.LARGE);//false</div></pre></td></tr></table></figure></p>
<h3 id="单例模式的枚举实现"><a href="#单例模式的枚举实现" class="headerlink" title="单例模式的枚举实现"></a>单例模式的枚举实现</h3><p>用枚举来实现单例模式是最佳方法。它更简洁，不仅可以避免多线程同步问题，自动支持序列化机制，也可以绝对防止多次被实例化。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    public void whateverMethod() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java随笔-枚举类&quot;&gt;&lt;a href=&quot;#Java随笔-枚举类&quot; class=&quot;headerlink&quot; title=&quot;Java随笔 - 枚举类&quot;&gt;&lt;/a&gt;Java随笔 - 枚举类&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
    
    </summary>
    
    
      <category term="Java" scheme="http://linzhs.cm/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java随笔 - 接口和抽象</title>
    <link href="http://linzhs.cm/2017/04/21/java-interface-abstract/"/>
    <id>http://linzhs.cm/2017/04/21/java-interface-abstract/</id>
    <published>2017-04-20T17:08:54.000Z</published>
    <updated>2017-04-20T17:08:54.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java随笔-接口和抽象类"><a href="#Java随笔-接口和抽象类" class="headerlink" title="Java随笔 - 接口和抽象类"></a>Java随笔 - 接口和抽象类</h2><blockquote>
<p>接口和抽象类有着相似和不同的地方，相似的地方在于都是为了在继承层次中，让上层更加通用的类更好地将数据隔离、封装、抽象出来，不同之处是两者使用的一些特性。</p>
</blockquote>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在继承的层次中，处在上层的类更具通用性，也就是通用的超类，让此类作为抽象类，抽象类中的通用的方法进行抽象，在类中起到占位的作用，自己不去实现它，而让继承它的之类去实现它。</p>
<p>抽象类的修饰词是abstract，不仅仅可以修饰类，还可以修饰方法。为了提高程序的清晰度，在一个类中，包含一到多个抽象方法的类，其本身必须被声明为抽象类。也就是说，具备一到多个方法的类一定是抽象类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class Person &#123;</div><div class="line">    public abstract String getDescription();//抽象方法必须为public或者default</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Student extends Person &#123;</div><div class="line">    public String getDescription() &#123;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在抽象类中，除了可以拥有抽象方法，还可以有具体的数据和具体方法，子类继承抽象类时，可以不用去重写具体方法。</p>
<p>抽象类中，可以包含具体的数据域和具体方法，还可以不包含抽象方法。也就是说，类即使不包含抽象方法，也可以被声明为抽象类。但是！抽象类是不能被实例化的，下面的例子就是错误的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person p = new Person();//error</div><div class="line">Person p = new Student();//ok</div></pre></td></tr></table></figure></p>
<p>抽象类可以定义对象变量，但是其只能引用非抽象子类的对象。</p>
<blockquote>
<p>在抽象类中尽量不要包含具体方法，不管是不是抽象的，都应该将通用的域和方法尽量放在super类中。</p>
</blockquote>
<h3 id="拓展抽象类的方式"><a href="#拓展抽象类的方式" class="headerlink" title="拓展抽象类的方式"></a>拓展抽象类的方式</h3><ul>
<li>在抽象中定义部分抽象类方法或者不定义抽象方法，这样子类就必须声明为抽象类，去定义剩余部分的抽象方法或者去定义没有定义的抽象方法</li>
<li>在抽象类中定义全部的抽象方法，这样子类就不是抽象的了</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口，修饰符为interface，声明方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Comparable&lt;T&gt; &#123;</div><div class="line">    int compareTo(T other);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口不是类，而是一种特殊的类，其意义在于描述了类的行为，具有什么功能，这些行为和功能往往具备通用性。接口只是“描述”，而不去实现。一个类只能继承一个类，在Java和C#中都是单继承的，但是对于接口来说，一个类可以实现多继承，也就是一个类可以继承多个接口，其含义是一个类可以具备多种通用的行为。</p>
<p>Java库中内置的Comparable接口，也就是上面的例子，对于实现了这个接口的类，都必须是实现comparaTo方法，从而拥有这个方法，而且这个方法必须和接口中声明的一致，包括参数和返回类型。</p>
<p>接口中的所有方法都是public的，所以在接口声明中写不写public修饰符都是一样的。但是！在实现类中，必须有public修饰符。因为在实现的具体类中，若不写明为public，那么编译器会认为此方法为default，也就是默认包可见的，从而引发后面的一系列警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person implements Comparable&lt;Person&gt; &#123;</div><div class="line">    public compareTo(Person other) &#123;</div><div class="line">        return age - other.age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口可以包含多个方法，但是在设计模式的六大原则中，职责单一原则建议实现接口的职责单一，而不是将所有不同功能的接口都放在一个接口中，最好是一个接口一个方法。</p>
<p>在接口中，是绝对不能有具体的实例域和具体方法或者静态方法的，这个有别于抽象类。提供实例域和方法的实现的任务应该交由实现接口的类来完成。但是，接口可以具备常量，且接口中的域会被自动设置为public static final。接口是没有构造方法的。</p>
<p>因此，我们可以把接口看成是没有实例域的抽象类。</p>
<p>和抽象类一样，接口是不能被实例化的，但是可以声明接口对象变量，去引用实现了这个接口的类的对象，这也体现了类的多态性。</p>
<h3 id="接口的其他特性"><a href="#接口的其他特性" class="headerlink" title="接口的其他特性"></a>接口的其他特性</h3><ul>
<li>静态方法</li>
</ul>
<p>Java8开始，允许在接口中增加静态方法。理论上讲，这是合乎常理的，只是这由位于将接口作为抽象规范的初衷。</p>
<ul>
<li>默认方法</li>
</ul>
<p>可以为接口方法提供一个默认的实现，但必须用default修饰符来标记。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Comparable&lt;T&gt; &#123;</div><div class="line">    default int compareTo(T other) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，添加这个默认的实现意义不大，因为在实现这个接口的同时，这个方法也会被重写，也就是被覆盖。意义不大，还是有些意义的，在过多类似的回调接口实现中，有些没有去实现，那就可以拿默认的来用。</p>
<h3 id="接口的默认方法冲突"><a href="#接口的默认方法冲突" class="headerlink" title="接口的默认方法冲突"></a>接口的默认方法冲突</h3><p>接口的默认方法出现冲突的情况是这样的：先是在一个接口中将一个方法定义为默认方法，然后又在超类或者另一个接口中定义了同样的方法。</p>
<p>Java为解决此问题，指定了如下规则：</p>
<ul>
<li>超类优先。如果超类提供了一个具体的方法，同名而且有相同参数类型的默认方法都会被忽略。</li>
<li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（无论是否是默认参数）相同的方法，拿就必须覆盖这个方法来解决冲突。</li>
</ul>
<blockquote>
<p>如果两个接口都没有为共享方法提供默认的实现，实现类可以选择两者都实现，也可以选择干脆都不实现。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java随笔-接口和抽象类&quot;&gt;&lt;a href=&quot;#Java随笔-接口和抽象类&quot; class=&quot;headerlink&quot; title=&quot;Java随笔 - 接口和抽象类&quot;&gt;&lt;/a&gt;Java随笔 - 接口和抽象类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;接口和抽象类有着相
    
    </summary>
    
    
      <category term="Java" scheme="http://linzhs.cm/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java随笔 - 对象克隆</title>
    <link href="http://linzhs.cm/2017/04/18/java-note-object-copy/"/>
    <id>http://linzhs.cm/2017/04/18/java-note-object-copy/</id>
    <published>2017-04-17T16:48:32.000Z</published>
    <updated>2017-04-17T16:48:32.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java随笔-对象克隆"><a href="#Java随笔-对象克隆" class="headerlink" title="Java随笔 - 对象克隆"></a>Java随笔 - 对象克隆</h1><blockquote>
<p>本文总结Java对象的浅复制和深复制，以及Clonable接口。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对象在传递的时候，会进行对象复制。对象的复制，可以分为浅复制和深复制。</p>
<h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>在下面的例子中，可以实现对象的复制，origin和copy对象变量引用同一个内存区域，copy调用raiseSalary方法可以修改origin对象所引用的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Employee &#123;</div><div class="line">    private double salary;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        salary = 0.0;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public double getSalary() &#123;</div><div class="line">        return this.salary;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void raiseSalary(int t) &#123;</div><div class="line">        this.salary = salary * t;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee origin = new Employee();</div><div class="line">Employee copy = origin;</div><div class="line">copy.raiseSalary(10);</div></pre></td></tr></table></figure></p>
<p>在这次的复制过程中，实现的细节是：Object这个Java的万类祖先有个protect的clone方法，可以在相同类的对象上做拷贝。</p>
<p>但是，在整个复制的过程中，复制是有限制的，也就是不完全的，所以我们称之为浅复制，浅克隆，浅拷贝。Object这个超类在实现clone这个方法的时候，并不知道子孙类到底是什么，所以在复制的时候也就有了局限性，若需要复制的内容是数值或者其他基本类型，那没什么问题，直接复制即可；若是复制的内容是另一对象的引用呢？那clone复制的新内存区域仍然和原对象共享着一些信息。</p>
<p>浅复制有什么影响吗？我们来举两个例子。</p>
<ul>
<li>例子1<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Employee &#123;</div><div class="line">    private String name;</div><div class="line">    private double salary;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        name = &quot;&quot;;</div><div class="line">        salary = 0.0;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public double getSalary() &#123;</div><div class="line">        return this.salary;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void raiseSalary(int t) &#123;</div><div class="line">        this.salary = salary * t;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee origin = new Employee();</div><div class="line">Employee copy = origin;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在例子1中，我们在Employee中新增String类型的name变量，还是像之前的那样进行拷贝操作。拷贝之后，原对象和克隆对象的name指向了同一块区域，String是不可变的，也就是指向了常量池。</p>
<p>对于不可变对象的拷贝，其实是安全的，没什么影响，拷贝与否没什么影响，因为不管拷贝与否，不可变对象都是同一块内存，并不会因为拷贝了就另外分配一块内存。所以对于不可变对象，浅复制是安全的，可以安全的共享信息。</p>
<ul>
<li>例子2<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Employee &#123;</div><div class="line">    private String name;</div><div class="line">    private double salary;</div><div class="line">    private Date hireDay;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        name = &quot;&quot;;</div><div class="line">        salary = 0.0;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public double getSalary() &#123;</div><div class="line">        return this.salary;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void raiseSalary(int t) &#123;</div><div class="line">        this.salary = salary * t;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee origin = new Employee();</div><div class="line">Employee copy = origin;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在新的例子中，我们新增了可变对象Date，这个时候不完全的拷贝，是有影响的。原本复制的用意是让克隆对象有单独的内存来管理自己的数据，但是由于浅复制导致原对象和克隆对象都指向了同一个可变的对象，那么任一对象进行修改，那就是灾难级别的，所以这时候我们需要深度复制。</p>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>通常，在复制对象的时候会考虑下面三个选项：</p>
<ul>
<li>默认的clone方法是否能满足要求；</li>
<li>是否可以在可变的子对象上调用clone方法来修补默认的clone方法；</li>
<li>是不是不应该使用clone方法</li>
</ul>
<p>对于第三个选项，其实是默认的，对于前两个选项，类必须：</p>
<ul>
<li>实现Cloneable接口</li>
<li>重新定义clone方法，并制定为public访问修饰符</li>
</ul>
<p>在Object类中制定了clone方法为protect，但是在新的Java语法规则中，已经变得宽松了，可以将clone方法重写成public的方法。</p>
<p>要建立深度复制来复制对象中另一个对象，那么就要实行Cloneable接口、重写clone方法，在clone方法里来完成这些复制，如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Employee implements Cloneable &#123;</div><div class="line">    private String name;</div><div class="line">    private double salary;</div><div class="line">    private Date hireDay;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        name = &quot;&quot;;</div><div class="line">        salary = 0.0;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public double getSalary() &#123;</div><div class="line">        return this.salary;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void raiseSalary(int t) &#123;</div><div class="line">        this.salary = salary * t;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Employee clone() throws CloneNotSupportedException &#123;</div><div class="line">        Employee cloned = (Employee)super.clone();</div><div class="line">        cloned.hireDay = (Date)hireDay.clone();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee origin = new Employee();</div><div class="line">Employee copy = origin;</div></pre></td></tr></table></figure></p>
<p>在新的clone实现里，指定了throws CloneNotSupportedException异常，其用意在于要实现Cloneable接口，否则就不支持深度拷贝，从而抛出异常。</p>
<p>在重写clone方法的时候，首先应该要调用超类的clone方法来完成浅复制，然后才去定制自己需要完成的深度复制。</p>
<blockquote>
<p>在重写clone方法的时候，我们返回的类型是Employee，而不是原本自带的Object，与super类有别，这个是Java5后的特性，为clone指定正确的返回类型，这就是协变返回类型。</p>
</blockquote>
<p>标记为Clone的类，在执行克隆方法的时候是内存二进制克隆，比new一个对象性能更好，但是直接在内存中拷贝，构造方法并不会被执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java随笔-对象克隆&quot;&gt;&lt;a href=&quot;#Java随笔-对象克隆&quot; class=&quot;headerlink&quot; title=&quot;Java随笔 - 对象克隆&quot;&gt;&lt;/a&gt;Java随笔 - 对象克隆&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文总结Java对象的浅复制和深复
    
    </summary>
    
    
      <category term="Java" scheme="http://linzhs.cm/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android中的动画和图形绘制</title>
    <link href="http://linzhs.cm/2017/03/25/Android%E4%B8%AD%E7%9A%84Animation/"/>
    <id>http://linzhs.cm/2017/03/25/Android中的Animation/</id>
    <published>2017-03-25T06:29:28.131Z</published>
    <updated>2017-03-25T06:29:28.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中的动画和图形绘制"><a href="#Android中的动画和图形绘制" class="headerlink" title="Android中的动画和图形绘制"></a>Android中的动画和图形绘制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android框架中提供了比较丰富的动画UI和2D、3D图形绘制API，包括底层的OpenGL和封装好的Animation。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>Android框架提供了两种动画模式，分别是属性动画（property animation）和视图动画（view animation）。Android官方比较推荐属性动画，它比较灵活，也具备更多的功能。除此之外，还可以利用drawable动画，来加载绘制的资源，连续播放每一帧。</p>
<ul>
<li><p>属性动画(Property Animation)</p>
<p>  在Android 3.0 （即API 11）之后，Android加入了属性动画，功能很强大。属性动画允许你通过修改任意的属性值来控制动画，包括未渲染到屏幕上的。属性动画也是可拓展的，可以让你自定义动画的属性类型。</p>
</li>
</ul>
<ul>
<li><p>视图动画(View Animation)</p>
<p>  视图动画是比较老的模式了，在Android 3.0之后，集成了3.0之前的补间动画（Tween）和帧动画（Frame），只能用于浏览。视图动画比较简单，也提供了能足够的能力来满足应用程序的需求。</p>
</li>
<li><p>可绘制动画(Drawable Animation)</p>
<p>  在Android3.0之后出现了这一概念，其实功能和帧动画一毛一样。</p>
</li>
</ul>
<h2 id="2D和3D图形"><a href="#2D和3D图形" class="headerlink" title="2D和3D图形"></a>2D和3D图形</h2><p>在Android的框架里，除了提高了丰富的2D图形绘制之外，还内置了3D绘图引擎，可以根据不同的需求来设计自己的应用程序。</p>
<ul>
<li><p>Canvas和Drawanles</p>
<p>  Android提供了一组View，用于提供各种各样的用户界面的一般功能部件。我们可以扩展这些小部件来修改它们的样式和行为。此外，也可以使用包含在各种绘图方式做自定义2D渲染Canvas类或创建Drawable的事情对象，如纹理按钮或帧动画。</p>
</li>
<li><p>硬件加速</p>
<p>  Android3.0开始，可以用硬件来加速Canvas API的图形绘制，从而提升其性能。</p>
</li>
<li><p>OpenGL</p>
<p>  Android中内置了OpenGL的3D图形绘制嵌入式版本，也就是OpenGL ES，可以通过NDK和C/C++相结合开发，其具备平台独立性。对于游戏开发来说，OpenGL是很重要的。</p>
</li>
</ul>
<h2 id="视图动画（View-Animation）"><a href="#视图动画（View-Animation）" class="headerlink" title="视图动画（View Animation）"></a>视图动画（View Animation）</h2><p>作为最早出现的动画模式，视图动画集成了Android3.0之前的补间动画和帧动画，由于帧动画和Drawable动画很类似，所以在这一小节只学习Tween动画。</p>
<p>Tween主要用于显示淡入淡出（alpha）、缩放（scale）、旋转（rotate）、移动（translate）等效果，这些操作可以通过XML和Android代码的动画集（Animation Set）来实现。在XML中定义动画集，就像是在XML定义布局一样，简洁，可读性、复用性也强，</p>
<p>下面通过在XML定义动画集的例子来学习Tween动画的旋转、缩放、移动、淡入淡出效果。</p>
<p>File Location:</p>
<pre><code>/res/anim/anim_alpla.xml
/res/anim/anim_scale.xml
/res/anim/rotate_scale.xml
/res/anim/translate_scale.xml
</code></pre><p>XML和Java代码实现：</p>
<p>anim_alpha.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:shareInterpolator=&quot;false&quot;</div><div class="line">    android:fillAfter=&quot;true&quot;</div><div class="line">    android:fillBefore=&quot;true&quot; &gt;</div><div class="line">    &lt;!--</div><div class="line">        shareInterpolator 分享插值器，这里静止</div><div class="line">        fillAfter和fillBefore两者同时设置，最终只显示fillAfter的效果</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">        fromAlpha:Float.起始动画时的不透明度，0.0表示透明，1.0表示不透明</div><div class="line">        toAlpha:Float.结束动画时的不透明度，0.0表示透明，1.0表示不透明</div><div class="line">     --&gt;</div><div class="line">    &lt;!-- 透明度从1.0变化到0.1，且动画结束后保留最后一帧的效果 --&gt;</div><div class="line">    &lt;alpha</div><div class="line">        android:fromAlpha=&quot;1.0&quot;</div><div class="line">        android:toAlpha=&quot;0.1&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p>
<p>anim_scale.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">        fromXScale &amp; fromYScale : float 伸缩起始时坐标</div><div class="line">        toXScale &amp; toYScale : float 伸缩结束时坐标</div><div class="line">        pivotX &amp; pivotY : float 当对象伸缩的时候X &amp; Y坐标保持不变 这里未使用</div><div class="line">    --&gt;</div><div class="line">    &lt;!-- 从(0.1, 0.1)到(1.0, 1.0) --&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:fromXScale=&quot;0.1&quot;</div><div class="line">        android:fromYScale=&quot;0.1&quot;</div><div class="line">        android:toXScale=&quot;1.0&quot;</div><div class="line">        android:toYScale=&quot;1.0&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p>
<p>anim_rotate.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">        fromDegrees &amp; toDegrees : float 动画开始和结束时的角度</div><div class="line">        pivotX &amp; pivotY：float or percentage 用Float（如(x,y)=(5,5)）代表中心为整个布局的左上角(5,5)，</div><div class="line">        用百分比(如(x,y)=(50%，50%))代表中心为该控件的中心，用百分比(如(x,y)=(50%p，50%p))代表中心为该控件的父控件的中心</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    &lt;rotate</div><div class="line">        android:fromDegrees=&quot;0&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot;</div><div class="line">        android:toDegrees=&quot;720&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p>
<p>anim_translate.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">        fromXDelta &amp; toXDelta : 位移开始和结束时x的位置。</div><div class="line">        fromYDelta &amp; toYDelta : 位移开始和结束时y的位置。</div><div class="line">    --&gt;</div><div class="line">    &lt;!-- 从（0，0）位移到（100，100）--&gt;</div><div class="line">    &lt;translate</div><div class="line">        android:fromXDelta=&quot;0&quot;</div><div class="line">        android:fromYDelta=&quot;0&quot;</div><div class="line">        android:toXDelta=&quot;100&quot;</div><div class="line">        android:toYDelta=&quot;100&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p>
<p>Animation.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public void onClick(View v) &#123;</div><div class="line">        switch (v.getId()) &#123;</div><div class="line">            case R.id.button_alpha_xml:</div><div class="line">                //AnimationUtils.loadAnimation()方法返回Animation对象，所以alphaAnimation为Animation</div><div class="line">                alphaAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha);</div><div class="line">                alphaAnimation.setDuration(1500);//设置动画时间为1.5ms</div><div class="line">                imageView.startAnimation(alphaAnimation);//启动动画</div><div class="line">                break;</div><div class="line">            case R.id.button_alpha_code:</div><div class="line">                //AlphaAnimation(float fromAlpha,float toAlpha)</div><div class="line">                //fromAlpha:起始动画时的不透明度，0.0表示透明，1.0表示不透明</div><div class="line">                //toAlpha:结束动画时的不透明度，0.0表示透明，1.0表示不透明</div><div class="line">                //透明度从0.1——&gt;1.0</div><div class="line">                alphaAnimation = new AlphaAnimation(0.1f, 1.0f);</div><div class="line">                alphaAnimation.setDuration(1500);</div><div class="line">                imageView.startAnimation(alphaAnimation);</div><div class="line">                break;</div><div class="line">            case R.id.button_scale_xml:</div><div class="line">                scaleAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_scale);</div><div class="line">                scaleAnimation.setDuration(3000);</div><div class="line">                imageView.startAnimation(scaleAnimation);</div><div class="line">                break;</div><div class="line">            case R.id.button_scale__code:</div><div class="line">                //ScaleAnimation(float fromX, float toX, float fromY, float toY)</div><div class="line">                //另外还有pivotXType、pivotYType：伸缩模式，</div><div class="line">                //pivotXValue、pivotYValue伸缩动画相对于x,y 坐标的开始位置</div><div class="line">                scaleAnimation = new ScaleAnimation(1.0f, 0.1f, 1.0f, 0.1f);</div><div class="line">                scaleAnimation.setDuration(3000);</div><div class="line">                imageView.startAnimation(scaleAnimation);</div><div class="line">                break;</div><div class="line">            case R.id.button_rotate_xml:</div><div class="line">                rotateAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_rorate);</div><div class="line">                rotateAnimation.setDuration(3000);</div><div class="line">                imageView.startAnimation(rotateAnimation);</div><div class="line">                break;</div><div class="line">            case R.id.button_rotate__code:</div><div class="line">                //RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,int pivotYType, float pivotYValue)</div><div class="line">                //pivotXType、pivotYType:中心点类型，主要有Animation.ABSOLUTE、Animation.RELATIVE_TO_PARENT、Animation.RELATIVE_TO_SELF</div><div class="line">                //pivotXValue、pivotYValue:根据pivotType决定旋转效果</div><div class="line">                rotateAnimation = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">                rotateAnimation.setDuration(3000);</div><div class="line">                rotateAnimation.setFillAfter(true);//设置动画结束时是否停留在最后一帧</div><div class="line">                imageView.startAnimation(rotateAnimation);</div><div class="line">                break;</div><div class="line">            case R.id.button_translate_xml:</div><div class="line">                translateAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_translate);</div><div class="line">                translateAnimation.setFillAfter(true);</div><div class="line">                translateAnimation.setDuration(3000);</div><div class="line">                imageView.startAnimation(translateAnimation);</div><div class="line">                break;</div><div class="line">            case R.id.button_translate__code:</div><div class="line">                //TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)</div><div class="line">                translateAnimation = new TranslateAnimation(0, 100, 0, 100);</div><div class="line">                translateAnimation.setDuration(3000);</div><div class="line">                translateAnimation.setFillAfter(true);</div><div class="line">                imageView.startAnimation(translateAnimation);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>组合使用</p>
<p>xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:fillAfter=&quot;true&quot;</div><div class="line">    android:duration=&quot;3000&quot; &gt;</div><div class="line"></div><div class="line">    &lt;alpha</div><div class="line">        android:fromAlpha=&quot;1.0&quot;</div><div class="line">        android:toAlpha=&quot;0.1&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;rotate</div><div class="line">        android:fromDegrees=&quot;0&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot;</div><div class="line">        android:toDegrees=&quot;720&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;scale</div><div class="line">        android:fromXScale=&quot;0.1&quot;</div><div class="line">        android:fromYScale=&quot;0.1&quot;</div><div class="line">        android:toXScale=&quot;1.0&quot;</div><div class="line">        android:toYScale=&quot;1.0&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;translate</div><div class="line">        android:fillAfter=&quot;true&quot;</div><div class="line">        android:fromXDelta=&quot;0&quot;</div><div class="line">        android:fromYDelta=&quot;0&quot;</div><div class="line">        android:toXDelta=&quot;100&quot;</div><div class="line">        android:toYDelta=&quot;100&quot; /&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p>
<p>java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void onClick(View v) &#123;</div><div class="line">        switch (v.getId()) &#123;</div><div class="line">            //Mutiple Animation实现方法一</div><div class="line">            case R.id.btn_mutiple_anim_one:</div><div class="line">                animationSet = new AnimationSet(true);</div><div class="line">                Animation alphaAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_alpha);</div><div class="line">                Animation scaleAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_scale);</div><div class="line">                Animation rotateAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_rotate);</div><div class="line">                Animation translateAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_translate);</div><div class="line">                animationSet.addAnimation(alphaAnimation);</div><div class="line">                animationSet.addAnimation(scaleAnimation);</div><div class="line">                animationSet.addAnimation(rotateAnimation);</div><div class="line">                animationSet.addAnimation(translateAnimation);</div><div class="line">                imageView.startAnimation(animationSet);</div><div class="line">                break;</div><div class="line">            //Mutiple Animation实现方法二</div><div class="line">            case R.id.btn_mutiple_anim_two:</div><div class="line">                Animation mutipleAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_mutiple);</div><div class="line">                imageView.startAnimation(mutipleAnimation);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>帧动画，包括Frame Animation和Drawable Animation，可以通过连续加载资源实现连续动画，类似于GIF等，就像在放电影。和Tween Animation一样，帧动画也可在XML和Java代码中实现。</p>
<p>下面为简单的例子，预先在res/drawable目录放一些图片，然后在该目录下创建文件连续动画文件：<br>/res/drawable/fruit_animlist.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:oneshot=&quot;true&quot;&gt;</div><div class="line"></div><div class="line">    &lt;item android:drawable=&quot;@drawable/apple_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/banana_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/cherry_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/grape_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/mango_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/orange_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/pineapple_pic&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/animation-list&gt;</div></pre></td></tr></table></figure></p>
<p>java code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void onClick(View v) &#123;</div><div class="line">    switch (v.getId()) &#123;</div><div class="line">        case R.id.button_anim_list_xml:</div><div class="line">                imageView.setImageResource(R.drawable.fruit_animlist);//设置动画集</div><div class="line">                AnimationDrawable animationDrawable = (AnimationDrawable)imageView.getDrawable();</div><div class="line">                animationDrawable.start();</div><div class="line">                break;</div><div class="line">        case R.id.button_anim_list_code:</div><div class="line">            AnimationDrawable anim = new AnimationDrawable();</div><div class="line">            for (int i = 1; i &lt; 10; ++i) &#123;</div><div class="line">                int id = getResources().getIdentifier(&quot;fruit_&quot; + i, &quot;drawable&quot;, getPackageName());</div><div class="line">                Drawable drawable = getResources().getDrawable(id);</div><div class="line">                anim.addFrame(drawable, 200);</div><div class="line">            &#125;</div><div class="line">            anim.setOneShot(false);</div><div class="line">            imageView.setImageDrawable(anim);</div><div class="line">            anim.start();</div><div class="line">            //anim.stop() anim.isRunning()</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;    </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在较大型的帧动画显示中，会出现卡顿的情况，这是View和OOM的原因，可以使用双缓冲的surfaceView来实现。</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>属性动画是Android3.0后引入的，是一个强大的框架，可以让你绘制几乎任何东西。无论有没有显示在屏幕上，属性动画可以随着时间去修改属性的值来控制动画。</p>
<p>属性动画相关类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>ValueAnimation</td>
<td>属性动画主要的计时器，也计算动画后的属性的值，动画的执行类</td>
</tr>
<tr>
<td>ObjectAnimator</td>
<td>ValueAnimator的一个子类，允许你设置一个目标对象和对象的属性进行动画，动画的执行类</td>
</tr>
<tr>
<td>AnimatorSet</td>
<td>提供组织动画的结构，使它们能相关联得运行，用于控制一组动画的执行</td>
</tr>
<tr>
<td>AnimatorInflater</td>
<td>用户加载属性动画的xml文件</td>
</tr>
<tr>
<td>Evaluators</td>
<td>属性动画计算器，告诉了属性动画系统如何计算给出属性的值</td>
</tr>
<tr>
<td>Interpolators</td>
<td>动画插入器，定义动画的变化率</td>
</tr>
</tbody>
</table>
<p>类之间的关系：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://images2015.cnblogs.com/blog/950883/201608/950883-20160820155327312-1227516581.png" alt="iamge" title="">
                </div>
                <div class="image-caption">iamge</div>
            </figure></p>
<p>接下来用几个例子来学习一下怎么使用属性动画，注意，==xml文件必须放在/res/animator中==。</p>
<ul>
<li>ObjectAnimation（用属性动画实现视图动画的淡入淡出效果，缩放、移动、旋转等类似）</li>
</ul>
<p>alpha_anim.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;500&quot;</div><div class="line">    android:propertyName=&quot;alpha&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;</div><div class="line">    android:startOffset=&quot;200&quot;</div><div class="line">    android:valueFrom=&quot;0.0&quot;</div><div class="line">    android:valueTo=&quot;1.0&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">        duration 表示动画执行的时间</div><div class="line">        propertyName 表示修改的物件的哪个属性值，这里是透明度</div><div class="line">        valueFrom 表示从哪个状态值开始动画</div><div class="line">        valueTo 表示到哪个状态值结束动画</div><div class="line">        valueType 类型估值，主要用于设置动画操作属性的值</div><div class="line">        repeatCount 动画重复的计数，动画将会执行该值+1次</div><div class="line">        repeatMode 动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。restart为重新执行，方向不变</div><div class="line">        startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间，单位毫秒</div><div class="line">        interpolator 指定动画插入器</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">&lt;/objectAnimator&gt;</div></pre></td></tr></table></figure></p>
<p>对应Java code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//ImageView预先设置好图片</div><div class="line">//xml实现</div><div class="line"></div><div class="line">//ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()这几个方法</div><div class="line">//都是设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值</div><div class="line">//ofFloat(Object target, String propertyName, float... values)</div><div class="line">Animator anim = AnimatorInflater.loadAnimator(this, R.animator.property_animation);</div><div class="line">anim.setTarget(imageView);</div><div class="line">anim.start();</div><div class="line"></div><div class="line">//java code</div><div class="line">ObjectAnimator alphaAnimation = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0f, 1f);</div><div class="line">alphaAnimation.setDuration(500);</div><div class="line">alphaAnimation.setRepeatCount(0);</div><div class="line">alphaAnimation.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">alphaAnimation.setStartDelay(200);</div><div class="line">alphaAnimation.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">alphaAnimation.start();</div></pre></td></tr></table></figure></p>
<p>scale_anim.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">　　android:duration=&quot;500&quot;</div><div class="line">　　android:propertyName=&quot;scaleX&quot;</div><div class="line">　　android:repeatCount=&quot;1&quot;</div><div class="line">　　android:repeatMode=&quot;reverse&quot;</div><div class="line">　　android:valueFrom=&quot;1.0&quot;</div><div class="line">　　android:valueTo=&quot;1.5&quot;</div><div class="line">　　android:valueType=&quot;floatType&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>java code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f);</div><div class="line">   scaleXAnimator.setDuration(500);</div><div class="line">   scaleXAnimator.setRepeatCount(1);</div><div class="line">   scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">   scaleXAnimator.start();</div></pre></td></tr></table></figure></p>
<p>rotate_anim.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;500&quot;</div><div class="line">    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</div><div class="line">    android:propertyName=&quot;rotation&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;360&quot;</div><div class="line">    android:valueType=&quot;floatType&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>java code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;rotation&quot;, 0f, 360f);</div><div class="line">    objectAnimator.setDuration(500);</div><div class="line">    objectAnimator.setRepeatCount(1);</div><div class="line">    objectAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">    objectAnimator.start();</div></pre></td></tr></table></figure></p>
<p>translate_anim.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;500&quot;</div><div class="line">    android:propertyName=&quot;translationX&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;</div><div class="line">    android:valueFrom=&quot;0&quot;</div><div class="line">    android:valueTo=&quot;100&quot;</div><div class="line">    android:valueType=&quot;floatType&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>java code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;translationX&quot;, 0f, 100f);</div><div class="line">    objectAnimator.setDuration(500);</div><div class="line">    objectAnimator.setRepeatCount(1);</div><div class="line">    objectAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">    objectAnimator.start();</div></pre></td></tr></table></figure></p>
<ul>
<li>Animation（组合动画）</li>
</ul>
<p>anim_set.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:ordering=&quot;together&quot;&gt;</div><div class="line">    &lt;objectAnimator</div><div class="line">        android:duration=&quot;500&quot;</div><div class="line">        android:propertyName=&quot;scaleX&quot;</div><div class="line">        android:repeatCount=&quot;1&quot;</div><div class="line">        android:repeatMode=&quot;reverse&quot;</div><div class="line">        android:valueFrom=&quot;1.0&quot;</div><div class="line">        android:valueTo=&quot;1.5&quot;</div><div class="line">        android:valueType=&quot;floatType&quot; /&gt;</div><div class="line">    &lt;objectAnimator</div><div class="line">        android:duration=&quot;500&quot;</div><div class="line">        android:propertyName=&quot;scaleY&quot;</div><div class="line">        android:repeatCount=&quot;1&quot;</div><div class="line">        android:repeatMode=&quot;reverse&quot;</div><div class="line">        android:valueFrom=&quot;1.0&quot;</div><div class="line">        android:valueTo=&quot;1.5&quot;</div><div class="line">        android:valueType=&quot;floatType&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure></p>
<p>java code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//加载动画</div><div class="line">Animator anim = AnimatorInflater.loadAnimator(this, R.animator.animator_scale);</div><div class="line">      anim.setTarget(imageView);</div><div class="line">      anim.start();</div><div class="line">      </div><div class="line">//纯代码实现</div><div class="line">AnimatorSet animatorSet = new AnimatorSet();</div><div class="line"></div><div class="line">    ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f);</div><div class="line">    scaleXAnimator.setDuration(500);</div><div class="line">    scaleXAnimator.setRepeatCount(1);</div><div class="line">    scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">    scaleXAnimator.start();</div><div class="line"></div><div class="line">    ObjectAnimator scaleYAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 1.5f);</div><div class="line">    scaleYAnimator.setDuration(500);</div><div class="line">    scaleYAnimator.setRepeatCount(1);</div><div class="line">    scaleYAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line"></div><div class="line">    animatorSet.playTogether(scaleXAnimator, scaleYAnimator);</div><div class="line">    animatorSet.start();</div></pre></td></tr></table></figure></p>
<h2 id="视图动画和属性动画的区别"><a href="#视图动画和属性动画的区别" class="headerlink" title="视图动画和属性动画的区别"></a>视图动画和属性动画的区别</h2><p>在视图动画中，止提供了唯一的View动画对象，如果要完成非View对象，那就玩自己去完成这部分带吗。在View视图中，其仅仅提供了一些功能，比如旋转、缩放等，但没有实现背景颜色这些，是有一定的局限性的。</p>
<p>视图动画只是修改了被画的东西，而不是自己本身。</p>
<p>属性动画把这些限制的缺点都去除了，使动画更加健壮，动画更加丰富。</p>
<p>视图动画的实现只需要少量的代码和时间，所以如果是小型的动画，可以用视图动画来完成。Android还保留着view动画，也是有它的用处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中的动画和图形绘制&quot;&gt;&lt;a href=&quot;#Android中的动画和图形绘制&quot; class=&quot;headerlink&quot; title=&quot;Android中的动画和图形绘制&quot;&gt;&lt;/a&gt;Android中的动画和图形绘制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr
    
    </summary>
    
    
      <category term="DataStructure&amp;Algorithm" scheme="http://linzhs.cm/tags/DataStructure-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法理论学习 -- 队列</title>
    <link href="http://linzhs.cm/2017/03/25/queue/"/>
    <id>http://linzhs.cm/2017/03/25/queue/</id>
    <published>2017-03-25T06:26:51.208Z</published>
    <updated>2017-03-25T06:26:51.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)是一种先进先出(FIFO)的数据结构，编程中可通过使用数组或者链表来实现。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre><code>enqueue        入队，向队列尾部添加一个元素
dequeue        出队，在队列头部移除一个元素
isEmpty        检查队列是否为空
size        查看队列大小
</code></pre><h3 id="Coding时刻"><a href="#Coding时刻" class="headerlink" title="Coding时刻"></a>Coding时刻</h3><ul>
<li><p>使用链表实现队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Queue&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    private Node first;//指向队列中最早添加的结点</div><div class="line">    private Node last;//指向队列中最近添加的结点</div><div class="line">    private int N;</div><div class="line">    private class Node &#123;//结点类，只在内部使用</div><div class="line">        T item;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean isEmpty() &#123;</div><div class="line">        return first == null;</div><div class="line">        //return N == 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int size() &#123;</div><div class="line">        return N;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void enqueue(T item) &#123;</div><div class="line">        Node oldlast = last;</div><div class="line">        last = new Node();</div><div class="line">        last.item = item;</div><div class="line">        last.next = null;</div><div class="line">        if (isEmpty() == true) first = last;</div><div class="line">        else oldlast.next = last;</div><div class="line">        N++; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Item dequeue() &#123;</div><div class="line">        Item item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        if (isEmpty()) last = null;</div><div class="line">        N--;</div><div class="line">        return item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现两个栈实现队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Solution&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    private static Stack&lt;T&gt; stack1 = new Stack&lt;&gt;();//入队</div><div class="line">    private static Stack&lt;T&gt; stack2 = new Stack&lt;&gt;();//出队</div><div class="line"></div><div class="line">    public void enqueue(T element) &#123;</div><div class="line">        stack1.push(element);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T dequeue() &#123;</div><div class="line">        if (stack2.isEmpty() == true) &#123;//出队，将stack1中的元素弹出，并且在stack2中入栈</div><div class="line">            while (stack1.isEmpty() == false) &#123;</div><div class="line">                T data = stack1.pop();</div><div class="line">                stack2.push(data);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (stack2.isEmpty() == true) &#123;</div><div class="line">            throw new Exception(&quot;queue is empty.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return stack2.pop();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h3><p>普通队列在现实计算机当中应用非常广泛，比如播放器的播放列表，数据流对象，异步数据传输结构(文件IO，管道通信，套接字等)，<br>多线程中的阻塞队列，打印机队列，消息队列等等。</p>
<h2 id="队列的常见衍生版本"><a href="#队列的常见衍生版本" class="headerlink" title="队列的常见衍生版本"></a>队列的常见衍生版本</h2><h3 id="1-循环队列"><a href="#1-循环队列" class="headerlink" title="1.循环队列"></a>1.循环队列</h3><p>在普通队列的基础上，将队列的头部和尾部相连接，就构成了循环队列这种数据结构。循环队列可以充分利用结构的空间，克服<br>队列的“假溢出”这种现象。循环队列可以通过数据和链表来实现。<br>    循环队列的一些基本的判断条件和性质：</p>
<pre><code>初始化条件为：队头指针是front，队尾是rear，队列的最大长度为QueueSize
1.队列为空                      rear == front
2.队列满                        (rear + 1) % QueueSize == front
3.队列的长度                    n = (rear - front + 1) % QueueSize
4.入队后rear指向                (rear + 1) % QueueSize
5.出队后front指向               (front + 1) % QueueSize
</code></pre><h3 id="2-双端队列"><a href="#2-双端队列" class="headerlink" title="2.双端队列"></a>2.双端队列</h3><p>双端队列是一种同时具有队列和栈的性质的一种数据结构，在队列的两头都可以进行插入和删除的操作，同时也可以对双端<br>队列做一些限制。</p>
<pre><code>输入受限的双端队列是指只能从队列一端输入，但可以从两端输出的双端队列；
输出受限的双端队列是指只能从队列一端输出，但可以从两端输入的双端队列；
如果双端队列允许从一端输入，从一端输出，则是普通的队列，如果双端队列只允许从一端输入和输出则是栈，
因此说双端队列同时具有队列和栈两种数据结构的性质。
</code></pre><h3 id="3-优先队列-堆-Heap"><a href="#3-优先队列-堆-Heap" class="headerlink" title="3.优先队列(堆, Heap)"></a>3.优先队列(堆, Heap)</h3><p>堆也是队列，但强调的是“<a href="">优先</a>”二字，每个在队列中取出的元素都具备最高优先权，若是最大堆，则每次取出必定是当前堆中<br>最大的元素，同理，若是最小堆而取出元素为最小。<br>堆有着广泛的应用，比如抢占式优先级的系统等。<br>堆还有着各种衍生结构，这里就不在详细说明，有关堆的知识，将专门开一篇文章来了解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文所述的队列知识比较简单，队列在数据结构中确实算是比较简单的，但是应用却是非常广泛。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队列-Queue&quot;&gt;&lt;a href=&quot;#队列-Queue&quot; class=&quot;headerlink&quot; title=&quot;队列(Queue)&quot;&gt;&lt;/a&gt;队列(Queue)&lt;/h2&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink
    
    </summary>
    
    
      <category term="DataStructure&amp;Algorithm" scheme="http://linzhs.cm/tags/DataStructure-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法理论学习 -- 栈</title>
    <link href="http://linzhs.cm/2017/03/25/stack/"/>
    <id>http://linzhs.cm/2017/03/25/stack/</id>
    <published>2017-03-25T06:25:40.600Z</published>
    <updated>2017-03-25T06:25:40.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 (Stack)"></a>栈 (Stack)</h1><h2 id="1-栈的概念"><a href="#1-栈的概念" class="headerlink" title="1. 栈的概念"></a>1. 栈的概念</h2><p>栈是一种先进后出(First in last off, FILO/LIFO)线性数据结构。很多人叫栈为堆栈，但是堆和栈是不同的数据结构。</p>
<h2 id="2-栈的实现"><a href="#2-栈的实现" class="headerlink" title="2. 栈的实现"></a>2. 栈的实现</h2><p>栈可以用数组和链表来实现。栈的基本操作有入栈、出栈、查看栈顶、判空等。</p>
<h2 id="3-栈的常见应用"><a href="#3-栈的常见应用" class="headerlink" title="3. 栈的常见应用"></a>3. 栈的常见应用</h2><p>栈的应用很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、<br>浏览器中的回退操作、编译器中的函数调用实现、表达式的计算等。<a href="http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html" target="_blank" rel="external">相关介绍深度好文推荐。</a></p>
<h3 id="3-1-线程栈"><a href="#3-1-线程栈" class="headerlink" title="3.1 线程栈"></a>3.1 线程栈</h3><p>线程栈是操作系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器。</p>
<h3 id="3-2-Object-C和OpenGL中的“绘图上下文”"><a href="#3-2-Object-C和OpenGL中的“绘图上下文”" class="headerlink" title="3.2 Object-C和OpenGL中的“绘图上下文”"></a>3.2 Object-C和OpenGL中的“绘图上下文”</h3><h3 id="3-3-用户按下键盘过滤无效按键"><a href="#3-3-用户按下键盘过滤无效按键" class="headerlink" title="3.3 用户按下键盘过滤无效按键"></a>3.3 用户按下键盘过滤无效按键</h3><h3 id="3-4-算术表达式的计算-此文重点"><a href="#3-4-算术表达式的计算-此文重点" class="headerlink" title="3.4 算术表达式的计算(此文重点)"></a>3.4 算术表达式的计算(<a href="">此文重点</a>)</h3><h2 id="编程中算术表达式计算"><a href="#编程中算术表达式计算" class="headerlink" title="编程中算术表达式计算"></a>编程中算术表达式计算</h2><p>在此主要介绍栈在编程语言中的一大用处。<br>编程语言中，算术表达式有前缀、中缀、后缀之分，他们都是对算术表达式的编程语言表达、记忆方式。</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><pre><code>前缀表达式: - * + 3 4 5 6
中缀表达式: (3 + 4) * 5 - 6
后缀表达式: 3 4 + 5 * 6 -
</code></pre><p>如上面例子所示，前中后缀表达式各不相同，其中很容易发现，中缀表达式是人在数学中所常用，且习惯的一种。<br>算术表达式中，主要由算术运算符和操作数组成，前中后缀表达式也是由此来区分的，也导致了表示的顺序不一样。</p>
<h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><pre><code>前缀表达式：算术运算符在前，操作数在后，不包含括号; 为纪念波兰数学家、此表达式发明者Jan Lukasiewicz，此表达式也成为&quot;波兰表达式&quot;；
中缀表达式：算术运算符在操作数中间，相比前后缀表达式，多了表示优先级的括号；
后缀表达式：算术运算符在后，操作数在前，正好与前缀相反，所以也成为&quot;逆波兰表达式&quot;。
</code></pre><h4 id="传统算术表达式的运算规则"><a href="#传统算术表达式的运算规则" class="headerlink" title="传统算术表达式的运算规则"></a>传统算术表达式的运算规则</h4><p>中缀表达式是人类最容易理解的和分析的表达方式，回忆我们对中缀表达式的运算规则：</p>
<pre><code>1.在有括号的情况下，括号优先级最高，优先计算括号内的内容；
2.在无括号的情况下，按运算符优先级进行先后计算，先乘除，后加减；
3.在相同优先级的情况下，从左到右计算。
</code></pre><h4 id="各表达式的优缺点"><a href="#各表达式的优缺点" class="headerlink" title="各表达式的优缺点"></a>各表达式的优缺点</h4><ul>
<li><p>在中缀表达式的计算当中，需要不断遍历找出表达式中的括号和优先级较高的运算符，并且考虑操作出现的先后，这对于<br>人来说是简而易举的，但是对于计算机这种一根筋，只能处理0和1的机器来说，显然太复杂了，就算是实现了，时间复杂度<br>也是很恐怖的，毕竟运算符和操作数不可能总是只有几个，这时候出现的前缀和后缀表达式就很有用处了，也是专门为计算机<br>设计的。</p>
</li>
<li><p>在前缀和后缀表达式中，计算顺序不必随着运算符和括号不断变换，而是从左到右或是从右到左顺序遍历一次，不需要考虑<br>括号对运算的影响，再辅之的数据结构(Stack)，可完美完成计算，大大降低了计算的时间复杂度，也符合计算机的工作方式。<br>前缀和后缀表达式大大提高了计算机计算的性能，但对于人来说是不易理解的，特别是对于没有编程基础的人来说，所以在<br>输入和输出表达式给计算机计算的时候需要进行表达式转换，中缀(输入) -&gt; 前缀/后缀(计算) -&gt; 结果(输出)。</p>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1.中缀表达式 -&gt; 后缀表达式 [ 例子：a + b * c - (d + e) ]</p>
<pre><code>人工转换：
    1.给中缀表达式的所有运算加上括号    ( (a + (b * c)) - (d + e) )
    2.将运算符放到括号后面        ( (a (b c)*)+ (de)+ )-
    3.去除括号            a b c * + d e + -

计算机转换(用栈辅助)：
    1.建立运算符栈(大小合适，这里只存储运算符)；
    2.从左到右遍历中缀表达式：
        如果遇到操作数，则直接输出；
        如果遇到运算符，则与栈顶的运算符比较优先级：
            若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈；
            若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为
            空，或者栈顶的运算符的优先级低于当前的运算符)。
        如果遇到括号：
            若为 &quot;(&quot; ，则直接入栈；
            若为 &quot;)&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;(&quot;，才同时把 &quot;()&quot; 删除。
</code></pre><p>计算机转换模拟 [ 例子：a + b * c - (d + e) ]</p>
<pre><code>输出终端                    运算符栈(栈底 -&gt; 栈顶)
a            |    
a            |    +
ab            |    +
ab            |    +*
abc            |    +*
abc*                |    +
abc*+                |    
abc*+                |    -
abc*+                |    -(
abc*+                |    -(+
abc*+d                |    -(+
abc*+de                |    -(+
abc*+de+            |    -(
abc*+de+            |    -
abc*+de+-            |
</code></pre><p>2.中缀表达式 -&gt; 前缀表达式 [ 例子：a + b * c - (d + e) ]</p>
<pre><code>人工转换：
    1.给中缀表达式的所有运算加上括号    ( (a + (b * c)) - (d + e) )
    2.将运算符放到括a号前面        ( -(+(a *(bc)) +(de) )
    3.去除括号                - + a * b c + d e

计算机转换(用栈辅助):
    1.建立运算符栈和输出栈(大小合适)，其中输出栈用于存储输出数据，完成遍历后出栈的元素顺序即为前缀表达式；
    2.从右向左遍历中缀表达式:
        如果遇到操作数，则直接输出;
        如果遇到运算符，则与栈顶的运算符比较优先级：
            若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈；
            若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为
            空，或者栈顶的运算符的优先级低于当前的运算符)。
        如果遇到括号：
            若为 &quot;)&quot; ，则直接入栈；
            若为 &quot;(&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;)&quot;，才同时把 &quot;()&quot; 删除。
</code></pre><p>计算机转换模拟 [ 例子：a + b * c - (d + e) ]</p>
<pre><code>输出栈(栈底 -&gt; 栈顶)        运算符栈(栈底 -&gt; 栈顶)
            |    )
e            |    
e            |    )+
ed+            |    
ed+            |    -
ed+c                |    -    
ed+c                |    -*
ed+cb            |    -
ed+cb*            |    -
ed+cb*            |    -+
ed+cb*a            |    -+
ed+cb*a+        |    -
ed+cb*a+-        |    

所以，输出的前缀表达式为-+a*bc+de。
</code></pre><p>3.构建表达式树</p>
<pre><code>下面将表达式和二叉树的知识结合，将后缀表达式转换为二叉树 [ 例子: a b c * + d e + - ]
    1.建立栈，大小为操作数个数，这里为5；
    2.将操作数从左到右入栈，若遇到操作符，则将前面两个元素弹出，并用当前栈顶指向形成的二叉树的根节点；
    3.最终合并二叉树。
演示：
    1. a b c
    2. a         |
            |
           / \
          b   c
    3.                    +
                /   \
                a    *
                    / \
                   b   c
    4.                                  +                d e
                            /   \
                            a        *
                                / \
                               b   c
    5.                                                +            +
                                        /   \           / \
                                        a        *        d   e
                                            / \
                                           b   c
    6.                                                            -
                                                        /    \
                                                       /      \        
                                                      /        \
                                                      +        +
                                                    /   \       / \     
                                                    a    *    d   e    
                                                        / \           
                                                       b   c       
</code></pre><h2 id="Coding时刻"><a href="#Coding时刻" class="headerlink" title="Coding时刻"></a>Coding时刻</h2><ul>
<li>栈的数组实现</li>
</ul>
<p>接下来来实现栈，这里先使用Java级数组来实现，下面再使用链表来搭建栈结构及其相关操作。</p>
<p>下面为要实现的操作方法API：</p>
<blockquote>
<p>Stack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Stack&lt;T&gt; &#123;</div><div class="line">    public Stack();</div><div class="line">    public void push(T item);</div><div class="line">    public boolean isEmpty();</div><div class="line">    public int size();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>在写出最终的实现代码之前，我们必须考虑应用数组或者其他形式来实现栈这种数据结构怎么样才能让其功能和性能最优。下面为重点考虑的几点：</p>
<blockquote>
<ol>
<li><p>支持泛型。原因要使栈所支持的数据类型更加广泛通用，而不是需要String的时候写一遍栈的实现，再需要Integer类型的时候又重新写一遍针对Integer的实现。</p>
</li>
<li><p>支持数组大小自动调节。对于数组来说，没法动态调节大小是一大缺点，随机查找是它的优势，若存入有效的元素过多导致数组容纳不下，或者存入有效元素很少（有可能为空）且数组大小较大，这些情况在实际应用当中都是非常不合理的，所以我们需要实现数组大小的动态调节。这里采用流行的调节方法，在数组容纳不下的时候将大小调节为原先的2倍，若数组的有效元素为数组的大小的1/4时将大小调节为原先的1/2。</p>
</li>
<li><p>避免对象游离现象。Java的垃圾回收策略是回收所有无法被访问的对象的内存。在我们实现的栈当前，每一个pop弹出栈顶元素，栈顶指针向栈底移动一位（栈元素足够），但是实际这个被弹出的元素还存留在数组当前，也就是相应的占用这部分内存，GC无法回收。避免对象游离的办法其实很简单，在每次pop的时候将弹出的元素空间置为空。</p>
</li>
<li><p>支持迭代。支持foreach迭代，可以使代码更加整洁。迭代器接口还需要实现remove方法，这个在实现的时候可以不处理，也可以抛出UnsupportedOperationException异常，在实现next方法时候栈为空，则可不处理或者抛出NoSuchElementException。</p>
</li>
</ol>
</blockquote>
<p>解决完以上考虑的问题，即可构建出一个不错的栈结构，具体代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">import java.util.Iterator;//Java迭代器接口所属包</div><div class="line"></div><div class="line">public class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123;</div><div class="line">    private T[] arr;</div><div class="line">    private int len;</div><div class="line"></div><div class="line">    public Stack() &#123;//默认构造器</div><div class="line">        arr = (T)new Object[1];//Java中不支持泛型对象数组 这里采用强制类型转换办法</div><div class="line">        len = 0;//默认元素数量</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void push(T item) &#123;//入栈</div><div class="line">        if (arr.len == len) </div><div class="line">            resize(2 * arr.length);</div><div class="line">        arr[len++] = item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T pop() &#123;//出栈</div><div class="line">        T t = arr[--len];</div><div class="line">        arr[len] = null;//避免对象游离</div><div class="line">        if (len &gt; 0 &amp;&amp; len == arr.length / 4)</div><div class="line">            resize(arr.length / 2);</div><div class="line">        return t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean isEmpty() &#123;//检查栈是否为空</div><div class="line">        return len == 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int size() &#123;//查看栈大小</div><div class="line">        return len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void resize(int max) &#123;//重新分配数组大小</div><div class="line">        T[] t = (T[])new Object[max];</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            t[i] = arr[i];</div><div class="line">        &#125;</div><div class="line">        arr = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Iterator&lt;T&gt; iterator() &#123;</div><div class="line">        return new ReverseArrayIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class ReverseArrayIterator implements Iterator&lt;T&gt; &#123;//内部类，实现迭代器接口</div><div class="line">        //支持先进后出迭代</div><div class="line">        private int i = len;</div><div class="line">        public boolean hasNext() &#123; return i &gt; 0; &#125;</div><div class="line">        public T next() &#123; return arr[--i]; &#125;</div><div class="line">        public void remove &#123; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>栈的链表实现</li>
</ul>
<p>相比数组来实现栈，链表的优势在于可以很方便的插入删除元素，长度也不会受限，但是它的缺点是随机访问的能力变差了很多，所示访问的结点在末尾，那就等于每次都要遍历一次链表，效率是比较低的。这里在pop出元素的时候，Java程序员无需关心结点成为孤儿后会不会导致内存占用，GC会帮你完成收尾工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Stack&lt;T&gt; &#123;</div><div class="line">    </div><div class="line">    private Node first;</div><div class="line">    private int N;</div><div class="line">    </div><div class="line">    private class Node &#123;</div><div class="line">        public T item;</div><div class="line">        public Node next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public  Stack() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean isEmpty() &#123;</div><div class="line">        return first == null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int size() &#123;</div><div class="line">        return N;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void push(T item) &#123;</div><div class="line">        Node oldfirst = first;</div><div class="line">        first = new Node();</div><div class="line">        first.item = item;</div><div class="line">        first.next = oldfirst;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Item pop() &#123;</div><div class="line">        T item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        N--;</div><div class="line">        return item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Dijkstra算法 - 双栈算法表达式求值</li>
</ul>
<p>使用两个栈来实现中缀表达式的求值，这里考虑的是理想情况，将所有运算都加上括号，输入为字符串的形式，实现加减乘除开方操作。基本的思路：</p>
<blockquote>
<ol>
<li><p>将操作数压入操作数栈</p>
</li>
<li><p>将操作符压入操作符栈</p>
</li>
<li><p>忽略左括号</p>
</li>
<li><p>遇到右括号时，弹出一个运算符，弹出运算所需的操作数，并将运算完的结果压入操作数栈</p>
</li>
</ol>
</blockquote>
<p>具体代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class DijkstraTwoStack &#123;</div><div class="line">    </div><div class="line">    private Stack&lt;Character&gt; ops = new Stack&lt;&gt;();</div><div class="line">    private Stack&lt;Double&gt; vals = new Stack&lt;&gt;();</div><div class="line"></div><div class="line">    public DijkstraTwoStack &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static int cal(String expr) &#123;</div><div class="line">        if (expr == null || expr.length &lt;= 1) return 0;</div><div class="line">        for (char c : expr) &#123;</div><div class="line">            if (c.equals(&apos;(&apos;)) ;</div><div class="line">            else if (c.equals(&apos;+&apos;) || c.equals(&apos;-&apos;) || c.equals(&apos;*&apos;) || c.equals(&apos;/&apos;) || c.equals(&apos;s&apos;))//用s表示开方 </div><div class="line">                ops.push(c);</div><div class="line">            else if (c.equals(&apos;)&apos;)) &#123;</div><div class="line">                char op = ops.pop();</div><div class="line">                double v = vals.pop();</div><div class="line">                if (op.equals(&apos;+&apos;)) v = vals.pop() + v;</div><div class="line">                else if (op.equals(&apos;-&apos;)) v = vals.pop() - v;</div><div class="line">                else if (op.equals(&apos;*&apos;)) v = vals.pop() * v;</div><div class="line">                else if (op.equals(&apos;/&apos;)) v = vals.pop() / v;</div><div class="line">                else if (op.equals(&apos;s&apos;)) v = Math.sqrt(v);</div><div class="line">                vals.push(v);</div><div class="line">            &#125; else &#123;</div><div class="line">                vals.push(Double.parseDouble(c));//操作数字符转换为double类型入栈</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文以栈为中心，主要介绍了栈的应用及算术表达式在编程语言中的表达形式。栈在大数据结构中用处很广，在其他数据结构中也能作为很好<br>的辅助，比如迭代版的二叉树遍历、深度优先搜索和广度优先搜索等等。学好栈和队列的时候是算法设计的一大基础，务必要扎实学好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈-Stack&quot;&gt;&lt;a href=&quot;#栈-Stack&quot; class=&quot;headerlink&quot; title=&quot;栈 (Stack)&quot;&gt;&lt;/a&gt;栈 (Stack)&lt;/h1&gt;&lt;h2 id=&quot;1-栈的概念&quot;&gt;&lt;a href=&quot;#1-栈的概念&quot; class=&quot;headerli
    
    </summary>
    
    
      <category term="DataStructure&amp;Algorithm" scheme="http://linzhs.cm/tags/DataStructure-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java中方法(函数)参数的传递</title>
    <link href="http://linzhs.cm/2017/03/22/JavaFuncParamCall/"/>
    <id>http://linzhs.cm/2017/03/22/JavaFuncParamCall/</id>
    <published>2017-03-22T12:05:45.114Z</published>
    <updated>2017-03-22T12:05:45.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中方法-函数-参数的传递"><a href="#Java中方法-函数-参数的传递" class="headerlink" title="Java中方法(函数)参数的传递"></a>Java中方法(函数)参数的传递</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在程序设计语言中，按值调用（call by value）表示方法接收的是调用者提供的值，而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址（指针）。一个方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。</p>
<p>在Java程序设计语言中，总是采用<a href="">按值调用</a>。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><p>例子1<br>用一个方法试图将一个参数值增加到3倍</p>
<pre><code>public static void tripleValue(int x) { // 无法实现
    x = x * 3;
}

public static void main(String[] args) {
    int intValue = 1;
    tripleValue(intValue); 
    System.out.println(intValue); // doubleValue = 1
}
</code></pre></li>
</ul>
<p>说明：在main方法中，我们定义一个变量intValue，其值为1，再调用tripleValue方法，将x传入，完成函数调用后在console上打印x的值，结果还是为原来的值，并未改变。tripleValue方法被调用整个过程运行的步骤如下：</p>
<pre><code>1. x被初始化，且其值为调用者传递参数doubleValue的一个拷贝，即 x = 10
2. 运算x = x * 3 ,即 x * 3 = 30 ，30赋值给x，x = 30 ，x为intValue的一个拷贝，x变了，但是intValue却未曾改变
3. 方法运行结束，释放x
</code></pre><ul>
<li><p>例子2<br>用一个方法实现将一个员工的工资提高2倍</p>
<pre><code>public static void tripleSalary(Employee e) { // 可以实现
    e.raiseSalary(200); //e的salary提高200%
}

public static void main(String... args) {
    Employee harry = new Employee(...);
    tripleSalary(harry);
    System.out.println(harry.salary);
}
</code></pre></li>
</ul>
<p>说明：在main方法中，我们实例化一个Employee对象harry，再调用tripleSalary方法来提高员工的工资，将harry传入，完成函数调用后在console上打印harry的工资，结果工资真的提高的两倍。tripleSalary方法被调用整个过程运行的步骤如下：</p>
<pre><code>1. e被初始化，并且为harry的值的拷贝，这里是一个对象的引用
2. e和harry同时引用一个Employee对象，所以e提高了工资相当于提高了harry的工资
3. 方法运行结束，释放e
</code></pre><ul>
<li><p>例子3<br>很多程序员认为Java中对对象采用的是引用传递，实际上，这样理解是错误的。由于这种误解具有一定的普遍性，所以下面采用一个反例方法来说明，该方法是交换两个员工的对象</p>
<pre><code>public static void swap(Employee x, Employee y) { //无法实现
    Employee e = x;
    x = y;
    y = e;
}

public static void main(String[] args) {
    Employee a = new Employee(&quot;Alice&quot;, ...);
    Employee b = new Employee(&quot;Bob&quot;, ...);
    swap(a, b);
}
</code></pre></li>
</ul>
<p>说明：在main方法中，实例化了两个员工对象，分别是Alice和Bob，然后传递给swap方法。x和y拷贝了a和b，也就是引用了a和b对象，在swap方法内部将x和y进行交换，确实是可以的，交换完成后x引用Bob，y引用Alice，但是，重点是，a还是引用Alice，b还是引用Bob，并没有改变。最后，swap方法结束，x和y也别GC回收。所以，Java中对对象的传递是值传递而不是引用调用，此操作也就是白费了力气。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们首先说明、强调了Java中方法的参数传递不同于其他语言，总是对值的传递而不是引用调用，再用三个例子来说明，下面用3点来总结一下Java中方法参数的使用：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或者布尔型）</li>
<li>一个方法可以修改一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p> <a href="">Java核心技术 卷I 基础知识</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java中方法-函数-参数的传递&quot;&gt;&lt;a href=&quot;#Java中方法-函数-参数的传递&quot; class=&quot;headerlink&quot; title=&quot;Java中方法(函数)参数的传递&quot;&gt;&lt;/a&gt;Java中方法(函数)参数的传递&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a hr
    
    </summary>
    
    
      <category term="Java" scheme="http://linzhs.cm/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CentOS-7个人静态博客Hexo搭建（适合新手）</title>
    <link href="http://linzhs.cm/2017/03/11/HowToBuildHexoBlog/"/>
    <id>http://linzhs.cm/2017/03/11/HowToBuildHexoBlog/</id>
    <published>2017-03-10T19:03:42.989Z</published>
    <updated>2017-03-10T19:03:42.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS-7个人静态博客Hexo搭建（适合新手）"><a href="#CentOS-7个人静态博客Hexo搭建（适合新手）" class="headerlink" title="CentOS-7个人静态博客Hexo搭建（适合新手）"></a>CentOS-7个人静态博客Hexo搭建（适合新手）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近，借助网上强大的博客资源，自己在个人服务器上搭建了hexo静态博客。在整个搭建的过程中间学到了很多，虽然过程并不是一帆风顺。现写下自己的经验，来与大家分享，希望能够起到作用。</p>
<h2 id="个人服务器和域名准备"><a href="#个人服务器和域名准备" class="headerlink" title="个人服务器和域名准备"></a>个人服务器和域名准备</h2><p>（本文操作基于个人服务器和GitHub）这里的个人服务器是指虚拟服务器（VPS），一般需要购买。现在国内比较有名的VPS供应商是<a href="https://www.aliyun.com/" target="_blank" rel="external">阿里云</a>和<a href="https://www.qcloud.com/" target="_blank" rel="external">腾讯云</a>。国外的服务器可以考虑AWS，现在支持12月免费体验，当然也可以选择搬瓦</p>
<p>工这些便宜实用的，国外的服务器还可以在上面部署ShadowSocks/SSR实现科学上网。<br>只有服务器没有域名和相应的解析操作，那在浏览器上访问博客服务器只能用IP，那是何等的尴尬。可以在国内或者国外的域名申请服务商购买，本人无实际购买经验，在这里就先不推荐了。DNS解析可以用DNSPOD，还不错。</p>
<p>本博主为学生，所以干脆利落地选择了腾讯的学生云，1月1元起飞，域名1年1元起飞。</p>
<h2 id="个人博客开源平台对比"><a href="#个人博客开源平台对比" class="headerlink" title="个人博客开源平台对比"></a>个人博客开源平台对比</h2><ul>
<li>WordPress: 动态博客基于php、MySQL，必须有VPS支持，功能很强大，可通过浏览器访问数据库进行博客后台管理，但平台的插件安装和博客迁移比较麻烦。</li>
<li>Jekyll: 静态博客，可托管到GitHub，功能比较强大，但是所采用的liquid语法对程序员不太友好。</li>
<li>Octopress: 基于Jekyll的静态网站生成引擎。</li>
<li>Hexo: 基于Node.js的静态博客，比较热门，其免费、方便、速度快、可托管到GitHub。</li>
</ul>
<h2 id="系统服务器配置"><a href="#系统服务器配置" class="headerlink" title="系统服务器配置"></a>系统服务器配置</h2><p>本文搭建的博客基于如何系统服务器配置：</p>
<blockquote>
<p>  系统版本：CentOS-7.2-x64</p>
<p>  USER: root</p>
<p>  Firewall: stop</p>
<p>  SeLinux: stop</p>
</blockquote>
<h2 id="建站所需服务支持"><a href="#建站所需服务支持" class="headerlink" title="建站所需服务支持"></a>建站所需服务支持</h2><blockquote>
<p>  Nginx 网页服务器</p>
<p>  Node.js 环境(JavaScript)</p>
<p>  Hexo博客平台</p>
<p>  Git (非必须)</p>
</blockquote>
<h2 id="依赖服务安装"><a href="#依赖服务安装" class="headerlink" title="依赖服务安装"></a>依赖服务安装</h2><ul>
<li><p>Nginx安装</p>
<pre><code>[root@ ~#] yum -y install nginx
</code></pre></li>
<li><p>Git安装</p>
<pre><code>[root@ ~#] yum install -y git
[root@ ~#] git config --global user.name &quot;linzh&quot;
</code></pre><ul>
<li>Node.js环境搭建</li>
</ul>
<p>可以在<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>官网下载binary package编译安装，这种方式需要安装gcc等编译器。本文使用nvm的方式安装</p>
<p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>的最新版本可以在GitHub上参看，附有安装教程（English version）,当前安装版本为v0.33.1。</p>
<p>下面的安装方法二选一(注意默认的安装路径为当前用户的home目录)</p>
<p>   [root@ ~#] curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh" target="_blank" rel="external">https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh</a> | bash #二选一</p>
<p>   [root@ ~#] wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh" target="_blank" rel="external">https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh</a> | bash #二选一</p>
<p>   [root@ ~#] source ~/.bashrc #使配置信息生效</p>
</li>
</ul>
<p>安装好nvm后查看当前可用的版本，并选取最新的版本安装(当前使用的版本为v6.10.0)</p>
<pre><code>[root@ ~#] nvm ls-remote #查看可用版本
[root@ ~#] nvm install v6.10.0 #安装最新版本
[root@ ~#] nvm alias default v6.10.0 #将v6.10.0设置为默认版本
[root@ ~#] nvm use default
</code></pre><ul>
<li>Hexo平台搭建</li>
</ul>
<p>这里使用npm安装hexo客户端和服务端</p>
<pre><code>[root@ ~#] npm install -g hexo-cli #g -&gt; global
[root@ ~#] npm install -g hexo-server
</code></pre><p>若用npm安装速度很慢的话，可以考虑更换npm镜像为淘宝镜像</p>
<pre><code>[root@ ~#] npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><h2 id="初次体验"><a href="#初次体验" class="headerlink" title="初次体验"></a>初次体验</h2><ul>
<li><p>初始化hexo环境 </p>
<pre><code>[root@ ~#] hexo init hexo_blog  # 在当前目录下建立hexo博客目录   
[root@ ~#] cd hexo_blog     
[root@ ~#] npm install
</code></pre><p>完成后会生成hexo相关文件，其中_config.yml为配置文件，具体配置可参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">hexo官方文档</a>。这里建议设置default_layout为draft，这样默认生成文章在Draft里，确认后再发布到Public。</p>
</li>
<li><p>发布文章</p>
<pre><code>[root@ ~#] hexo new hello_post      #新建文章    
[root@ ~#] vim ~/hexo_blog/source/_drafts/hello_post.md #编辑文章内容     
[root@ hexo_blog#] hexo publish hello_post      #发布文章，hello_post.md会从_drafts目录移动到_post目录        
</code></pre></li>
<li><p>运行服务<br>启动服务器，默认起在4000端口，成功后访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 预览效果</p>
<pre><code>[root@ ~#] hexo server
</code></pre></li>
</ul>
<h2 id="托管部署"><a href="#托管部署" class="headerlink" title="托管部署"></a>托管部署</h2><p>这里我们将博客的文件托管到<a href="https://github.com/" target="_blank" rel="external">GitHub</a>，国内现在可以考虑托管到<a href="https://git.oschina.net/" target="_blank" rel="external">码云</a>上，听名字就很霸气！</p>
<ul>
<li>新建 Repository</li>
</ul>
<p>托管代码需要一个仓库（如何新建仓库，请自行search，此处省略数字），仓库名为hexo_repo（仓库名可以根据自己的爱好取，注意接下来的步骤需要对应此名称）</p>
<ul>
<li>配置hexo部署方式</li>
</ul>
<p>进入服务器的hexo博客主目录，编辑_config.yml文件，修改deploy项。这里的$username需要换成你的GitHub的账户</p>
<pre><code>deploy:
  type: git
  repo: https://github.com/$username/hexo_repo.git
  branch: master
</code></pre><ul>
<li><p>安装hexo一键git推送插件</p>
<pre><code>[root@ hexo_blog#] npm install hexo-deployer-git --save
</code></pre></li>
<li><p>部署</p>
<pre><code>[root@ hexo_blog#] hexo -g  # 也可以使用全称 hexo -generate
[root@ hexo_blog#] hexo -d  # 也可以使用全称 hexo -deploy
</code></pre><p>输入命令后会提示输入GitHub的账号密码，输入完成后即已将代码提交到GitHub上了。</p>
</li>
</ul>
<h2 id="自动化部署发布"><a href="#自动化部署发布" class="headerlink" title="自动化部署发布"></a>自动化部署发布</h2><p>每次发布博文都要经过创建文章，推送GitHub托管代码，hexo生成发布，挺麻烦的，现在来实现一键自动化。<br>自动化的思路：编写一个脚本，该脚本执行的时候生成博客静态文件，通过hexo deploy实现自动提交到GitHub，然后通过本地更新代码，对关联的空分支进行git push操作，触发git的post-receive钩子，从而将静态文件同步到/var/www/hexo目录，而该目录正是Nginx将80端口转发到本地的路径（反向代理）。</p>
<ul>
<li><p>在服务器上建立hexo博客git仓库</p>
<p>  [root@ ~#] git init –bare ~/hexo_bare</p>
</li>
<li><p>创建git hooks</p>
</li>
</ul>
<p>这里使用git的post-receive钩子，当本地绑定仓库执行git push后触发。</p>
<pre><code>[root@ ~#] vim ~/hexo_bare/hooks/post-receive
</code></pre><p>post-receive文件具体内容(注意$USER):</p>
<pre><code>#!/bin/bash

git --work-tree=/var/www/hexo --git-dir=/home/$USER/hexo_bare checkout -f
</code></pre><ul>
<li><p>将空仓库关联到主仓库</p>
<pre><code>[root@ ~#] git clone https://github.com/$username/hexo_repo.git ~/hexo_static 
[root@ ~#] cd ~/hexo_static
[root@ ~#] git remote add live ~/hexo_bare   
</code></pre></li>
<li><p>创建自动化脚本</p>
<p>  [root@ ~#] vim ~/hexo_blog/hexo_git_deploy.sh</p>
</li>
</ul>
<p>脚本内容如下</p>
<pre><code>#!/bin/bash

hexo clean
hexo generate 
hexo deploy

( cd ~/hexo_static ; git pull ; git push live master)
</code></pre><ul>
<li>配置Nginx反向代理</li>
</ul>
<p>修改/var/www/html目录的权限，此目录默认为Nginx的请求映射目录</p>
<pre><code>[root@ ~#] chown -R $USER:$USER /var/www/hexo
[root@ ~#] chmod -R 755 /var/www/hexo
</code></pre><p>编辑Nginx配置文件(当前使用的系统为centos7.2，nginx和系统版本不一，配置文件的位置可能也不一)</p>
<pre><code>[root@ ~#] cp /ect/nginx/nginx.conf /ect/nginx/nginx.conf.bak  #备份
[root@ ~#] vim /ect/nginx/nginx.conf  #编辑
</code></pre><p>找到server块，内容大致如下</p>
<pre><code>server {
    listen       80 default_server;
    listen       [::]:80 default_server;
    server_name  _;
    root         /var/www/hexo;

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf;

    #反向代理重点配置部分
    location / {
            root /var/www/hexo;
            index index.html index.htm;
    }

    error_page 404 /404.html;
        location = /40x.html {
    }

    error_page 500 502 503 504 /50x.html;
        location = /50x.html {
    }
}
</code></pre><p>编辑好Nginx配置文件后重启Nginx服务</p>
<pre><code>[root@ ~#] systemctl restart nginx
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，hexo静态博客的基本搭建已经完成，我们总结一下发布文章或者更新文章的流程</p>
<pre><code>$ hexo new my-post
$ vim ~/hexo_blog/source/_draft/my-post.md
$ hexo publish my-post
$ hexo generate
$ hexo server
$  ~/hexo_blog/hexo_git_deploy.sh
</code></pre><p>新建文章 -&gt; 编辑文章 -&gt; 发布文件 -&gt; 生成静态博客文件 -&gt; 预览 –&gt; 修改 –&gt; 最终发布</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>美化hexo</li>
</ul>
<p>hexo官方和好心网友提供了丰富的网页主题和评论、数据统计、监控等插件，可参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方支持文档</a>.<br>本文借鉴了好心网友的<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="external">indigo</a>,沉浸式设计，还不错。</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>这是博主第一次写博客，好激动，但很多借鉴了网友的博文，如果有侵权问题，麻烦通知删除，谢谢！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.jianshu.com/p/70f3cfae1ef4" target="_blank" rel="external">使用Hexo搭建个人静态博客</a></p>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a></p>
<p><a href="http://blog.csdn.net/lnxfei/article/details/43900271" target="_blank" rel="external">wordpress-jekyll-octopress-hexo四博客引擎比较</a></p>
<p><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">Markdown——入门指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS-7个人静态博客Hexo搭建（适合新手）&quot;&gt;&lt;a href=&quot;#CentOS-7个人静态博客Hexo搭建（适合新手）&quot; class=&quot;headerlink&quot; title=&quot;CentOS-7个人静态博客Hexo搭建（适合新手）&quot;&gt;&lt;/a&gt;CentOS-7
    
    </summary>
    
    
      <category term="hexo" scheme="http://linzhs.cm/tags/hexo/"/>
    
  </entry>
  
</feed>
