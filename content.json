[{"title":"","date":"2017-03-24T11:46:36.099Z","path":"2017/03/24/stack/","text":"taStructure&amp;Algorithm栈 (Stack)1. 栈的概念栈是一种先进后出(First in last off, FILO/LIFO)线性数据结构。很多人叫栈为堆栈，但是堆和栈是不同的数据结构。 2. 栈的实现栈可以用数组和链表来实现。栈的基本操作有入栈、出栈、查看栈顶、判空等。 3. 栈的常见应用栈的应用很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、浏览器中的回退操作、编译器中的函数调用实现、表达式的计算等。相关介绍深度好文推荐。 3.1 线程栈线程栈是操作系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器。 3.2 Object-C和OpenGL中的“绘图上下文”3.3 用户按下键盘过滤无效按键3.4 算术表达式的计算(此文重点)编程中算术表达式计算在此主要介绍栈在编程语言中的一大用处。编程语言中，算术表达式有前缀、中缀、后缀之分，他们都是对算术表达式的编程语言表达、记忆方式。 举例：前缀表达式: - * + 3 4 5 6 中缀表达式: (3 + 4) * 5 - 6 后缀表达式: 3 4 + 5 * 6 - 如上面例子所示，前中后缀表达式各不相同，其中很容易发现，中缀表达式是人在数学中所常用，且习惯的一种。算术表达式中，主要由算术运算符和操作数组成，前中后缀表达式也是由此来区分的，也导致了表示的顺序不一样。 概念：前缀表达式：算术运算符在前，操作数在后，不包含括号; 为纪念波兰数学家、此表达式发明者Jan Lukasiewicz，此表达式也成为&quot;波兰表达式&quot;； 中缀表达式：算术运算符在操作数中间，相比前后缀表达式，多了表示优先级的括号； 后缀表达式：算术运算符在后，操作数在前，正好与前缀相反，所以也成为&quot;逆波兰表达式&quot;。 传统算术表达式的运算规则中缀表达式是人类最容易理解的和分析的表达方式，回忆我们对中缀表达式的运算规则： 1.在有括号的情况下，括号优先级最高，优先计算括号内的内容； 2.在无括号的情况下，按运算符优先级进行先后计算，先乘除，后加减； 3.在相同优先级的情况下，从左到右计算。 各表达式的优缺点 在中缀表达式的计算当中，需要不断遍历找出表达式中的括号和优先级较高的运算符，并且考虑操作出现的先后，这对于人来说是简而易举的，但是对于计算机这种一根筋，只能处理0和1的机器来说，显然太复杂了，就算是实现了，时间复杂度也是很恐怖的，毕竟运算符和操作数不可能总是只有几个，这时候出现的前缀和后缀表达式就很有用处了，也是专门为计算机设计的。 在前缀和后缀表达式中，计算顺序不必随着运算符和括号不断变换，而是从左到右或是从右到左顺序遍历一次，不需要考虑括号对运算的影响，再辅之的数据结构(Stack)，可完美完成计算，大大降低了计算的时间复杂度，也符合计算机的工作方式。前缀和后缀表达式大大提高了计算机计算的性能，但对于人来说是不易理解的，特别是对于没有编程基础的人来说，所以在输入和输出表达式给计算机计算的时候需要进行表达式转换，中缀(输入) -&gt; 前缀/后缀(计算) -&gt; 结果(输出)。 例子1.中缀表达式 -&gt; 后缀表达式 [ 例子：a + b * c - (d + e) ] 人工转换： 1.给中缀表达式的所有运算加上括号 ( (a + (b * c)) - (d + e) ) 2.将运算符放到括号后面 ( (a (b c)*)+ (de)+ )- 3.去除括号 a b c * + d e + - 计算机转换(用栈辅助)： 1.建立运算符栈(大小合适，这里只存储运算符)； 2.从左到右遍历中缀表达式： 如果遇到操作数，则直接输出； 如果遇到运算符，则与栈顶的运算符比较优先级： 若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈； 若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为 空，或者栈顶的运算符的优先级低于当前的运算符)。 如果遇到括号： 若为 &quot;(&quot; ，则直接入栈； 若为 &quot;)&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;(&quot;，才同时把 &quot;()&quot; 删除。 计算机转换模拟 [ 例子：a + b * c - (d + e) ] 输出终端 运算符栈(栈底 -&gt; 栈顶) a | a | + ab | + ab | +* abc | +* abc* | + abc*+ | abc*+ | - abc*+ | -( abc*+ | -(+ abc*+d | -(+ abc*+de | -(+ abc*+de+ | -( abc*+de+ | - abc*+de+- | 2.中缀表达式 -&gt; 前缀表达式 [ 例子：a + b * c - (d + e) ] 人工转换： 1.给中缀表达式的所有运算加上括号 ( (a + (b * c)) - (d + e) ) 2.将运算符放到括a号前面 ( -(+(a *(bc)) +(de) ) 3.去除括号 - + a * b c + d e 计算机转换(用栈辅助): 1.建立运算符栈和输出栈(大小合适)，其中输出栈用于存储输出数据，完成遍历后出栈的元素顺序即为前缀表达式； 2.从右向左遍历中缀表达式: 如果遇到操作数，则直接输出; 如果遇到运算符，则与栈顶的运算符比较优先级： 若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈； 若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为 空，或者栈顶的运算符的优先级低于当前的运算符)。 如果遇到括号： 若为 &quot;)&quot; ，则直接入栈； 若为 &quot;(&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;)&quot;，才同时把 &quot;()&quot; 删除。 计算机转换模拟 [ 例子：a + b * c - (d + e) ] 输出栈(栈底 -&gt; 栈顶) 运算符栈(栈底 -&gt; 栈顶) | ) e | e | )+ ed+ | ed+ | - ed+c | - ed+c | -* ed+cb | - ed+cb* | - ed+cb* | -+ ed+cb*a | -+ ed+cb*a+ | - ed+cb*a+- | 所以，输出的前缀表达式为-+a*bc+de。 3.构建表达式树 下面将表达式和二叉树的知识结合，将后缀表达式转换为二叉树 [ 例子: a b c * + d e + - ] 1.建立栈，大小为操作数个数，这里为5； 2.将操作数从左到右入栈，若遇到操作符，则将前面两个元素弹出，并用当前栈顶指向形成的二叉树的根节点； 3.最终合并二叉树。 演示： 1. a b c 2. a | | / \\ b c 3. + / \\ a * / \\ b c 4. + d e / \\ a * / \\ b c 5. + + / \\ / \\ a * d e / \\ b c 6. - / \\ / \\ / \\ + + / \\ / \\ a * d e / \\ b c Coding时刻 栈的实现 接下来来实现栈，这里使用Java级数组来实现，当然，你也可以应该链表来搭建栈结构及其相关操作。 下面为要实现的操作方法API： Stack123456public class Stack&lt;T&gt; &#123; public Stack(); public void push(T item); public boolean isEmpty(); public int size();&#125; 在写出最终的实现代码之前，我们必须考虑应用数组或者其他形式来实现栈这种数据结构怎么样才能让其功能和性能最优。下面为重点考虑的几点： 支持泛型。原因要使栈所支持的数据类型更加广泛通用，而不是需要String的时候写一遍栈的实现，再需要Integer类型的时候又重新写一遍针对Integer的实现。 支持数组大小自动调节。对于数组来说，没法动态调节大小是一大缺点，随机查找是它的优势，若存入有效的元素过多导致数组容纳不下，或者存入有效元素很少（有可能为空）且数组大小较大，这些情况在实际应用当中都是非常不合理的，所以我们需要实现数组大小的动态调节。这里采用流行的调节方法，在数组容纳不下的时候将大小调节为原先的2倍，若数组的有效元素为数组的大小的1/4时将大小调节为原先的1/2。 避免对象游离现象。Java的垃圾回收策略是回收所有无法被访问的对象的内存。在我们实现的栈当前，每一个pop弹出栈顶元素，栈顶指针向栈底移动一位（栈元素足够），但是实际这个被弹出的元素还存留在数组当前，也就是相应的占用这部分内存，GC无法回收。避免对象游离的办法其实很简单，在每次pop的时候将弹出的元素空间置为空。 支持迭代。支持foreach迭代，可以使代码更加整洁。迭代器接口还需要实现remove方法，这个在实现的时候可以不处理，也可以抛出UnsupportedOperationException异常，在实现next方法时候栈为空，则可不处理或者抛出NoSuchElementException。 解决完以上考虑的问题，即可构建出一个不错的栈结构，具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Iterator;//Java迭代器接口所属包public class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123; private T[] arr; private int len; public Stack() &#123;//默认构造器 arr = (T)new Object[1];//Java中不支持泛型对象数组 这里采用强制类型转换办法 len = 0;//默认元素数量 &#125; public void push(T item) &#123;//入栈 if (arr.len == len) resize(2 * arr.length); arr[len++] = item; &#125; public T pop() &#123;//出栈 T t = arr[--len]; arr[len] = null;//避免对象游离 if (len &gt; 0 &amp;&amp; len == arr.length / 4) resize(arr.length / 2); return t; &#125; public boolean isEmpty() &#123;//检查栈是否为空 return len == 0; &#125; public int size() &#123;//查看栈大小 return len; &#125; private void resize(int max) &#123;//重新分配数组大小 T[] t = (T[])new Object[max]; for (int i = 0; i &lt; len; i++) &#123; t[i] = arr[i]; &#125; arr = t; &#125; public Iterator&lt;T&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;T&gt; &#123;//内部类，实现迭代器接口 //支持先进后出迭代 private int i = len; public boolean hasNext() &#123; return i &gt; 0; &#125; public T next() &#123; return arr[--i]; &#125; public void remove &#123; &#125; &#125;&#125; Dijkstra算法 - 双栈算法表达式求值 使用两个栈来实现中缀表达式的求值，这里考虑的是理想情况，将所有运算都加上括号，输入为字符串的形式，实现加减乘除开方操作。基本的思路： 将操作数压入操作数栈 将操作符压入操作符栈 忽略左括号 遇到右括号时，弹出一个运算符，弹出运算所需的操作数，并将运算完的结果压入操作数栈 具体代码实现：123456789101112131415161718192021222324252627282930public class DijkstraTwoStack &#123; private Stack&lt;Character&gt; ops = new Stack&lt;&gt;(); private Stack&lt;Double&gt; vals = new Stack&lt;&gt;(); public DijkstraTwoStack &#123; &#125; public static int cal(String expr) &#123; if (expr == null || expr.length &lt;= 1) return 0; for (char c : expr) &#123; if (c.equals(&apos;(&apos;)) ; else if (c.equals(&apos;+&apos;) || c.equals(&apos;-&apos;) || c.equals(&apos;*&apos;) || c.equals(&apos;/&apos;) || c.equals(&apos;s&apos;))//用s表示开方 ops.push(c); else if (c.equals(&apos;)&apos;)) &#123; char op = ops.pop(); double v = vals.pop(); if (op.equals(&apos;+&apos;)) v = vals.pop() + v; else if (op.equals(&apos;-&apos;)) v = vals.pop() - v; else if (op.equals(&apos;*&apos;)) v = vals.pop() * v; else if (op.equals(&apos;/&apos;)) v = vals.pop() / v; else if (op.equals(&apos;s&apos;)) v = Math.sqrt(v); vals.push(v); &#125; else &#123; vals.push(Double.parseDouble(c));//操作数字符转换为double类型入栈 &#125; &#125; &#125;&#125; 总结本文以栈为中心，主要介绍了栈的应用及算术表达式在编程语言中的表达形式。栈在大数据结构中用处很广，在其他数据结构中也能作为很好的辅助，比如迭代版的二叉树遍历、深度优先搜索和广度优先搜索等等。学好栈和队列的时候是算法设计的一大基础，务必要扎实学好。","tags":[]},{"title":"Java中方法(函数)参数的传递","date":"2017-03-22T12:05:45.114Z","path":"2017/03/22/JavaFuncParamCall/","text":"Java中方法(函数)参数的传递概述在程序设计语言中，按值调用（call by value）表示方法接收的是调用者提供的值，而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址（指针）。一个方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。 在Java程序设计语言中，总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 例子 例子1用一个方法试图将一个参数值增加到3倍 public static void tripleValue(int x) { // 无法实现 x = x * 3; } public static void main(String[] args) { int intValue = 1; tripleValue(intValue); System.out.println(intValue); // doubleValue = 1 } 说明：在main方法中，我们定义一个变量intValue，其值为1，再调用tripleValue方法，将x传入，完成函数调用后在console上打印x的值，结果还是为原来的值，并未改变。tripleValue方法被调用整个过程运行的步骤如下： 1. x被初始化，且其值为调用者传递参数doubleValue的一个拷贝，即 x = 10 2. 运算x = x * 3 ,即 x * 3 = 30 ，30赋值给x，x = 30 ，x为intValue的一个拷贝，x变了，但是intValue却未曾改变 3. 方法运行结束，释放x 例子2用一个方法实现将一个员工的工资提高2倍 public static void tripleSalary(Employee e) { // 可以实现 e.raiseSalary(200); //e的salary提高200% } public static void main(String... args) { Employee harry = new Employee(...); tripleSalary(harry); System.out.println(harry.salary); } 说明：在main方法中，我们实例化一个Employee对象harry，再调用tripleSalary方法来提高员工的工资，将harry传入，完成函数调用后在console上打印harry的工资，结果工资真的提高的两倍。tripleSalary方法被调用整个过程运行的步骤如下： 1. e被初始化，并且为harry的值的拷贝，这里是一个对象的引用 2. e和harry同时引用一个Employee对象，所以e提高了工资相当于提高了harry的工资 3. 方法运行结束，释放e 例子3很多程序员认为Java中对对象采用的是引用传递，实际上，这样理解是错误的。由于这种误解具有一定的普遍性，所以下面采用一个反例方法来说明，该方法是交换两个员工的对象 public static void swap(Employee x, Employee y) { //无法实现 Employee e = x; x = y; y = e; } public static void main(String[] args) { Employee a = new Employee(&quot;Alice&quot;, ...); Employee b = new Employee(&quot;Bob&quot;, ...); swap(a, b); } 说明：在main方法中，实例化了两个员工对象，分别是Alice和Bob，然后传递给swap方法。x和y拷贝了a和b，也就是引用了a和b对象，在swap方法内部将x和y进行交换，确实是可以的，交换完成后x引用Bob，y引用Alice，但是，重点是，a还是引用Alice，b还是引用Bob，并没有改变。最后，swap方法结束，x和y也别GC回收。所以，Java中对对象的传递是值传递而不是引用调用，此操作也就是白费了力气。 总结我们首先说明、强调了Java中方法的参数传递不同于其他语言，总是对值的传递而不是引用调用，再用三个例子来说明，下面用3点来总结一下Java中方法参数的使用： 一个方法不能修改一个基本数据类型的参数（即数值型或者布尔型） 一个方法可以修改一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 参考文章 Java核心技术 卷I 基础知识","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"数据结构与算法理论学习 -- 队列","date":"2017-03-21T02:58:10.000Z","path":"2017/03/21/queue/","text":"队列(Queue)基本概念队列(Queue)是一种先进先出(FIFO)的数据结构，编程中可通过使用数组或者链表来实现。 基本操作Enqueue 入队，向队列尾部添加一个元素Dequeue 出队，在队列头部移除一个元素isEmpty 检查队列是否为空size 查看队列大小 常见应用普通队列在现实计算机当中应用非常广泛，比如播放器的播放列表，数据流对象，异步数据传输结构(文件IO，管道通信，套接字等)，多线程中的阻塞队列，打印机队列，消息队列等等。 队列的常见衍生版本1.循环队列在普通队列的基础上，将队列的头部和尾部相连接，就构成了循环队列这种数据结构。循环队列可以充分利用结构的空间，克服队列的“假溢出”这种现象。循环队列可以通过数据和链表来实现。 循环队列的一些基本的判断条件和性质： 初始化条件为：队头指针是front，队尾是rear，队列的最大长度为QueueSize 1.队列为空 rear == front 2.队列满 (rear + 1) % QueueSize == front 3.队列的长度 n = (rear - front + 1) % QueueSize 4.入队后rear指向 (rear + 1) % QueueSize 5.出队后front指向 (front + 1) % QueueSize 2.双端队列双端队列是一种同时具有队列和栈的性质的一种数据结构，在队列的两头都可以进行插入和删除的操作，同时也可以对双端队列做一些限制。 输入受限的双端队列是指只能从队列一端输入，但可以从两端输出的双端队列； 输出受限的双端队列是指只能从队列一端输出，但可以从两端输入的双端队列； 如果双端队列允许从一端输入，从一端输出，则是普通的队列，如果双端队列只允许从一端输入和输出则是栈， 因此说双端队列同时具有队列和栈两种数据结构的性质。 3.优先队列(堆, Heap)堆也是队列，但强调的是“优先”二字，每个在队列中取出的元素都具备最高优先权，若是最大堆，则每次取出必定是当前堆中最大的元素，同理，若是最小堆而取出元素为最小。堆有着广泛的应用，比如抢占式优先级的系统等。堆还有着各种衍生结构，这里就不在详细说明，有关堆的知识，将专门开一篇文章来了解。 总结本文所述的队列知识比较简单，队列在数据结构中确实算是比较简单的，但是应用却是非常广泛。文章很遗憾没有上代码，希望能尽快完成代码并且贴上来。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"CentOS-7个人静态博客Hexo搭建（适合新手）","date":"2017-03-10T19:03:42.989Z","path":"2017/03/11/HowToBuildHexoBlog/","text":"CentOS-7个人静态博客Hexo搭建（适合新手）前言最近，借助网上强大的博客资源，自己在个人服务器上搭建了hexo静态博客。在整个搭建的过程中间学到了很多，虽然过程并不是一帆风顺。现写下自己的经验，来与大家分享，希望能够起到作用。 个人服务器和域名准备（本文操作基于个人服务器和GitHub）这里的个人服务器是指虚拟服务器（VPS），一般需要购买。现在国内比较有名的VPS供应商是阿里云和腾讯云。国外的服务器可以考虑AWS，现在支持12月免费体验，当然也可以选择搬瓦 工这些便宜实用的，国外的服务器还可以在上面部署ShadowSocks/SSR实现科学上网。只有服务器没有域名和相应的解析操作，那在浏览器上访问博客服务器只能用IP，那是何等的尴尬。可以在国内或者国外的域名申请服务商购买，本人无实际购买经验，在这里就先不推荐了。DNS解析可以用DNSPOD，还不错。 本博主为学生，所以干脆利落地选择了腾讯的学生云，1月1元起飞，域名1年1元起飞。 个人博客开源平台对比 WordPress: 动态博客基于php、MySQL，必须有VPS支持，功能很强大，可通过浏览器访问数据库进行博客后台管理，但平台的插件安装和博客迁移比较麻烦。 Jekyll: 静态博客，可托管到GitHub，功能比较强大，但是所采用的liquid语法对程序员不太友好。 Octopress: 基于Jekyll的静态网站生成引擎。 Hexo: 基于Node.js的静态博客，比较热门，其免费、方便、速度快、可托管到GitHub。 系统服务器配置本文搭建的博客基于如何系统服务器配置： 系统版本：CentOS-7.2-x64 USER: root Firewall: stop SeLinux: stop 建站所需服务支持 Nginx 网页服务器 Node.js 环境(JavaScript) Hexo博客平台 Git (非必须) 依赖服务安装 Nginx安装 [root@ ~#] yum -y install nginx Git安装 [root@ ~#] yum install -y git [root@ ~#] git config --global user.name &quot;linzh&quot; Node.js环境搭建 可以在Node.js官网下载binary package编译安装，这种方式需要安装gcc等编译器。本文使用nvm的方式安装 nvm的最新版本可以在GitHub上参看，附有安装教程（English version）,当前安装版本为v0.33.1。 下面的安装方法二选一(注意默认的安装路径为当前用户的home目录) [root@ ~#] curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash #二选一 [root@ ~#] wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash #二选一 [root@ ~#] source ~/.bashrc #使配置信息生效 安装好nvm后查看当前可用的版本，并选取最新的版本安装(当前使用的版本为v6.10.0) [root@ ~#] nvm ls-remote #查看可用版本 [root@ ~#] nvm install v6.10.0 #安装最新版本 [root@ ~#] nvm alias default v6.10.0 #将v6.10.0设置为默认版本 [root@ ~#] nvm use default Hexo平台搭建 这里使用npm安装hexo客户端和服务端 [root@ ~#] npm install -g hexo-cli #g -&gt; global [root@ ~#] npm install -g hexo-server 若用npm安装速度很慢的话，可以考虑更换npm镜像为淘宝镜像 [root@ ~#] npm install -g cnpm --registry=https://registry.npm.taobao.org 初次体验 初始化hexo环境 [root@ ~#] hexo init hexo_blog # 在当前目录下建立hexo博客目录 [root@ ~#] cd hexo_blog [root@ ~#] npm install 完成后会生成hexo相关文件，其中_config.yml为配置文件，具体配置可参考hexo官方文档。这里建议设置default_layout为draft，这样默认生成文章在Draft里，确认后再发布到Public。 发布文章 [root@ ~#] hexo new hello_post #新建文章 [root@ ~#] vim ~/hexo_blog/source/_drafts/hello_post.md #编辑文章内容 [root@ hexo_blog#] hexo publish hello_post #发布文章，hello_post.md会从_drafts目录移动到_post目录 运行服务启动服务器，默认起在4000端口，成功后访问http://localhost:4000 预览效果 [root@ ~#] hexo server 托管部署这里我们将博客的文件托管到GitHub，国内现在可以考虑托管到码云上，听名字就很霸气！ 新建 Repository 托管代码需要一个仓库（如何新建仓库，请自行search，此处省略数字），仓库名为hexo_repo（仓库名可以根据自己的爱好取，注意接下来的步骤需要对应此名称） 配置hexo部署方式 进入服务器的hexo博客主目录，编辑_config.yml文件，修改deploy项。这里的$username需要换成你的GitHub的账户 deploy: type: git repo: https://github.com/$username/hexo_repo.git branch: master 安装hexo一键git推送插件 [root@ hexo_blog#] npm install hexo-deployer-git --save 部署 [root@ hexo_blog#] hexo -g # 也可以使用全称 hexo -generate [root@ hexo_blog#] hexo -d # 也可以使用全称 hexo -deploy 输入命令后会提示输入GitHub的账号密码，输入完成后即已将代码提交到GitHub上了。 自动化部署发布每次发布博文都要经过创建文章，推送GitHub托管代码，hexo生成发布，挺麻烦的，现在来实现一键自动化。自动化的思路：编写一个脚本，该脚本执行的时候生成博客静态文件，通过hexo deploy实现自动提交到GitHub，然后通过本地更新代码，对关联的空分支进行git push操作，触发git的post-receive钩子，从而将静态文件同步到/var/www/hexo目录，而该目录正是Nginx将80端口转发到本地的路径（反向代理）。 在服务器上建立hexo博客git仓库 [root@ ~#] git init –bare ~/hexo_bare 创建git hooks 这里使用git的post-receive钩子，当本地绑定仓库执行git push后触发。 [root@ ~#] vim ~/hexo_bare/hooks/post-receive post-receive文件具体内容(注意$USER): #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/home/$USER/hexo_bare checkout -f 将空仓库关联到主仓库 [root@ ~#] git clone https://github.com/$username/hexo_repo.git ~/hexo_static [root@ ~#] cd ~/hexo_static [root@ ~#] git remote add live ~/hexo_bare 创建自动化脚本 [root@ ~#] vim ~/hexo_blog/hexo_git_deploy.sh 脚本内容如下 #!/bin/bash hexo clean hexo generate hexo deploy ( cd ~/hexo_static ; git pull ; git push live master) 配置Nginx反向代理 修改/var/www/html目录的权限，此目录默认为Nginx的请求映射目录 [root@ ~#] chown -R $USER:$USER /var/www/hexo [root@ ~#] chmod -R 755 /var/www/hexo 编辑Nginx配置文件(当前使用的系统为centos7.2，nginx和系统版本不一，配置文件的位置可能也不一) [root@ ~#] cp /ect/nginx/nginx.conf /ect/nginx/nginx.conf.bak #备份 [root@ ~#] vim /ect/nginx/nginx.conf #编辑 找到server块，内容大致如下 server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/www/hexo; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; #反向代理重点配置部分 location / { root /var/www/hexo; index index.html index.htm; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 编辑好Nginx配置文件后重启Nginx服务 [root@ ~#] systemctl restart nginx 总结到此，hexo静态博客的基本搭建已经完成，我们总结一下发布文章或者更新文章的流程 $ hexo new my-post $ vim ~/hexo_blog/source/_draft/my-post.md $ hexo publish my-post $ hexo generate $ hexo server $ ~/hexo_blog/hexo_git_deploy.sh 新建文章 -&gt; 编辑文章 -&gt; 发布文件 -&gt; 生成静态博客文件 -&gt; 预览 –&gt; 修改 –&gt; 最终发布 其他 美化hexo hexo官方和好心网友提供了丰富的网页主题和评论、数据统计、监控等插件，可参考hexo官方支持文档.本文借鉴了好心网友的indigo,沉浸式设计，还不错。 重点这是博主第一次写博客，好激动，但很多借鉴了网友的博文，如果有侵权问题，麻烦通知删除，谢谢！ 参考文章使用Hexo搭建个人静态博客 hexo官方文档 wordpress-jekyll-octopress-hexo四博客引擎比较 Markdown——入门指南","tags":[{"name":"hexo","slug":"hexo","permalink":"http://linzhs.cm/tags/hexo/"}]}]