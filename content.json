[{"title":"Java随笔 - 对象克隆","date":"2017-04-17T16:48:32.000Z","path":"2017/04/18/java-note-object-copy/","text":"Java随笔 - 对象克隆 本文总结Java对象的浅复制和深复制，以及Clonable接口。 前言对象在传递的时候，会进行对象复制。对象的复制，可以分为浅复制和深复制。 浅复制在下面的例子中，可以实现对象的复制，origin和copy对象变量引用同一个内存区域，copy调用raiseSalary方法可以修改origin对象所引用的内容。12345678910111213141516171819public class Employee &#123; private double salary; &#123; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125;&#125;Employee origin = new Employee();Employee copy = origin;copy.raiseSalary(10); 在这次的复制过程中，实现的细节是：Object这个Java的万类祖先有个protect的clone方法，可以在相同类的对象上做拷贝。 但是，在整个复制的过程中，复制是有限制的，也就是不完全的，所以我们称之为浅复制，浅克隆，浅拷贝。Object这个超类在实现clone这个方法的时候，并不知道子孙类到底是什么，所以在复制的时候也就有了局限性，若需要复制的内容是数值或者其他基本类型，那没什么问题，直接复制即可；若是复制的内容是另一对象的引用呢？那clone复制的新内存区域仍然和原对象共享着一些信息。 浅复制有什么影响吗？我们来举两个例子。 例子112345678910111213141516171819202122public class Employee &#123; private String name; private double salary; &#123; name = &quot;&quot;; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125; ...&#125;Employee origin = new Employee();Employee copy = origin; 在例子1中，我们在Employee中新增String类型的name变量，还是像之前的那样进行拷贝操作。拷贝之后，原对象和克隆对象的name指向了同一块区域，String是不可变的，也就是指向了常量池。 对于不可变对象的拷贝，其实是安全的，没什么影响，拷贝与否没什么影响，因为不管拷贝与否，不可变对象都是同一块内存，并不会因为拷贝了就另外分配一块内存。所以对于不可变对象，浅复制是安全的，可以安全的共享信息。 例子21234567891011121314151617181920212223public class Employee &#123; private String name; private double salary; private Date hireDay; &#123; name = &quot;&quot;; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125; ...&#125;Employee origin = new Employee();Employee copy = origin; 在新的例子中，我们新增了可变对象Date，这个时候不完全的拷贝，是有影响的。原本复制的用意是让克隆对象有单独的内存来管理自己的数据，但是由于浅复制导致原对象和克隆对象都指向了同一个可变的对象，那么任一对象进行修改，那就是灾难级别的，所以这时候我们需要深度复制。 深复制通常，在复制对象的时候会考虑下面三个选项： 默认的clone方法是否能满足要求； 是否可以在可变的子对象上调用clone方法来修补默认的clone方法； 是不是不应该使用clone方法 对于第三个选项，其实是默认的，对于前两个选项，类必须： 实现Cloneable接口 重新定义clone方法，并制定为public访问修饰符 在Object类中制定了clone方法为protect，但是在新的Java语法规则中，已经变得宽松了，可以将clone方法重写成public的方法。 要建立深度复制来复制对象中另一个对象，那么就要实行Cloneable接口、重写clone方法，在clone方法里来完成这些复制，如下例子：12345678910111213141516171819202122232425262728public class Employee implements Cloneable &#123; private String name; private double salary; private Date hireDay; &#123; name = &quot;&quot;; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125; public Employee clone() throws CloneNotSupportedException &#123; Employee cloned = (Employee)super.clone(); cloned.hireDay = (Date)hireDay.clone(); &#125; ...&#125;Employee origin = new Employee();Employee copy = origin; 在新的clone实现里，指定了throws CloneNotSupportedException异常，其用意在于要实现Cloneable接口，否则就不支持深度拷贝，从而抛出异常。 在重写clone方法的时候，首先应该要调用超类的clone方法来完成浅复制，然后才去定制自己需要完成的深度复制。 在重写clone方法的时候，我们返回的类型是Employee，而不是原本自带的Object，与super类有别，这个是Java5后的特性，为clone指定正确的返回类型，这就是协变返回类型。 标记为Clone的类，在执行克隆方法的时候是内存二进制克隆，比new一个对象性能更好，但是直接在内存中拷贝，构造方法并不会被执行。","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"Android中的动画和图形绘制","date":"2017-03-25T06:29:28.131Z","path":"2017/03/25/Android中的Animation/","text":"Android中的动画和图形绘制前言Android框架中提供了比较丰富的动画UI和2D、3D图形绘制API，包括底层的OpenGL和封装好的Animation。 动画Android框架提供了两种动画模式，分别是属性动画（property animation）和视图动画（view animation）。Android官方比较推荐属性动画，它比较灵活，也具备更多的功能。除此之外，还可以利用drawable动画，来加载绘制的资源，连续播放每一帧。 属性动画(Property Animation) 在Android 3.0 （即API 11）之后，Android加入了属性动画，功能很强大。属性动画允许你通过修改任意的属性值来控制动画，包括未渲染到屏幕上的。属性动画也是可拓展的，可以让你自定义动画的属性类型。 视图动画(View Animation) 视图动画是比较老的模式了，在Android 3.0之后，集成了3.0之前的补间动画（Tween）和帧动画（Frame），只能用于浏览。视图动画比较简单，也提供了能足够的能力来满足应用程序的需求。 可绘制动画(Drawable Animation) 在Android3.0之后出现了这一概念，其实功能和帧动画一毛一样。 2D和3D图形在Android的框架里，除了提高了丰富的2D图形绘制之外，还内置了3D绘图引擎，可以根据不同的需求来设计自己的应用程序。 Canvas和Drawanles Android提供了一组View，用于提供各种各样的用户界面的一般功能部件。我们可以扩展这些小部件来修改它们的样式和行为。此外，也可以使用包含在各种绘图方式做自定义2D渲染Canvas类或创建Drawable的事情对象，如纹理按钮或帧动画。 硬件加速 Android3.0开始，可以用硬件来加速Canvas API的图形绘制，从而提升其性能。 OpenGL Android中内置了OpenGL的3D图形绘制嵌入式版本，也就是OpenGL ES，可以通过NDK和C/C++相结合开发，其具备平台独立性。对于游戏开发来说，OpenGL是很重要的。 视图动画（View Animation）作为最早出现的动画模式，视图动画集成了Android3.0之前的补间动画和帧动画，由于帧动画和Drawable动画很类似，所以在这一小节只学习Tween动画。 Tween主要用于显示淡入淡出（alpha）、缩放（scale）、旋转（rotate）、移动（translate）等效果，这些操作可以通过XML和Android代码的动画集（Animation Set）来实现。在XML中定义动画集，就像是在XML定义布局一样，简洁，可读性、复用性也强， 下面通过在XML定义动画集的例子来学习Tween动画的旋转、缩放、移动、淡入淡出效果。 File Location: /res/anim/anim_alpla.xml /res/anim/anim_scale.xml /res/anim/rotate_scale.xml /res/anim/translate_scale.xml XML和Java代码实现： anim_alpha.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shareInterpolator=&quot;false&quot; android:fillAfter=&quot;true&quot; android:fillBefore=&quot;true&quot; &gt; &lt;!-- shareInterpolator 分享插值器，这里静止 fillAfter和fillBefore两者同时设置，最终只显示fillAfter的效果 --&gt; &lt;!-- fromAlpha:Float.起始动画时的不透明度，0.0表示透明，1.0表示不透明 toAlpha:Float.结束动画时的不透明度，0.0表示透明，1.0表示不透明 --&gt; &lt;!-- 透明度从1.0变化到0.1，且动画结束后保留最后一帧的效果 --&gt; &lt;alpha android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot;/&gt;&lt;/set&gt; anim_scale.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- fromXScale &amp; fromYScale : float 伸缩起始时坐标 toXScale &amp; toYScale : float 伸缩结束时坐标 pivotX &amp; pivotY : float 当对象伸缩的时候X &amp; Y坐标保持不变 这里未使用 --&gt; &lt;!-- 从(0.1, 0.1)到(1.0, 1.0) --&gt; &lt;scale android:fromXScale=&quot;0.1&quot; android:fromYScale=&quot;0.1&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt;&lt;/set&gt; anim_rotate.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- fromDegrees &amp; toDegrees : float 动画开始和结束时的角度 pivotX &amp; pivotY：float or percentage 用Float（如(x,y)=(5,5)）代表中心为整个布局的左上角(5,5)， 用百分比(如(x,y)=(50%，50%))代表中心为该控件的中心，用百分比(如(x,y)=(50%p，50%p))代表中心为该控件的父控件的中心 --&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot; /&gt;&lt;/set&gt; anim_translate.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- fromXDelta &amp; toXDelta : 位移开始和结束时x的位置。 fromYDelta &amp; toYDelta : 位移开始和结束时y的位置。 --&gt; &lt;!-- 从（0，0）位移到（100，100）--&gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100&quot; android:toYDelta=&quot;100&quot; /&gt;&lt;/set&gt; Animation.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button_alpha_xml: //AnimationUtils.loadAnimation()方法返回Animation对象，所以alphaAnimation为Animation alphaAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha); alphaAnimation.setDuration(1500);//设置动画时间为1.5ms imageView.startAnimation(alphaAnimation);//启动动画 break; case R.id.button_alpha_code: //AlphaAnimation(float fromAlpha,float toAlpha) //fromAlpha:起始动画时的不透明度，0.0表示透明，1.0表示不透明 //toAlpha:结束动画时的不透明度，0.0表示透明，1.0表示不透明 //透明度从0.1——&gt;1.0 alphaAnimation = new AlphaAnimation(0.1f, 1.0f); alphaAnimation.setDuration(1500); imageView.startAnimation(alphaAnimation); break; case R.id.button_scale_xml: scaleAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_scale); scaleAnimation.setDuration(3000); imageView.startAnimation(scaleAnimation); break; case R.id.button_scale__code: //ScaleAnimation(float fromX, float toX, float fromY, float toY) //另外还有pivotXType、pivotYType：伸缩模式， //pivotXValue、pivotYValue伸缩动画相对于x,y 坐标的开始位置 scaleAnimation = new ScaleAnimation(1.0f, 0.1f, 1.0f, 0.1f); scaleAnimation.setDuration(3000); imageView.startAnimation(scaleAnimation); break; case R.id.button_rotate_xml: rotateAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_rorate); rotateAnimation.setDuration(3000); imageView.startAnimation(rotateAnimation); break; case R.id.button_rotate__code: //RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,int pivotYType, float pivotYValue) //pivotXType、pivotYType:中心点类型，主要有Animation.ABSOLUTE、Animation.RELATIVE_TO_PARENT、Animation.RELATIVE_TO_SELF //pivotXValue、pivotYValue:根据pivotType决定旋转效果 rotateAnimation = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnimation.setDuration(3000); rotateAnimation.setFillAfter(true);//设置动画结束时是否停留在最后一帧 imageView.startAnimation(rotateAnimation); break; case R.id.button_translate_xml: translateAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_translate); translateAnimation.setFillAfter(true); translateAnimation.setDuration(3000); imageView.startAnimation(translateAnimation); break; case R.id.button_translate__code: //TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) translateAnimation = new TranslateAnimation(0, 100, 0, 100); translateAnimation.setDuration(3000); translateAnimation.setFillAfter(true); imageView.startAnimation(translateAnimation); break; default: break; &#125; 组合使用 xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot; android:duration=&quot;3000&quot; &gt; &lt;alpha android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot; /&gt; &lt;scale android:fromXScale=&quot;0.1&quot; android:fromYScale=&quot;0.1&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt; &lt;translate android:fillAfter=&quot;true&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100&quot; android:toYDelta=&quot;100&quot; /&gt;&lt;/set&gt; java123456789101112131415161718192021222324public void onClick(View v) &#123; switch (v.getId()) &#123; //Mutiple Animation实现方法一 case R.id.btn_mutiple_anim_one: animationSet = new AnimationSet(true); Animation alphaAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_alpha); Animation scaleAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_scale); Animation rotateAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_rotate); Animation translateAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_translate); animationSet.addAnimation(alphaAnimation); animationSet.addAnimation(scaleAnimation); animationSet.addAnimation(rotateAnimation); animationSet.addAnimation(translateAnimation); imageView.startAnimation(animationSet); break; //Mutiple Animation实现方法二 case R.id.btn_mutiple_anim_two: Animation mutipleAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_mutiple); imageView.startAnimation(mutipleAnimation); break; default: break; &#125; &#125; 帧动画帧动画，包括Frame Animation和Drawable Animation，可以通过连续加载资源实现连续动画，类似于GIF等，就像在放电影。和Tween Animation一样，帧动画也可在XML和Java代码中实现。 下面为简单的例子，预先在res/drawable目录放一些图片，然后在该目录下创建文件连续动画文件：/res/drawable/fruit_animlist.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/apple_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/banana_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/cherry_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/grape_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/mango_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/orange_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/pineapple_pic&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; java code1234567891011121314151617181920212223public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button_anim_list_xml: imageView.setImageResource(R.drawable.fruit_animlist);//设置动画集 AnimationDrawable animationDrawable = (AnimationDrawable)imageView.getDrawable(); animationDrawable.start(); break; case R.id.button_anim_list_code: AnimationDrawable anim = new AnimationDrawable(); for (int i = 1; i &lt; 10; ++i) &#123; int id = getResources().getIdentifier(&quot;fruit_&quot; + i, &quot;drawable&quot;, getPackageName()); Drawable drawable = getResources().getDrawable(id); anim.addFrame(drawable, 200); &#125; anim.setOneShot(false); imageView.setImageDrawable(anim); anim.start(); //anim.stop() anim.isRunning() break; default: break; &#125; &#125; 在较大型的帧动画显示中，会出现卡顿的情况，这是View和OOM的原因，可以使用双缓冲的surfaceView来实现。 属性动画属性动画是Android3.0后引入的，是一个强大的框架，可以让你绘制几乎任何东西。无论有没有显示在屏幕上，属性动画可以随着时间去修改属性的值来控制动画。 属性动画相关类： 类名 用途 ValueAnimation 属性动画主要的计时器，也计算动画后的属性的值，动画的执行类 ObjectAnimator ValueAnimator的一个子类，允许你设置一个目标对象和对象的属性进行动画，动画的执行类 AnimatorSet 提供组织动画的结构，使它们能相关联得运行，用于控制一组动画的执行 AnimatorInflater 用户加载属性动画的xml文件 Evaluators 属性动画计算器，告诉了属性动画系统如何计算给出属性的值 Interpolators 动画插入器，定义动画的变化率 类之间的关系： iamge 接下来用几个例子来学习一下怎么使用属性动画，注意，==xml文件必须放在/res/animator中==。 ObjectAnimation（用属性动画实现视图动画的淡入淡出效果，缩放、移动、旋转等类似） alpha_anim.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:propertyName=&quot;alpha&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:startOffset=&quot;200&quot; android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;1.0&quot; android:valueType=&quot;floatType&quot;&gt; &lt;!-- duration 表示动画执行的时间 propertyName 表示修改的物件的哪个属性值，这里是透明度 valueFrom 表示从哪个状态值开始动画 valueTo 表示到哪个状态值结束动画 valueType 类型估值，主要用于设置动画操作属性的值 repeatCount 动画重复的计数，动画将会执行该值+1次 repeatMode 动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。restart为重新执行，方向不变 startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间，单位毫秒 interpolator 指定动画插入器 --&gt;&lt;/objectAnimator&gt; 对应Java code123456789101112131415161718//ImageView预先设置好图片//xml实现//ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()这几个方法//都是设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值//ofFloat(Object target, String propertyName, float... values)Animator anim = AnimatorInflater.loadAnimator(this, R.animator.property_animation);anim.setTarget(imageView);anim.start();//java codeObjectAnimator alphaAnimation = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0f, 1f);alphaAnimation.setDuration(500);alphaAnimation.setRepeatCount(0);alphaAnimation.setRepeatMode(ValueAnimator.REVERSE);alphaAnimation.setStartDelay(200);alphaAnimation.setInterpolator(new AccelerateDecelerateInterpolator());alphaAnimation.start(); scale_anim.xml12345678&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:propertyName=&quot;scaleX&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;1.5&quot; android:valueType=&quot;floatType&quot; /&gt; java code12345ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f); scaleXAnimator.setDuration(500); scaleXAnimator.setRepeatCount(1); scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE); scaleXAnimator.start(); rotate_anim.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:propertyName=&quot;rotation&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;360&quot; android:valueType=&quot;floatType&quot; /&gt; java code12345ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;rotation&quot;, 0f, 360f); objectAnimator.setDuration(500); objectAnimator.setRepeatCount(1); objectAnimator.setRepeatMode(ValueAnimator.REVERSE); objectAnimator.start(); translate_anim.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:propertyName=&quot;translationX&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;100&quot; android:valueType=&quot;floatType&quot; /&gt; java code12345ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;translationX&quot;, 0f, 100f); objectAnimator.setDuration(500); objectAnimator.setRepeatCount(1); objectAnimator.setRepeatMode(ValueAnimator.REVERSE); objectAnimator.start(); Animation（组合动画） anim_set.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:ordering=&quot;together&quot;&gt; &lt;objectAnimator android:duration=&quot;500&quot; android:propertyName=&quot;scaleX&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;1.5&quot; android:valueType=&quot;floatType&quot; /&gt; &lt;objectAnimator android:duration=&quot;500&quot; android:propertyName=&quot;scaleY&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;1.5&quot; android:valueType=&quot;floatType&quot; /&gt;&lt;/set&gt; java code123456789101112131415161718192021//加载动画Animator anim = AnimatorInflater.loadAnimator(this, R.animator.animator_scale); anim.setTarget(imageView); anim.start(); //纯代码实现AnimatorSet animatorSet = new AnimatorSet(); ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f); scaleXAnimator.setDuration(500); scaleXAnimator.setRepeatCount(1); scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE); scaleXAnimator.start(); ObjectAnimator scaleYAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 1.5f); scaleYAnimator.setDuration(500); scaleYAnimator.setRepeatCount(1); scaleYAnimator.setRepeatMode(ValueAnimator.REVERSE); animatorSet.playTogether(scaleXAnimator, scaleYAnimator); animatorSet.start(); 视图动画和属性动画的区别在视图动画中，止提供了唯一的View动画对象，如果要完成非View对象，那就玩自己去完成这部分带吗。在View视图中，其仅仅提供了一些功能，比如旋转、缩放等，但没有实现背景颜色这些，是有一定的局限性的。 视图动画只是修改了被画的东西，而不是自己本身。 属性动画把这些限制的缺点都去除了，使动画更加健壮，动画更加丰富。 视图动画的实现只需要少量的代码和时间，所以如果是小型的动画，可以用视图动画来完成。Android还保留着view动画，也是有它的用处。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"数据结构与算法理论学习 -- 队列","date":"2017-03-25T06:26:51.208Z","path":"2017/03/25/queue/","text":"队列(Queue)基本概念队列(Queue)是一种先进先出(FIFO)的数据结构，编程中可通过使用数组或者链表来实现。 基本操作enqueue 入队，向队列尾部添加一个元素 dequeue 出队，在队列头部移除一个元素 isEmpty 检查队列是否为空 size 查看队列大小 Coding时刻 使用链表实现队列 12345678910111213141516171819202122232425262728293031323334353637public class Queue&lt;T&gt; &#123; private Node first;//指向队列中最早添加的结点 private Node last;//指向队列中最近添加的结点 private int N; private class Node &#123;//结点类，只在内部使用 T item; Node next; &#125; public boolean isEmpty() &#123; return first == null; //return N == 0; &#125; public int size() &#123; return N; &#125; public void enqueue(T item) &#123; Node oldlast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty() == true) first = last; else oldlast.next = last; N++; &#125; public Item dequeue() &#123; Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; &#125;&#125; 实现两个栈实现队列 123456789101112131415161718192021222324public class Solution&lt;T&gt; &#123; private static Stack&lt;T&gt; stack1 = new Stack&lt;&gt;();//入队 private static Stack&lt;T&gt; stack2 = new Stack&lt;&gt;();//出队 public void enqueue(T element) &#123; stack1.push(element); &#125; public T dequeue() &#123; if (stack2.isEmpty() == true) &#123;//出队，将stack1中的元素弹出，并且在stack2中入栈 while (stack1.isEmpty() == false) &#123; T data = stack1.pop(); stack2.push(data); &#125; &#125; if (stack2.isEmpty() == true) &#123; throw new Exception(&quot;queue is empty.&quot;); &#125; return stack2.pop(); &#125;&#125; 常见应用普通队列在现实计算机当中应用非常广泛，比如播放器的播放列表，数据流对象，异步数据传输结构(文件IO，管道通信，套接字等)，多线程中的阻塞队列，打印机队列，消息队列等等。 队列的常见衍生版本1.循环队列在普通队列的基础上，将队列的头部和尾部相连接，就构成了循环队列这种数据结构。循环队列可以充分利用结构的空间，克服队列的“假溢出”这种现象。循环队列可以通过数据和链表来实现。 循环队列的一些基本的判断条件和性质： 初始化条件为：队头指针是front，队尾是rear，队列的最大长度为QueueSize 1.队列为空 rear == front 2.队列满 (rear + 1) % QueueSize == front 3.队列的长度 n = (rear - front + 1) % QueueSize 4.入队后rear指向 (rear + 1) % QueueSize 5.出队后front指向 (front + 1) % QueueSize 2.双端队列双端队列是一种同时具有队列和栈的性质的一种数据结构，在队列的两头都可以进行插入和删除的操作，同时也可以对双端队列做一些限制。 输入受限的双端队列是指只能从队列一端输入，但可以从两端输出的双端队列； 输出受限的双端队列是指只能从队列一端输出，但可以从两端输入的双端队列； 如果双端队列允许从一端输入，从一端输出，则是普通的队列，如果双端队列只允许从一端输入和输出则是栈， 因此说双端队列同时具有队列和栈两种数据结构的性质。 3.优先队列(堆, Heap)堆也是队列，但强调的是“优先”二字，每个在队列中取出的元素都具备最高优先权，若是最大堆，则每次取出必定是当前堆中最大的元素，同理，若是最小堆而取出元素为最小。堆有着广泛的应用，比如抢占式优先级的系统等。堆还有着各种衍生结构，这里就不在详细说明，有关堆的知识，将专门开一篇文章来了解。 总结本文所述的队列知识比较简单，队列在数据结构中确实算是比较简单的，但是应用却是非常广泛。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"数据结构与算法理论学习 -- 栈","date":"2017-03-25T06:25:40.600Z","path":"2017/03/25/stack/","text":"栈 (Stack)1. 栈的概念栈是一种先进后出(First in last off, FILO/LIFO)线性数据结构。很多人叫栈为堆栈，但是堆和栈是不同的数据结构。 2. 栈的实现栈可以用数组和链表来实现。栈的基本操作有入栈、出栈、查看栈顶、判空等。 3. 栈的常见应用栈的应用很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、浏览器中的回退操作、编译器中的函数调用实现、表达式的计算等。相关介绍深度好文推荐。 3.1 线程栈线程栈是操作系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器。 3.2 Object-C和OpenGL中的“绘图上下文”3.3 用户按下键盘过滤无效按键3.4 算术表达式的计算(此文重点)编程中算术表达式计算在此主要介绍栈在编程语言中的一大用处。编程语言中，算术表达式有前缀、中缀、后缀之分，他们都是对算术表达式的编程语言表达、记忆方式。 举例：前缀表达式: - * + 3 4 5 6 中缀表达式: (3 + 4) * 5 - 6 后缀表达式: 3 4 + 5 * 6 - 如上面例子所示，前中后缀表达式各不相同，其中很容易发现，中缀表达式是人在数学中所常用，且习惯的一种。算术表达式中，主要由算术运算符和操作数组成，前中后缀表达式也是由此来区分的，也导致了表示的顺序不一样。 概念：前缀表达式：算术运算符在前，操作数在后，不包含括号; 为纪念波兰数学家、此表达式发明者Jan Lukasiewicz，此表达式也成为&quot;波兰表达式&quot;； 中缀表达式：算术运算符在操作数中间，相比前后缀表达式，多了表示优先级的括号； 后缀表达式：算术运算符在后，操作数在前，正好与前缀相反，所以也成为&quot;逆波兰表达式&quot;。 传统算术表达式的运算规则中缀表达式是人类最容易理解的和分析的表达方式，回忆我们对中缀表达式的运算规则： 1.在有括号的情况下，括号优先级最高，优先计算括号内的内容； 2.在无括号的情况下，按运算符优先级进行先后计算，先乘除，后加减； 3.在相同优先级的情况下，从左到右计算。 各表达式的优缺点 在中缀表达式的计算当中，需要不断遍历找出表达式中的括号和优先级较高的运算符，并且考虑操作出现的先后，这对于人来说是简而易举的，但是对于计算机这种一根筋，只能处理0和1的机器来说，显然太复杂了，就算是实现了，时间复杂度也是很恐怖的，毕竟运算符和操作数不可能总是只有几个，这时候出现的前缀和后缀表达式就很有用处了，也是专门为计算机设计的。 在前缀和后缀表达式中，计算顺序不必随着运算符和括号不断变换，而是从左到右或是从右到左顺序遍历一次，不需要考虑括号对运算的影响，再辅之的数据结构(Stack)，可完美完成计算，大大降低了计算的时间复杂度，也符合计算机的工作方式。前缀和后缀表达式大大提高了计算机计算的性能，但对于人来说是不易理解的，特别是对于没有编程基础的人来说，所以在输入和输出表达式给计算机计算的时候需要进行表达式转换，中缀(输入) -&gt; 前缀/后缀(计算) -&gt; 结果(输出)。 例子1.中缀表达式 -&gt; 后缀表达式 [ 例子：a + b * c - (d + e) ] 人工转换： 1.给中缀表达式的所有运算加上括号 ( (a + (b * c)) - (d + e) ) 2.将运算符放到括号后面 ( (a (b c)*)+ (de)+ )- 3.去除括号 a b c * + d e + - 计算机转换(用栈辅助)： 1.建立运算符栈(大小合适，这里只存储运算符)； 2.从左到右遍历中缀表达式： 如果遇到操作数，则直接输出； 如果遇到运算符，则与栈顶的运算符比较优先级： 若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈； 若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为 空，或者栈顶的运算符的优先级低于当前的运算符)。 如果遇到括号： 若为 &quot;(&quot; ，则直接入栈； 若为 &quot;)&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;(&quot;，才同时把 &quot;()&quot; 删除。 计算机转换模拟 [ 例子：a + b * c - (d + e) ] 输出终端 运算符栈(栈底 -&gt; 栈顶) a | a | + ab | + ab | +* abc | +* abc* | + abc*+ | abc*+ | - abc*+ | -( abc*+ | -(+ abc*+d | -(+ abc*+de | -(+ abc*+de+ | -( abc*+de+ | - abc*+de+- | 2.中缀表达式 -&gt; 前缀表达式 [ 例子：a + b * c - (d + e) ] 人工转换： 1.给中缀表达式的所有运算加上括号 ( (a + (b * c)) - (d + e) ) 2.将运算符放到括a号前面 ( -(+(a *(bc)) +(de) ) 3.去除括号 - + a * b c + d e 计算机转换(用栈辅助): 1.建立运算符栈和输出栈(大小合适)，其中输出栈用于存储输出数据，完成遍历后出栈的元素顺序即为前缀表达式； 2.从右向左遍历中缀表达式: 如果遇到操作数，则直接输出; 如果遇到运算符，则与栈顶的运算符比较优先级： 若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈； 若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为 空，或者栈顶的运算符的优先级低于当前的运算符)。 如果遇到括号： 若为 &quot;)&quot; ，则直接入栈； 若为 &quot;(&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;)&quot;，才同时把 &quot;()&quot; 删除。 计算机转换模拟 [ 例子：a + b * c - (d + e) ] 输出栈(栈底 -&gt; 栈顶) 运算符栈(栈底 -&gt; 栈顶) | ) e | e | )+ ed+ | ed+ | - ed+c | - ed+c | -* ed+cb | - ed+cb* | - ed+cb* | -+ ed+cb*a | -+ ed+cb*a+ | - ed+cb*a+- | 所以，输出的前缀表达式为-+a*bc+de。 3.构建表达式树 下面将表达式和二叉树的知识结合，将后缀表达式转换为二叉树 [ 例子: a b c * + d e + - ] 1.建立栈，大小为操作数个数，这里为5； 2.将操作数从左到右入栈，若遇到操作符，则将前面两个元素弹出，并用当前栈顶指向形成的二叉树的根节点； 3.最终合并二叉树。 演示： 1. a b c 2. a | | / \\ b c 3. + / \\ a * / \\ b c 4. + d e / \\ a * / \\ b c 5. + + / \\ / \\ a * d e / \\ b c 6. - / \\ / \\ / \\ + + / \\ / \\ a * d e / \\ b c Coding时刻 栈的数组实现 接下来来实现栈，这里先使用Java级数组来实现，下面再使用链表来搭建栈结构及其相关操作。 下面为要实现的操作方法API： Stack123456public class Stack&lt;T&gt; &#123; public Stack(); public void push(T item); public boolean isEmpty(); public int size();&#125; 在写出最终的实现代码之前，我们必须考虑应用数组或者其他形式来实现栈这种数据结构怎么样才能让其功能和性能最优。下面为重点考虑的几点： 支持泛型。原因要使栈所支持的数据类型更加广泛通用，而不是需要String的时候写一遍栈的实现，再需要Integer类型的时候又重新写一遍针对Integer的实现。 支持数组大小自动调节。对于数组来说，没法动态调节大小是一大缺点，随机查找是它的优势，若存入有效的元素过多导致数组容纳不下，或者存入有效元素很少（有可能为空）且数组大小较大，这些情况在实际应用当中都是非常不合理的，所以我们需要实现数组大小的动态调节。这里采用流行的调节方法，在数组容纳不下的时候将大小调节为原先的2倍，若数组的有效元素为数组的大小的1/4时将大小调节为原先的1/2。 避免对象游离现象。Java的垃圾回收策略是回收所有无法被访问的对象的内存。在我们实现的栈当前，每一个pop弹出栈顶元素，栈顶指针向栈底移动一位（栈元素足够），但是实际这个被弹出的元素还存留在数组当前，也就是相应的占用这部分内存，GC无法回收。避免对象游离的办法其实很简单，在每次pop的时候将弹出的元素空间置为空。 支持迭代。支持foreach迭代，可以使代码更加整洁。迭代器接口还需要实现remove方法，这个在实现的时候可以不处理，也可以抛出UnsupportedOperationException异常，在实现next方法时候栈为空，则可不处理或者抛出NoSuchElementException。 解决完以上考虑的问题，即可构建出一个不错的栈结构，具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Iterator;//Java迭代器接口所属包public class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123; private T[] arr; private int len; public Stack() &#123;//默认构造器 arr = (T)new Object[1];//Java中不支持泛型对象数组 这里采用强制类型转换办法 len = 0;//默认元素数量 &#125; public void push(T item) &#123;//入栈 if (arr.len == len) resize(2 * arr.length); arr[len++] = item; &#125; public T pop() &#123;//出栈 T t = arr[--len]; arr[len] = null;//避免对象游离 if (len &gt; 0 &amp;&amp; len == arr.length / 4) resize(arr.length / 2); return t; &#125; public boolean isEmpty() &#123;//检查栈是否为空 return len == 0; &#125; public int size() &#123;//查看栈大小 return len; &#125; private void resize(int max) &#123;//重新分配数组大小 T[] t = (T[])new Object[max]; for (int i = 0; i &lt; len; i++) &#123; t[i] = arr[i]; &#125; arr = t; &#125; public Iterator&lt;T&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;T&gt; &#123;//内部类，实现迭代器接口 //支持先进后出迭代 private int i = len; public boolean hasNext() &#123; return i &gt; 0; &#125; public T next() &#123; return arr[--i]; &#125; public void remove &#123; &#125; &#125;&#125; 栈的链表实现 相比数组来实现栈，链表的优势在于可以很方便的插入删除元素，长度也不会受限，但是它的缺点是随机访问的能力变差了很多，所示访问的结点在末尾，那就等于每次都要遍历一次链表，效率是比较低的。这里在pop出元素的时候，Java程序员无需关心结点成为孤儿后会不会导致内存占用，GC会帮你完成收尾工作。12345678910111213141516171819202122232425262728293031323334353637public class Stack&lt;T&gt; &#123; private Node first; private int N; private class Node &#123; public T item; public Node next; &#125; public Stack() &#123; &#125; public boolean isEmpty() &#123; return first == null; &#125; public int size() &#123; return N; &#125; public void push(T item) &#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; public Item pop() &#123; T item = first.item; first = first.next; N--; return item; &#125;&#125; Dijkstra算法 - 双栈算法表达式求值 使用两个栈来实现中缀表达式的求值，这里考虑的是理想情况，将所有运算都加上括号，输入为字符串的形式，实现加减乘除开方操作。基本的思路： 将操作数压入操作数栈 将操作符压入操作符栈 忽略左括号 遇到右括号时，弹出一个运算符，弹出运算所需的操作数，并将运算完的结果压入操作数栈 具体代码实现：123456789101112131415161718192021222324252627282930public class DijkstraTwoStack &#123; private Stack&lt;Character&gt; ops = new Stack&lt;&gt;(); private Stack&lt;Double&gt; vals = new Stack&lt;&gt;(); public DijkstraTwoStack &#123; &#125; public static int cal(String expr) &#123; if (expr == null || expr.length &lt;= 1) return 0; for (char c : expr) &#123; if (c.equals(&apos;(&apos;)) ; else if (c.equals(&apos;+&apos;) || c.equals(&apos;-&apos;) || c.equals(&apos;*&apos;) || c.equals(&apos;/&apos;) || c.equals(&apos;s&apos;))//用s表示开方 ops.push(c); else if (c.equals(&apos;)&apos;)) &#123; char op = ops.pop(); double v = vals.pop(); if (op.equals(&apos;+&apos;)) v = vals.pop() + v; else if (op.equals(&apos;-&apos;)) v = vals.pop() - v; else if (op.equals(&apos;*&apos;)) v = vals.pop() * v; else if (op.equals(&apos;/&apos;)) v = vals.pop() / v; else if (op.equals(&apos;s&apos;)) v = Math.sqrt(v); vals.push(v); &#125; else &#123; vals.push(Double.parseDouble(c));//操作数字符转换为double类型入栈 &#125; &#125; &#125;&#125; 总结本文以栈为中心，主要介绍了栈的应用及算术表达式在编程语言中的表达形式。栈在大数据结构中用处很广，在其他数据结构中也能作为很好的辅助，比如迭代版的二叉树遍历、深度优先搜索和广度优先搜索等等。学好栈和队列的时候是算法设计的一大基础，务必要扎实学好。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"Java中方法(函数)参数的传递","date":"2017-03-22T12:05:45.114Z","path":"2017/03/22/JavaFuncParamCall/","text":"Java中方法(函数)参数的传递概述在程序设计语言中，按值调用（call by value）表示方法接收的是调用者提供的值，而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址（指针）。一个方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。 在Java程序设计语言中，总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 例子 例子1用一个方法试图将一个参数值增加到3倍 public static void tripleValue(int x) { // 无法实现 x = x * 3; } public static void main(String[] args) { int intValue = 1; tripleValue(intValue); System.out.println(intValue); // doubleValue = 1 } 说明：在main方法中，我们定义一个变量intValue，其值为1，再调用tripleValue方法，将x传入，完成函数调用后在console上打印x的值，结果还是为原来的值，并未改变。tripleValue方法被调用整个过程运行的步骤如下： 1. x被初始化，且其值为调用者传递参数doubleValue的一个拷贝，即 x = 10 2. 运算x = x * 3 ,即 x * 3 = 30 ，30赋值给x，x = 30 ，x为intValue的一个拷贝，x变了，但是intValue却未曾改变 3. 方法运行结束，释放x 例子2用一个方法实现将一个员工的工资提高2倍 public static void tripleSalary(Employee e) { // 可以实现 e.raiseSalary(200); //e的salary提高200% } public static void main(String... args) { Employee harry = new Employee(...); tripleSalary(harry); System.out.println(harry.salary); } 说明：在main方法中，我们实例化一个Employee对象harry，再调用tripleSalary方法来提高员工的工资，将harry传入，完成函数调用后在console上打印harry的工资，结果工资真的提高的两倍。tripleSalary方法被调用整个过程运行的步骤如下： 1. e被初始化，并且为harry的值的拷贝，这里是一个对象的引用 2. e和harry同时引用一个Employee对象，所以e提高了工资相当于提高了harry的工资 3. 方法运行结束，释放e 例子3很多程序员认为Java中对对象采用的是引用传递，实际上，这样理解是错误的。由于这种误解具有一定的普遍性，所以下面采用一个反例方法来说明，该方法是交换两个员工的对象 public static void swap(Employee x, Employee y) { //无法实现 Employee e = x; x = y; y = e; } public static void main(String[] args) { Employee a = new Employee(&quot;Alice&quot;, ...); Employee b = new Employee(&quot;Bob&quot;, ...); swap(a, b); } 说明：在main方法中，实例化了两个员工对象，分别是Alice和Bob，然后传递给swap方法。x和y拷贝了a和b，也就是引用了a和b对象，在swap方法内部将x和y进行交换，确实是可以的，交换完成后x引用Bob，y引用Alice，但是，重点是，a还是引用Alice，b还是引用Bob，并没有改变。最后，swap方法结束，x和y也别GC回收。所以，Java中对对象的传递是值传递而不是引用调用，此操作也就是白费了力气。 总结我们首先说明、强调了Java中方法的参数传递不同于其他语言，总是对值的传递而不是引用调用，再用三个例子来说明，下面用3点来总结一下Java中方法参数的使用： 一个方法不能修改一个基本数据类型的参数（即数值型或者布尔型） 一个方法可以修改一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 参考文章 Java核心技术 卷I 基础知识","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"CentOS-7个人静态博客Hexo搭建（适合新手）","date":"2017-03-10T19:03:42.989Z","path":"2017/03/11/HowToBuildHexoBlog/","text":"CentOS-7个人静态博客Hexo搭建（适合新手）前言最近，借助网上强大的博客资源，自己在个人服务器上搭建了hexo静态博客。在整个搭建的过程中间学到了很多，虽然过程并不是一帆风顺。现写下自己的经验，来与大家分享，希望能够起到作用。 个人服务器和域名准备（本文操作基于个人服务器和GitHub）这里的个人服务器是指虚拟服务器（VPS），一般需要购买。现在国内比较有名的VPS供应商是阿里云和腾讯云。国外的服务器可以考虑AWS，现在支持12月免费体验，当然也可以选择搬瓦 工这些便宜实用的，国外的服务器还可以在上面部署ShadowSocks/SSR实现科学上网。只有服务器没有域名和相应的解析操作，那在浏览器上访问博客服务器只能用IP，那是何等的尴尬。可以在国内或者国外的域名申请服务商购买，本人无实际购买经验，在这里就先不推荐了。DNS解析可以用DNSPOD，还不错。 本博主为学生，所以干脆利落地选择了腾讯的学生云，1月1元起飞，域名1年1元起飞。 个人博客开源平台对比 WordPress: 动态博客基于php、MySQL，必须有VPS支持，功能很强大，可通过浏览器访问数据库进行博客后台管理，但平台的插件安装和博客迁移比较麻烦。 Jekyll: 静态博客，可托管到GitHub，功能比较强大，但是所采用的liquid语法对程序员不太友好。 Octopress: 基于Jekyll的静态网站生成引擎。 Hexo: 基于Node.js的静态博客，比较热门，其免费、方便、速度快、可托管到GitHub。 系统服务器配置本文搭建的博客基于如何系统服务器配置： 系统版本：CentOS-7.2-x64 USER: root Firewall: stop SeLinux: stop 建站所需服务支持 Nginx 网页服务器 Node.js 环境(JavaScript) Hexo博客平台 Git (非必须) 依赖服务安装 Nginx安装 [root@ ~#] yum -y install nginx Git安装 [root@ ~#] yum install -y git [root@ ~#] git config --global user.name &quot;linzh&quot; Node.js环境搭建 可以在Node.js官网下载binary package编译安装，这种方式需要安装gcc等编译器。本文使用nvm的方式安装 nvm的最新版本可以在GitHub上参看，附有安装教程（English version）,当前安装版本为v0.33.1。 下面的安装方法二选一(注意默认的安装路径为当前用户的home目录) [root@ ~#] curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash #二选一 [root@ ~#] wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash #二选一 [root@ ~#] source ~/.bashrc #使配置信息生效 安装好nvm后查看当前可用的版本，并选取最新的版本安装(当前使用的版本为v6.10.0) [root@ ~#] nvm ls-remote #查看可用版本 [root@ ~#] nvm install v6.10.0 #安装最新版本 [root@ ~#] nvm alias default v6.10.0 #将v6.10.0设置为默认版本 [root@ ~#] nvm use default Hexo平台搭建 这里使用npm安装hexo客户端和服务端 [root@ ~#] npm install -g hexo-cli #g -&gt; global [root@ ~#] npm install -g hexo-server 若用npm安装速度很慢的话，可以考虑更换npm镜像为淘宝镜像 [root@ ~#] npm install -g cnpm --registry=https://registry.npm.taobao.org 初次体验 初始化hexo环境 [root@ ~#] hexo init hexo_blog # 在当前目录下建立hexo博客目录 [root@ ~#] cd hexo_blog [root@ ~#] npm install 完成后会生成hexo相关文件，其中_config.yml为配置文件，具体配置可参考hexo官方文档。这里建议设置default_layout为draft，这样默认生成文章在Draft里，确认后再发布到Public。 发布文章 [root@ ~#] hexo new hello_post #新建文章 [root@ ~#] vim ~/hexo_blog/source/_drafts/hello_post.md #编辑文章内容 [root@ hexo_blog#] hexo publish hello_post #发布文章，hello_post.md会从_drafts目录移动到_post目录 运行服务启动服务器，默认起在4000端口，成功后访问http://localhost:4000 预览效果 [root@ ~#] hexo server 托管部署这里我们将博客的文件托管到GitHub，国内现在可以考虑托管到码云上，听名字就很霸气！ 新建 Repository 托管代码需要一个仓库（如何新建仓库，请自行search，此处省略数字），仓库名为hexo_repo（仓库名可以根据自己的爱好取，注意接下来的步骤需要对应此名称） 配置hexo部署方式 进入服务器的hexo博客主目录，编辑_config.yml文件，修改deploy项。这里的$username需要换成你的GitHub的账户 deploy: type: git repo: https://github.com/$username/hexo_repo.git branch: master 安装hexo一键git推送插件 [root@ hexo_blog#] npm install hexo-deployer-git --save 部署 [root@ hexo_blog#] hexo -g # 也可以使用全称 hexo -generate [root@ hexo_blog#] hexo -d # 也可以使用全称 hexo -deploy 输入命令后会提示输入GitHub的账号密码，输入完成后即已将代码提交到GitHub上了。 自动化部署发布每次发布博文都要经过创建文章，推送GitHub托管代码，hexo生成发布，挺麻烦的，现在来实现一键自动化。自动化的思路：编写一个脚本，该脚本执行的时候生成博客静态文件，通过hexo deploy实现自动提交到GitHub，然后通过本地更新代码，对关联的空分支进行git push操作，触发git的post-receive钩子，从而将静态文件同步到/var/www/hexo目录，而该目录正是Nginx将80端口转发到本地的路径（反向代理）。 在服务器上建立hexo博客git仓库 [root@ ~#] git init –bare ~/hexo_bare 创建git hooks 这里使用git的post-receive钩子，当本地绑定仓库执行git push后触发。 [root@ ~#] vim ~/hexo_bare/hooks/post-receive post-receive文件具体内容(注意$USER): #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/home/$USER/hexo_bare checkout -f 将空仓库关联到主仓库 [root@ ~#] git clone https://github.com/$username/hexo_repo.git ~/hexo_static [root@ ~#] cd ~/hexo_static [root@ ~#] git remote add live ~/hexo_bare 创建自动化脚本 [root@ ~#] vim ~/hexo_blog/hexo_git_deploy.sh 脚本内容如下 #!/bin/bash hexo clean hexo generate hexo deploy ( cd ~/hexo_static ; git pull ; git push live master) 配置Nginx反向代理 修改/var/www/html目录的权限，此目录默认为Nginx的请求映射目录 [root@ ~#] chown -R $USER:$USER /var/www/hexo [root@ ~#] chmod -R 755 /var/www/hexo 编辑Nginx配置文件(当前使用的系统为centos7.2，nginx和系统版本不一，配置文件的位置可能也不一) [root@ ~#] cp /ect/nginx/nginx.conf /ect/nginx/nginx.conf.bak #备份 [root@ ~#] vim /ect/nginx/nginx.conf #编辑 找到server块，内容大致如下 server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/www/hexo; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; #反向代理重点配置部分 location / { root /var/www/hexo; index index.html index.htm; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 编辑好Nginx配置文件后重启Nginx服务 [root@ ~#] systemctl restart nginx 总结到此，hexo静态博客的基本搭建已经完成，我们总结一下发布文章或者更新文章的流程 $ hexo new my-post $ vim ~/hexo_blog/source/_draft/my-post.md $ hexo publish my-post $ hexo generate $ hexo server $ ~/hexo_blog/hexo_git_deploy.sh 新建文章 -&gt; 编辑文章 -&gt; 发布文件 -&gt; 生成静态博客文件 -&gt; 预览 –&gt; 修改 –&gt; 最终发布 其他 美化hexo hexo官方和好心网友提供了丰富的网页主题和评论、数据统计、监控等插件，可参考hexo官方支持文档.本文借鉴了好心网友的indigo,沉浸式设计，还不错。 重点这是博主第一次写博客，好激动，但很多借鉴了网友的博文，如果有侵权问题，麻烦通知删除，谢谢！ 参考文章使用Hexo搭建个人静态博客 hexo官方文档 wordpress-jekyll-octopress-hexo四博客引擎比较 Markdown——入门指南","tags":[{"name":"hexo","slug":"hexo","permalink":"http://linzhs.cm/tags/hexo/"}]}]