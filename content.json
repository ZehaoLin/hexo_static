[{"title":"Java随笔 - 泛型","date":"2017-05-25T18:17:38.000Z","path":"2017/05/26/java-generic/","text":"Java随笔 - 泛型泛型的基本用法泛型类1234567891011121314151617public class Pair&lt;T&gt; &#123; private T first; private T second; public T getFirst() &#123; return first; &#125; public void setFirst(T t) &#123; this.first = t;W &#125; ...&#125;public class Pair&lt;K, V&gt; &#123; ...&#125; 泛型方法，可以在普通类中存在。12345public class ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T...a) &#123; return a[a.lenght / 2]; &#125;&#125; 在调用一个泛型方法时，在方法名前的尖括号放入具体的类型，大多数情况下，编译器有能力推导出具体的类型，所以尖括号部分的类型可以省略12String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;John&quot;, &quot;Q.&quot;, &quot;Public&quot;);String middle = ArrayAlg.getMiddle(&quot;John&quot;, &quot;Q.&quot;, &quot;Public&quot;); 少数情况下会报错的情形如下，参数的类型不对应。1double middle = ArrayAlg.getMiddle(3.14, 122, 0); 以上例子参数中，参数分别是double和int，编译器会将他们分别打包成Double和Integer，然后生成两种类型的方法，这两个方法都是合法的，但是他们放在一起使用，没有共同的超类型。 类型变量的限定单个限定extends Comparable>```， 多个限定用&做间隔``````。123456789101112131415以上例子限定T要去实现相应的接口，用的关键词是extends而不是implements，表示T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口，选定extends关键词的原因是其更接近子类的意思。Java中类是单继承的，所以限定类型为类时，只能是限定列表的第一个。## 泛型的实现细节编译器将代码编译完成后交给虚拟机来运行时，虚拟机中是不存在泛型这种类型对象的，所有泛型的对象都会变成指定类型的普通类对象。也就是说泛型其实是一种类，可以指定为很多种类型变量的类，很多工作都交给了编译器来完成。### 类型擦除为什么在编译过后，运行在虚拟机上的代码是没有泛型类型的，这是因为编译器对泛型做了类型擦除（type erasure）操作。经过类型擦除后，泛型类型都会自动转换为相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除变量有以下两种情况：* 无限定类型此情况下T将被替换成Object类型，并擦除&lt;T&gt;，如下示例： public class Pair { private T first; public T getFirst() { return first; } ... }12擦除后 -&gt; public class Pair { private Object first; public Object getFirst() { return first; } ... }12345&gt; C\\++的模板和Java泛型在这一点上的实现有很大的区别，C++的每个模板的实例化产生的类型都是不一样的，这样很容易导致“模板代码膨胀”现象。* 有限定类型泛型类型变量若有限定类型，那原始类型用限定表中的第一个类型变量来替换。 public class Interval implements Serializable { private T lower; private T upper; … public Interval(T first, T second) { if (first.compareTo(second) &gt;= 0) { lower = first; upper = second; } else { lower = second; upper = first; } }}1擦除后 -&gt; public class Interval implements Serializable { private ComparableComparable lower; private Comparable upper; … public Interval(Comparable first, Comparable second) { if (first.compareTo(second) &gt;= 0) { lower = first; upper = second; } else { lower = second; upper = first; } }}1234T的限定变量书写的顺序并没有严格的要求，也可以写成```class Interval&lt;T extends Serializable &amp; Comparable&gt;```。这样书写，编译器会把T替换成Serializable，而需要用到Comparable时，编译器会在相应的代码中插入强制类型转换。为了提高效率，比较好的习惯是将标签（tagging）接口，也就是没有方法的接口放在限定列表的末尾。### 翻译泛型表达式在T没有限定类型时，调用一个有返回值的泛型方法时，由于类型擦除，返回的是Object类型，所以编译器会在返回值的代码上插入强制类型转换。 Pair buddies = …;Employee buddy = buddies.getFirst();12345678以上代码，翻译成虚拟指令就是：* 调用原始方法Pair.getFirst* 将返回的Object类型强制转换为Employee类型。同理，对于泛型的公有域也是如此，但是不推荐有公有泛型域。### 翻译泛型方法泛型方法的翻译要注意的问题是保持多态性。实例分析： public class DateInterval extends Pair { public void setSecond(LocalDate second) { if (second.compareTo(getFirst()) &gt;= 0) { super.setSecond(second); } } …}1类型擦除后 -&gt; public class DateInterval extends Pair { public void setSecond(LocalDate second) { … } …}1DateInterval继承自Pair，Pair中也有一个setSecond方法，为```public void setSecond(Object second)```，也就是DateInterval被编译器做完类型擦除处理后，内部存在两个setSecond方法: public void setSecond(LocalDate second);public void setSecond(Object second);1现在，要使用setSecond方法， DateInterval interval = new DateInterval(…);Pair pair = interval;//super类对象引用子类，多态性pair.setSecond(aDate);123在调用setSecond方法的时候，为了适合多态性，编译器需要给调用的方法选择最合适的实现方法。因为pair应用的是子类DateInterval对象，正常来说调用的应该是DateInterval.setSecond，但是现在由于类型擦除的原因使得与多态性发生了冲突，不能去调用DateInterval.setSecond方法。要解决此问题，就需要编译器做一些中间工作，那就是z在DataInterval类中生成一个桥方法（bridge method）： public void setSecond(Object second) { setSecond((Date)second);}1234567891011## 泛型的约束和局限性&gt; Java中泛型的很多限制其实都来自其底层的实现，就是类型擦除。### 不能用基本类型实例化类型参数没有```Pair&lt;double&gt;```，只有```Pair&lt;Double&gt;```，原因是经过类型擦除后，类型会被替换成Object，double和Object不对应，所以不能存储double值，只有Object类型的域。### 运行时的类型查询只适用于原始类型泛型经过编译器的类型擦除后，虚拟中只剩下一个非泛型类型，比如Pair&lt;T&gt;，类型擦除后，放在虚拟机中运行，只有Pair。运行时试图查询一个对象是否属于某个泛型类型时，若使用instanceof编译器会报错，若用强制类型转换则会得到一个警告。 if (a instanceof Pair)//errorif (a instanceof Pair)//errorPair p = (Pair)a;//warningif (a instanceof Pair)//ok,it is true1另一个例子： Pair stringPair = …;Pair employeePair = …;System.out.println(stringPair.getClass() == employeePair.getClass());// print “true”1234比较后的结果是true，因为虚拟机中只有Pair，返回的都是Pair.class。### 不能创建参数化类型的数组可以声明参数类化型的数组，但是不能实例化 Pair[] table;//OKtable = new Pair[10];//error1234原因是，经过编译器的类型擦除后，数组会变成Pair[]。### Varargs警告有时候泛型方法的参数是可变的，这时候参数其实是接收了一个参数数组，若这个数组接收的都是泛型，那么就存在上面的问题--不能创建参数化类型的数组。为了能通过编译，可以加入注解（二选一）： @SuppressWarnings(“unchecked”)@SafeVarargs1234通过注解可以顺利运行，但是在处理table[0]的时候还是会抛出一个异常。### 不能实例化类型变量不能如此使用类型变量： new T(…)new T[…]T.calss123原因是，类型擦除后都会变成Object，但是本意却不是想new Object()。### 不能构造泛型数组 public static T[] minmax(T[] a) { T[] t = new T[2];}123456类型擦除后，得到的数组永远是Comapable[2]。可以使用强制类型转换，让类型擦除无法察觉，但是运行的时候还是会抛出异常。### 方形类的静态上下文中类型变量无效不能在静态域或者方法中应用类型变量。 public class Singleton { private static T singleInstance;//error public static T getSingleInstance() {//error if (singleInstance == null) singleInstance = new Singleton&lt;&gt;(); return singleInstance; } }1234类型擦除后，只剩下Singleton类，且只包含singleInstance域，不能再被指定泛型并且创建。### 不能抛出或者捕获泛型类的实例不能抛出，也不能捕获泛型类对象，泛型类也不能扩展Throwable。 public class Problem extends Exception {}//errorpublic static void doWork(Class t) {//error try { } catch (T e) { } }1不过以下例子是允许的: public static void doWork(T t) throws T { try { } catch (Throwable e) { t.initCause(e); throw t; } }123### 可以消除对受查异常的检查Java异常处理的一个原则是，对所有受查异常，必须提供一个处理器。若是使用泛型，可以绕开这个原则，然后包装到非受查异常中，就可以欺骗编译器。 @SuppressWarnings(“unchecked”)public static void doWorkAs(Throwable e) throws T { throw (T) e;}12### 注意擦除后的冲突 public calss Pair { public boolean equals(T values) { … }}1234泛型类Pair，在类型擦除后，equal方法变成了boolean equals(Object)，这是和Object中的equals方法冲突的。## 泛型类型的继承规则假设Manager是Employee的子类，但是，Pair&lt;Manager&gt;不是Pair&lt;Employee&gt;的子类，两者并没有什么关系，所以不能用Pair&lt;Employee&gt;对象变量引用Pair&lt;Manager&gt;，但是两者都可以用Pair引用，因为两者都继承于Pair。 Manager[] m = …;Pair e = ArraAlg.minmax(m);//errorPair p = new Pair&lt;&gt;(…); Pair t = p;//ok 123## 通配符类型通配符类型中，允许类型参数变化，比如： Pair&lt;? extends Employee&gt; 123表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair&lt;Manager&gt;，而Pair&lt;String&gt;就不是。### 通配符的超类限定 ? super Manager 123这个通配符限定Manger为所有类型的超类。### 无限定通配符 public class Pair&lt;?&gt; { ? getFirst() {…} void setFirst(?) {…} } ``` 例子中getFirst的返回值只能赋给一个Object，而setFirst方法不能被调用，甚至不能用Object调用。 Pair&lt;?&gt;和Pair本质的区别在于，可以用任意Object对象调用原始Pair类的setOnjevt方法。","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"Android接口定义语言（AIDL）","date":"2017-05-25T18:16:29.000Z","path":"2017/05/26/android-aidl/","text":"Android 接口定义语言 (AIDL)AIDL可以定义客户端与服务使用IPC机型互相通信时都认可的编程接口。在Android，进程是fork形式存在的，独自占有一块内存，一个进程无法访问另一个进程的内存。但是，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。Android使用AIDL来执行这一编组操作的代码繁琐工作。 注：只有允许不同应用的客户端用IPC方式访问服务，并且想要在服务中处理多线程，才有必要使用AIDL。如果不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。 定义AIDL接口Android Studio下新建AIDL文件（基本已经全自动完成了），会默认生成一个aidl文件夹，并把.aidl文件放入这里。Android SDK工具都会生成一个基于该.aidl文件的IBinder接口。并且保存到项目的 gen/ 目录中，生成的文件名与.aidl文件名一致，只是使用了.java（例如：IRemoteService.aidl 生成的文件名是 IRemoteService.java）。服务必须视情况实现IBinder接口，然后客户端应用便可绑定到该服务，并调用IBinder中的方法来执行IPC。 使用AIDL创建绑定服务，执行以下步骤： 创建.aidl文件 此文件定义带有方法签名的编程接口。 实现接口 Android SDK工具基于创建的.aidl文件，使用Java编程语言生成一个接口。此接口另有一个名为Stub的内部抽象类，用于拓展Binder类并实现AIDL接口中的方法。必须要拓展Stub类并实现方法。 向客户端公开该接口 实现 Service 并重写 onBind() 以返回 Stub 类的实现。 注意：在 AIDL 接口首次发布后对其进行的任何更改都必须保持向后兼容性，以避免中断其他应用对服务的使用。 也就是说，因为必须将自己的 .aidl 文件复制到其他应用，才能让这些应用访问这个服务的接口，因此必须保留对原始接口的支持。 创建.aidl文件AIDL使用简单的语法，这样可以通过可带参数和返回值的一个或多个方法来声明接口。参数和返回值可以是任意类型，甚至可以是其他AIDL生成的接口。 .aidl文件有Java构建，每个.aidl文件都必须定义单个接口，并且只需包含接口声明和方法签名。 默认情况下，AIDL支持以下数据类型： Java支持的所有基本数据类型（int, double, float, boolean, char long等） String CharSequence List Map List和Map中的所有元素都必须是以上列表中支持的数据类型，其他AIDL生成的接口或自己声明的可打包的类型。不支持通用 Map（如 Map 形式的 Map）。 另一端实际接收的具体类始终是 HashMap/ArrayList，但生成的方法使用的是 Map/List 接口。 定义服务接口时要注意： 方法可带0到多个参数，返回值可以为空 所有非原语参数都需要指示数据走向的方向标记。可以是in、out、inout。原语（基本类型）默认是in，不能是其他方向。应该将方法限定为真正需要的方向，因为编组参数的开销极大。 .aidl文件中包括的所有代码注释都包含在生成的IBinder接口中（import和package语句之前的注释除外） 只支持方法，不能公开AIDL中的静态字段。 .aidl demo:1234567891011121314151617// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. * 默认生成的方法，告知你可以使用哪些数据类型 */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 实现接口创建的AIDL文件会被转换成同名的.java文件，并且内部包含一个Stub子类，这个子类是其父接口（例如：YourInterface.Stub）的抽象实现，用于声明.aidl文件中的所有方法。 要实现.aidl生成的接口，就要拓展生成的Binder接口并实现从.aidl文件继承的方法。 demo：123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125;&#125;; 现在，mBinder 是 Stub 类的一个实例（一个 Binder），用于定义服务的 RPC 接口。 在下一步中，将向客户端公开该实例，以便客户端能与服务进行交互。 在实现 AIDL 接口时应注意遵守以下这几个规则： 由于不能保证在主线程上执行传入调用，因此一开始就需要做好多线程处理准备，并将服务正确地编译为线程安全服务。 默认情况下，RPC 调用是同步调用。如果您明知服务完成请求的时间不止几毫秒，就不应该从 Activity 的主线程调用服务，因为这样做可能会使应用挂起（Android 可能会显示“Application is Not Responding”对话框）— 您通常应该从客户端内的单独线程调用服务。 引发的任何异常都不会回传给调用方。 向客户端公开该接口服务实现该接口后，就需要向客户端公开该接口，以便客户端进行绑定。要为服务公开该接口，需要拓展Service类并且实现onBinder()，以返回一个类实例，这个类实现了生成的Stub。 demo：12345678910111213141516171819202122public class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125; &#125;;&#125; 客户端还必须具有对 interface 类的访问权限，因此如果客户端和服务在不同的应用内，则客户端的应用 src/ 目录内必须包含 .aidl 文件（它生成 android.os.Binder 接口 — 为客户端提供对 AIDL 方法的访问权限）的副本。 当客户端在 onServiceConnected() 回调中收到 IBinder 时，它必须调用 YourServiceInterface.Stub.asInterface(service) 以将返回的参数转换成 YourServiceInterface 类型。例如：123456789101112131415IRemoteService mIRemoteService;private ServiceConnection mConnection = new ServiceConnection() &#123; // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) &#123; // Following the example above for an AIDL interface, // this gets an instance of the IRemoteInterface, which we can use to call on the service mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) &#123; Log.e(TAG, &quot;Service has unexpectedly disconnected&quot;); mIRemoteService = null; &#125;&#125;; 通过IPC传递对象通过IPC接口把某个类从一个进程发送到另一进程是可以实现的。不过必须要确保该类的代码对IPC通信的另一端可用，并且该类必须支持Parcelable接口。支持Parcelable接口是很重要的，Android系统可通过它将对象分解成可编组到各进程的原语。 .aidl与C语言中的头文件类似，编译的时候不用添加.aidl文件，其并未被编译。 以下这个 Rect.aidl 文件可创建一个可打包的 Rect 类：12345package android.graphics;// Declare Rect so AIDL can find it and knows that it implements// the parcelable protocol.parcelable Rect; Rect类实现Parcelable接口实例：1234567891011121314151617181920212223242526272829303132333435363738394041import android.os.Parcel;import android.os.Parcelable;public final class Rect implements Parcelable &#123; public int left; public int top; public int right; public int bottom; public static final Parcelable.Creator&lt;Rect&gt; CREATOR = newParcelable.Creator&lt;Rect&gt;() &#123; public Rect createFromParcel(Parcel in) &#123; return new Rect(in); &#125; public Rect[] newArray(int size) &#123; return new Rect[size]; &#125; &#125;; public Rect() &#123; &#125; private Rect(Parcel in) &#123; readFromParcel(in); &#125; public void writeToParcel(Parcel out) &#123; out.writeInt(left); out.writeInt(top); out.writeInt(right); out.writeInt(bottom); &#125; public void readFromParcel(Parcel in) &#123; left = in.readInt(); top = in.readInt(); right = in.readInt(); bottom = in.readInt(); &#125;&#125; 调用IPC方法调用类必须执行以下步骤，才能调用使用AIDL定义的远程接口： 在项目src/目录中加入.aidl文件（Android Studio已默认创建）。 声明一个IBinder接口实例（基于AIDL生成）。 实现ServiceConnection 调用Context.bindService()，以传入ServiceConnection的实现。 再实现的onServiceConnected()中，将收到一个名为service的IBinder实例。调用YourInterfaceName.Stub.asInterface((IBinder)service)，以将返回的参数转换为 YourInterface 类型。 调用再接口上定义的方法。注意要始终捕获DeadObjectException异常，他们是连接中断时引发的，这也是远程方法引起的唯一异常。 如需断开连接，需要在接口中调用Conext.unBindService()。 有关调用 IPC 服务的几点说明： 对象是跨进程计数的引用。 可以将匿名对象作为方法参数发送。 demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public static class Binding extends Activity &#123; /** The primary interface we will be calling on the service. */ IRemoteService mService = null; /** Another interface we use on the service. */ ISecondary mSecondaryService = null; Button mKillButton; TextView mCallbackText; private boolean mIsBound; /** * Standard initialization of this activity. Set up the UI, then wait * for the user to poke it before doing anything. */ @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.remote_service_binding); // Watch for button clicks. Button button = (Button)findViewById(R.id.bind); button.setOnClickListener(mBindListener); button = (Button)findViewById(R.id.unbind); button.setOnClickListener(mUnbindListener); mKillButton = (Button)findViewById(R.id.kill); mKillButton.setOnClickListener(mKillListener); mKillButton.setEnabled(false); mCallbackText = (TextView)findViewById(R.id.callback); mCallbackText.setText(&quot;Not attached.&quot;); &#125; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); mKillButton.setEnabled(true); mCallbackText.setText(&quot;Attached.&quot;); // We want to monitor the service for as long as we are // connected to it. try &#123; mService.registerCallback(mCallback); &#125; catch (RemoteException e) &#123; // In this case the service has crashed before we could even // do anything with it; we can count on soon being // disconnected (and then reconnected if it can be restarted) // so there is no need to do anything here. &#125; // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_connected, Toast.LENGTH_SHORT).show(); &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mKillButton.setEnabled(false); mCallbackText.setText(&quot;Disconnected.&quot;); // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_disconnected, Toast.LENGTH_SHORT).show(); &#125; &#125;; /** * Class for interacting with the secondary interface of the service. */ private ServiceConnection mSecondaryConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // Connecting to a secondary interface is the same as any // other interface. mSecondaryService = ISecondary.Stub.asInterface(service); mKillButton.setEnabled(true); &#125; public void onServiceDisconnected(ComponentName className) &#123; mSecondaryService = null; mKillButton.setEnabled(false); &#125; &#125;; private OnClickListener mBindListener = new OnClickListener() &#123; public void onClick(View v) &#123; // Establish a couple connections with the service, binding // by interface names. This allows other applications to be // installed that replace the remote service by implementing // the same interface. Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); intent.setAction(ISecondary.class.getName()); bindService(intent, mSecondaryConnection, Context.BIND_AUTO_CREATE); mIsBound = true; mCallbackText.setText(&quot;Binding.&quot;); &#125; &#125;; private OnClickListener mUnbindListener = new OnClickListener() &#123; public void onClick(View v) &#123; if (mIsBound) &#123; // If we have received the service, and hence registered with // it, then now is the time to unregister. if (mService != null) &#123; try &#123; mService.unregisterCallback(mCallback); &#125; catch (RemoteException e) &#123; // There is nothing special we need to do if the service // has crashed. &#125; &#125; // Detach our existing connection. unbindService(mConnection); unbindService(mSecondaryConnection); mKillButton.setEnabled(false); mIsBound = false; mCallbackText.setText(&quot;Unbinding.&quot;); &#125; &#125; &#125;; private OnClickListener mKillListener = new OnClickListener() &#123; public void onClick(View v) &#123; // To kill the process hosting our service, we need to know its // PID. Conveniently our service has a call that will return // to us that information. if (mSecondaryService != null) &#123; try &#123; int pid = mSecondaryService.getPid(); // Note that, though this API allows us to request to // kill any process based on its PID, the kernel will // still impose standard restrictions on which PIDs you // are actually able to kill. Typically this means only // the process running your application and any additional // processes created by that app as shown here; packages // sharing a common UID will also be able to kill each // other&apos;s processes. Process.killProcess(pid); mCallbackText.setText(&quot;Killed service process.&quot;); &#125; catch (RemoteException ex) &#123; // Recover gracefully from the process hosting the // server dying. // Just for purposes of the sample, put up a notification. Toast.makeText(Binding.this, R.string.remote_call_failed, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;; // ---------------------------------------------------------------------- // Code showing how to deal with callbacks. // ---------------------------------------------------------------------- /** * This implementation is used to receive callbacks from the remote * service. */ private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() &#123; /** * This is called by the remote service regularly to tell us about * new values. Note that IPC calls are dispatched through a thread * pool running in each process, so the code executing here will * NOT be running in our main thread like most other things -- so, * to update the UI, we need to use a Handler to hop over there. */ public void valueChanged(int value) &#123; mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0)); &#125; &#125;; private static final int BUMP_MSG = 1; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BUMP_MSG: mCallbackText.setText(&quot;Received from service: &quot; + msg.arg1); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的异步消息处理机制","date":"2017-05-25T18:15:40.000Z","path":"2017/05/26/android-message/","text":"Android的异步消息处理机制HandlerAndroid中的异步消息处理机制由4个部分组成：Message、Handler、MessageQueue、Looper。 Message Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。 Handler Handler（处理者）主要是用于发送和处理信息的。发送一般是使用Handler的sendMessage方法，而发出去的信息经过一些地处理后，最终会传递到Handler的handleMessage方法中。 MessageQueue MessageQueue（消息队列）主要用于存放所有通过Handler发送出来的信息。这部分信息会一直存在于消息队列中等待被处理。每个线程中只会有一个MessageQueue对象。 Looper Looper是每个线程中的MessageQueue管家，调用Looper的loop方法后，就会进入到一个无线循环当中，然后每当发现MessageQueue中存在信息，就会将队列头部的信息取出，并传递给Handler的handleMessage方法。每个线程只有一个Looper对象。 demo：123456789101112131415161718192021222324252627282930pubblic class MainActivity extends AppCompatActivity &#123; public static final int UPDATE_TEXT = 1; private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case UPDATE_TEXT: // 刷新UI break; &#125; &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.test_button: new Thread(new Runnable() &#123; @Overrride public void run() &#123; Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); &#125; &#125;).start(); break; &#125; &#125;&#125; AsyncTask为了更好地在子线程中对UI主线程进行操作，Android提供了一个异步的工具–AsyncTask，其能轻易地从子线程切换到主线程。 AsyncTask是一个抽象类，要使用必须是集成并且实现抽象方法。AsyncTask类指定了三个参数，结构如下：1public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; ... &#125; 参数的作用： Params 在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。 Progress 在后台任务执行时，如果需要在界面上显示当前的进度，则使用这个泛型参数来作为进度单位。 Result 当任务执行完毕后，如果需要对结果进行返回，则使用这里的指定泛型作为返回类型。 demo：1public abstract class AsyncTask&lt;Void, Integer, Boolean&gt; &#123; ... &#125; 继承AsyncTask经常用到的重写方法有： onPreExecute() 这个方法在后台任务开始执行之前调用，用于进行一些界面上的初始化操作。 doInBackground(Params…) 这个方法的所有代码都在子线程中运行，可以用来执行所有耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果返回，如果AsyncTask的第三个参数为Void，就可以不返回任务的执行结果。注意，此方法在子线程中运行，不可以刷新UI线程，应该调用publishProgress方法触发onProgressUpdate()方法来完成。 onProgressUpdate(Progress…) 当在后台任务中调用publishProgress()方法后，onProgressUpdate方法很快就会被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。 onPostExecute(Result) 当后台任务执行完毕并通过return语句进行返回时，这个方法就很快被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如提醒任务执行的结果，以及关闭进度对话框等。 demo:123456789101112131415161718192021222324252627282930313233343536373839404142class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; progressDialog.show();//显示进度对话框 &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent = doDownload(); pubulishProgress(downloadPercent);//触发onProgressUpdate if (downloadPercent &gt;= 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; //在这里更新下载进度 progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss();//关闭进度对话框 //显示结果 if (result) &#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(): &#125; else &#123; Toast.makeText(context, &quot;Download failed&quot;, Toast.LENGTH_SHORT).show(): &#125; &#125;&#125; 执行：1new DownloadTask().execute();","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的Service","date":"2017-05-25T18:14:48.000Z","path":"2017/05/26/android-service/","text":"Android的ServiceService 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信(IPC)。例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 服务基本上分为两种形式： 启动 当应用组件（如 Activity）通过调用startService()启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。操作完成后，服务会自行停止运行。 绑定 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 一个服务可以同时以这两种方式运行，也就是既可以启动服务（不手动关闭就限期运行），也允许绑定。问题只是在于是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。 不管应用是处于启动状态还是绑定状态，或者是处于启动且绑定状态，任何应用组件均可以使用Activity那样通过调用Intent来使用服务，即使此服务是来自另一个应用。若是服务不想被其他应用访问，可知在AndroidManifest.xml中将服务声明为私有服务。123456789&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=&quot;.ExampleService&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;/&gt; ... &lt;/application&gt;&lt;/manifest&gt; 注意：服务默认是托管在主线程的，它既不创建自己的线程，也不在单独的进程中运行（除非另行制定）。若是有太占用时间的事务要完成，应该在服务中创建子线程来完成，从而降低ANR的风险，主线程扔可以与Activity交互。 基础知识要创建服务，必须使用或者创建Service的子类。定制service子类的时候，需要去实现一些回调方法，以处理服务生命周期中某些关键操作。应重写的重要回调方法有： onStartCommand() 当另一个组件（如 Activity）通过调用startService()请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。如果实现了此方法，则在服务工作完成后，需要自己在此服务中调用 stopSelf() 或在服务外的地方调用 stopService() 来停止服务。绑定的服务无需手动停止服务。 onBind 这个方法是Service类中唯一一个抽象方法。当另一个组件想通过调用bindService与绑定绑定（例如执行RPC）时，系统就会调用此方法。此方法要求返回一个IBinder接口，供客户端与服务进行通信。此方法是抽象方法，是一定要重写的，但是不绑定的话，返回null就可以了。 onCreate 首次创建服务时，系统将在onStartCommand或onBind前调用此方法来执行服务的创建。如果服务已在运行，则不会再被调用。 onDestroy 当服务不再使用且将被销毁时，系统将会调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。 如果以[startCommand()]方式启动服务，则服务将一直运行，直到服务本身使用stopSelf()自行停止运行或者其他组件使用stopService()停止。 如果以bindService()的方式创建服务，并且未调用startCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。 仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的Activity，则它不太可能会终止；如果将服务声明为==在前台运行==），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务（不过这还取决于从 onStartCommand() 返回的值。 为了确保应用的安全性，要始终使用显式Intent启动或绑定Service，且不要为服务声明inten过滤器，启动哪个服务存在一定的不确定性，而如果对这种不确定性的考虑非常有必要，则可为服务提供Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。 创建启动服务由startService()方法来启动服务，系统会回调onStartCommand()方法。服务通过该方式启动后，其生命周期是独立于启动它的组件的，并且可以无限期地在后台运行，即使启动它的组件已被销毁。因此，如果要终止该服务，则需要自身调用[stopSelf()]方法或者其他组件调用[stopService()]来停止。 应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。 例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。 拓展IntentService类IntentService是Service的一个子类，也是抽象类，在实现Service基础上添加了一个onHnaldeIntent抽象方法，其是startService()启动的，onBind()方法返回null。 如果不要求服务同时处理多个请求，这是最好的选择。只要onHandleIntent()方法，该方法接收一个请求的Intent。此类的优点是不用关心启动服务后怎么去关闭它，onHandeIntent方法执行完成后服务会自动停止。 IntentService执行一下操作： 创建默认的工作线程，用于在应用的主线程外执行传递给onStartCommand()的所有Intent。 创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这您就永远不必担心多线程问题。 在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。 提供 onBind() 的默认实现（返回 null）。 提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。 demo:123456789101112131415161718192021222324252627public class HelloIntentService extends IntentService &#123; /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() &#123; super(&quot;HelloIntentService&quot;); &#125; /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; &#125;&#125; 基本的IntentService只需要实现一个构造方法和onHandleIntent()方法，若是要实现onCreate()、onStartCommand()等方法，要确保调用超类的实现，这样才能使IntentService有效处理工作线程的生命周期。 demo:12345@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId);&#125; 除 onHandleIntent() 之外，您无需从中调用超类的唯一方法就是 onBind()（仅当服务允许绑定时，才需要实现该方法）。 拓展Service类使用 IntentService 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 Service 类来处理每个 Intent。 为了便于比较，以下提供了 Service 类实现的代码示例，该类执行的工作与上述使用 IntentService 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求，也就是异步处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HelloService extends Service &#123; private Looper mServiceLooper; private ServiceHandler mServiceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; // Stop the service using the startId, so that we don&apos;t stop // the service in the middle of handling another job stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process&apos;s // main thread, which we don&apos;t want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread&apos;s Looper and use it for our Handler mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we&apos;re stopping when we finish the job Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; mServiceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // We don&apos;t provide binding, so return null return null; &#125; @Override public void onDestroy() &#123; Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 要注意的是，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务，而IntentService做了默认的实现。从onStartCommand()返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 如果服务同时处理多个 onStartCommand() 请求，您不应在处理完一个启动请求之后停止服务，因您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，可以使用 stopSelf(int) 确保服务停止请求始终基于最近的启动请求。也就说，在调用 stopSelf(int) 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果在能够调用 stopSelf(int) 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。 创建绑定服务绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接（通常不允许组件通过调用 startService() 来启动它）。 如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。 要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。 要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 客户端可通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。bindService() 方法会立即无值返回，但当 Android 系统创建客户端与服务之间的连接时，会对 ServiceConnection 调用 onServiceConnected()，向客户端传递用来与服务通信的 IBinder。 多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。 创建提供绑定的服务时，必须提供 IBinder，用以提供客户端用来与服务进行交互的编程接口。可以通过三种方法定义接口： 扩展 Binder 类 如果服务是供自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。 如果服务只是自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，服务被其他应用或不同的进程占用。 使用 Messenger 如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。 这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样就不必对服务进行线程安全设计。 使用 AIDL AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。 如需直接使用 AIDL，必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，随后可在服务内对其进行扩展。 注意：大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用。 拓展 Binder 类若服务仅供本地应用使用，不需要跨进程工作，则可以直接实现Binder类，让自己的客户端通过该类来访问服务中的公共方法。 注意：此方法只有在客户端和服务位于同一应用和进程内的这一常见情况才有效。例如，对于需要将Activity绑定在后台播放音乐的自由服务的音乐应用，此方法非常有效。 一下是具体的设置方法： 在服务中，创建一个可满足下列任一要求的Binder实例： 包含客户端可调用的公共方法 返回当前Service实例，其中包含客户端可调用的公共方法 或返回服务承载的其他类的实例，其中包含客户端可调用的公共方法 从onBind()回调方法返回此Binder实例 在客户端中，从onServiceConnected()回调方法接收Binder，并使用提供的方法调用绑定服务。 Service demo：123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don&apos;t need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; Activity demo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We&apos;ve bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 使用 Messenger想让服务与远程进程通信，则可使用Messenger为服务提供接口。利用这种方法，无需使用AIDL就可以执行IPC。 Messenger使用方法摘要： 服务实现一个Handler，由其接收来自客户端的每个调用的回调 Handler用于创建Messenger对象（对Handler的引用） Messenger创建一个IBinder，服务通过onBind() 使其返回客户端 客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务 服务在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message。 Service demo：1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), &quot;hello!&quot;, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), &quot;binding&quot;, Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; Activity demo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported &apos;what&apos; value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 前台服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。 例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 要请求让服务运行于前台，则调用startForeground()，此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如：1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的进程和线程","date":"2017-05-25T18:14:01.000Z","path":"2017/05/26/android-process-thread/","text":"Android的进程和线程当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。 进程默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。 各类组件元素的清单文件条目—、、和—均支持 android:process属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。 此外， 元素还支持 android:process属性，以设置适用于所有组件的默认值。 如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。 决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面为决定终止进程所用的规则。 进程生命周期Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。 重要性层次结构一共有 5级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）： 前台进程 用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程： 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法） 托管某个 Service，后者绑定到用户正在交互的 Activity 托管正在“前台”运行的 Service（服务已调用 startForeground()） 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()） 托管正执行其 onReceive() 方法的 BroadcastReceiver 通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。 可见进程 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause()方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。 托管绑定到可见（或前台）Activity 的 Service。 可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 服务进程 正在运行已使用 startService()方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 后台进程 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息。 空进程 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。 此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。 由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。 进程间通信Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。 这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。 要执行 IPC，必须使用 bindService() 将应用绑定到服务上。 线程应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。 系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。 例如，当用户触摸屏幕上的按钮时，应用的 UI 线程会将触摸事件分派给小部件，而小部件反过来又设置其按下状态，并将失效请求发布到事件队列中。 UI 线程从队列中取消该请求并通知小部件应该重绘自身。 在应用执行繁重的任务以响应用户交互时，除非正确实现应用，否则这种单线程模式可能会导致性能低下。 具体地讲，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。 一旦线程被阻塞，将无法分派任何事件，包括绘图事件。 从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。 此外，Android UI 工具包并非线程安全工具包。因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。 因此，Android 的单线程模式必须遵守两条规则： 不要阻塞 UI 线程 不要在 UI 线程之外访问 Android UI 工具包 工作线程根据上述单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。 如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。 例如，以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在 ImageView 中：12345678public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; Bitmap b = loadImageFromNetwork(&quot;http://example.com/image.png&quot;); mImageView.setImageBitmap(b); &#125; &#125;).start();&#125; 乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：不要在 UI 线程之外访问 Android UI 工具包 — 此示例从工作线程（而不是 UI 线程）修改了 ImageView。 这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。 为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 例如，您可以通过使用 View.post(Runnable) 方法修复上述代码：12345678910111213public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; final Bitmap bitmap = loadImageFromNetwork(&quot;http://example.com/image.png&quot;); mImageView.post(new Runnable() &#123; public void run() &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125;).start();&#125; 现在，上述实现属于线程安全型：在单独的线程中完成网络操作，而在 UI 线程中操纵 ImageView。 但是，随着操作日趋复杂，这类代码也会变得复杂且难以维护。 要通过工作线程处理更复杂的交互，可以考虑在工作线程中使用 Handler 处理来自 UI 线程的消息。当然，最好的解决方案或许是扩展 AsyncTask 类，此类简化了与 UI 进行交互所需执行的工作线程任务。 使用AsyncTaskAsyncTask 允许对用户界面执行异步操作。 它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。 要使用它，必须创建 AsyncTask 的子类并实现 doInBackground() 回调方法，该方法将在后台线程池中运行。 要更新 UI，应该实现 onPostExecute() 以传递 doInBackground() 返回的结果并在 UI 线程中运行，以便您安全地更新 UI。 稍后，您可以通过从 UI 线程调用 execute() 来运行任务。 例如，您可以通过以下方式使用 AsyncTask 来实现上述示例：1234567891011121314151617public void onClick(View v) &#123; new DownloadImageTask().execute(&quot;http://example.com/image.png&quot;);&#125;private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123; /** The system calls this to perform work in a worker thread and * delivers it the parameters given to AsyncTask.execute() */ protected Bitmap doInBackground(String... urls) &#123; return loadImageFromNetwork(urls[0]); &#125; /** The system calls this to perform work in the UI thread and delivers * the result from doInBackground() */ protected void onPostExecute(Bitmap result) &#123; mImageView.setImageBitmap(result); &#125;&#125; 现在 UI 是安全的，代码也得到简化，因为任务分解成了两部分：一部分应在工作线程内完成，另一部分应在 UI 线程内完成。 下面简要概述了 AsyncTask 的工作方法，但要全面了解如何使用此类，应阅读 AsyncTask 参考文档： 可以使用泛型指定参数类型、进度值和任务最终值 方法 doInBackground() 会在工作线程上自动执行 onPreExecute()、onPostExecute() 和 onProgressUpdate() 均在 UI 线程中调用 doInBackground() 返回的值将发送到 onPostExecute() 可以随时在 doInBackground() 中调用publishProgress()，以在 UI 线程中执行 onProgressUpdate() 可以随时取消任何线程中的任务 使用工作线程时可能会遇到另一个问题，即：运行时配置变更（例如，用户更改了屏幕方向）导致 Activity 意外重启，这可能会销毁工作线程。 线程安全方法在某些情况下，您实现的方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。 这一点主要适用于可以远程调用的方法，如绑定服务中的方法。如果对 IBinder 中所实现方法的调用源自运行 IBinder 的同一进程，则该方法在调用方的线程中执行。但是，如果调用源自其他进程，则该方法将在从线程池选择的某个线程中执行（而不是在进程的 UI 线程中执行），线程池由系统在与 IBinder 相同的进程中维护。 例如，即使服务的 onBind() 方法将从服务进程的 UI 线程调用，在 onBind() 返回的对象中实现的方法（例如，实现 RPC 方法的子类）仍会从线程池中的线程调用。 由于一个服务可以有多个客户端，因此可能会有多个池线程在同一时间使用同一 IBinder 方法。因此，IBinder 方法必须实现为线程安全方法。 同样，内容提供程序也可接收来自其他进程的数据请求。尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法（query()、insert()、delete()、update() 和 getType() 方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的 UI 线程调用。 由于这些方法可能会同时从任意数量的线程调用，因此它们也必须实现为线程安全方法。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的Context及其子类","date":"2017-05-25T18:12:37.000Z","path":"2017/05/26/android-context/","text":"Android的Context及其子类Android的系统组件很多，Activity、Service、BroadcastReceiver等都是很常用的，这些组件的创建都不能是凭空的，都需要借助Context这个核心功能类或者其子类。 Context继承结构 image Context（android.content）是一个抽象类，它有两个继承类，分别是上下文封装的封装类ContextWrapper和上下文功能的实现类ContextImpl（可以从命名看出，Wrapper和Implments）。 ContextWrapper有三个子类，分别是Application，Service，ContextThemeWrapper，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity。 从以上的继承关系上总结，Context有三种类型，分别是Apllication、Activity、Service。三个类分别承担着不同的任务，而他们具体的Context功能有ContextImpl去实现。 Context的功能Context的功能很多，很强大。Toast、启动Activity、启动Service、发送广播、操作数据库等都需要用到Context。 由于Context的具体能力是由ContextImpl去实现的，所以绝大多数场景下，Apllication、Activity、Service三类的Context是可以通用的。 出于安全的考虑，Android做了一些限制，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 Context的数量Context数量 = Activity数量 + Service数量 + 1 一个应用只能有一个Application，但是活动和服务可以有多个。 Application Context每个应用程序都会在AndroidManifest.xml上注册一个Application，默认是没有指定名字的。在Activity上获取Context的相关信息：1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Application application = (Application)getApplication(); Log.d(&quot;MainActivity&quot;, &quot;getApplication is&quot; + application); Context appContext = getApplicationContext(); Log.d(&quot;MainActivity&quot;, &quot;getApplicationContext is&quot; + appContext); Context baseContext = getBaseContext(); Log.d(&quot;MainActivity&quot;, &quot;getBaseContext is&quot; + baseContext); &#125;&#125; logcat输出结果123com.example.linzh.contexttest D/MainActivity: getApplication isandroid.app.Application@421b137com.example.linzh.contexttest D/MainActivity: getApplicationContext isandroid.app.Application@421b137com.example.linzh.contexttest D/MainActivity: getBaseContext isandroid.app.ContextImpl@de166a4 输出结果分析： 在输出的结果里，getApplication和getApplicationContext的结果是一样的，因为Application本身也是Context（其子类）。所以这里获取的getApplicationContext就是Application本身的实例。 但是，getApplicationContext和getApplication两者的应用范围是不一样的。getApplication只能在Activity和Service中被调用，而getApplicationContext适用范围更广，比如BroadcastReceiver是不能调用getApplication的，但是getApplicationContext可以。 在输出的log里还有baseContext，这个是ContextImpl功能实现类的。 注意点Application不能被new，不能和单例混在一起。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android中Activity之间的通信","date":"2017-05-25T18:11:37.000Z","path":"2017/05/26/android-activity-communication/","text":"Android中Activity之间的通信 此篇随笔将总结Activity之间的通信，数据交流，如何保存Activity的状态。 IntentIntent，即意图，用于描述你想在某个Intent对象的简单操作，再通过startActivity或者startActivityForResult方法来启动这个意图所对应的活动。 意图有隐式和显式之分。显式的意图是在java文件中直接调用指定的活动类，隐式的意图是现在AndroidManifest.xml中指定uri，然后在活动中指定此uri来启动所对应的活动。 Android自带的库中有很多通用的隐式意图，具体的参考Android官方文档。 此外，意图还可以指定意图过滤器，来筛选自己想要的意图。 传递信息意图不仅可以用来启动活动，还可以用来做活动之间的传信者。 在用意图启动一个活动之前，调用intent的putExtra方法来存储键值对。1234String value = &quot;hello&quot;;Intent intent = new Intent(ThisActivity.this, OtherActivity.class);intent.putExtra(&quot;key&quot;, value);startActivity(intent); 完成启动后，即可将数据取出。12Intent intent = getIntent();String data = intent.getStringExtra(&quot;key&quot;); 当然，传递的信息不仅仅只能是String，其他基本类型都是可以的，相应的把getXXX的XXX置为相应的类型即可。 同理，用startActivityForResult启动的活动，也可以通过Intent传递回一些信息。返回的信息通过setResult来设置。12345Intent intent = new Intent();intent.putExtra(&quot;data_return&quot;, &quot;Hello&quot;);intent.putExtra(&quot;int_data&quot;, 100);setResult(RESULT_OK, intent);//RESULT_OK是返回的编码，可以自定义finish(); 在接收返回的活动中取出信息12getIntent().getStringExtra(&quot;data_return&quot;);getIntent().getIntExtra(&quot;int_data&quot;); 序列化在用Intent来启动的时候顺便传递一些信息，是很便捷的，但是Intent所传递的信息非常有限，它只能传递基本数据类型。 默认的Intent传递信息有所限制，但是可以自己定制传递的信息机制，那就是用序列化机制。序列化后对象即可储存在本地，也可以通过网络流进行传输。 SerializableAndroid提供的序列化机制是比较丰富的，Java默认支持Serializable接口，只要类去implements它，就具备了序列化能力，而且可以不去实现Serializable的方法，如下例子：1234567891011121314151617181920public class Person implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; publci void setAge(int age) &#123; this.age = age; &#125;&#125; 通过Intent传递，传递的方式和普通的intent传递并没有什么差别。123456Person person = new Person();person.setName(&quot;Tom&quot;);person.setAge(20);Intent intent = new Intent(ThisActivity.this, OtherActivity.class);intent.putExtra(&quot;person_data&quot;, person);startActivity(intent); 获取也是一样：1Person person = (Person)getIntent().getSerializableExtra(&quot;person_data&quot;); PercelableAndroid除了支持Serializable，还自己实现了另一个序列化机制，Percelable接口。Percelable的实现相比Serializable复杂，需要去重写describeContents和writeToParcel两个方法，还得创建一个Parcelable.Creator接口的实现。例子：1234567891011121314151617181920212223242526272829303132public class Person implements Parcelable &#123; private String name; private int age; ... @Override public int describeContents() &#123; return 0;//包含特殊对象的种类，这里返回0即可 &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(age); &#125; public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel source) &#123;//用于反序列化读取数据 Person person = new Person(); person.name = source.readString(); person.age = source.readInt(); return person; &#125; @Override public Person[] newArray(int size) &#123;//创建序列化对象数组 return new Person[size]; &#125; &#125;&#125; 接下来的序列化和传递都和Serializable的一致，反序列化有点差别的地方在于下面例子，其他的没什么差别。1Person person = (Person)getIntent().getParcelableExtra(&quot;person_data&quot;); Parcelable的序列化操作相比Serializable麻烦了不少，但其效率更好，Serializable的序列化是把整个对象都序列化了，不管信息有没有用，而Parcelable是根据自己去实现相应的操作定制相应的数据进行序列化。所以通常情况下更加推荐使用Parcelable进行Intent传递数据。 保存Activity的状态当一个任务中的一个Activity停止时，系统的默认行为是会保留它的状态的，这样一来，当用户从上一个活动中返回时，其用户界面与用户离开该活动时才一致，这样才不会影响到用户的体验，效率也更快。但是，若该活动在返回栈中很久没有重新回到栈顶工作，那么系统GC会回收并且销毁它，重新需要工作的时候就是重新实例了，这样会丢失已有的状态信息，这个时候我们需要给Activity的状态做保留。 保存Activity的状态信息通过onSavaInstanceState()这个回调方法来完成。 系统会在onPause回调方法被调用前去调用onSaveInstanceState方法，然后再使Activity进行后面的方法回调，以至于活动变得易于销毁，保证内存的充足使用。 在调用onSavaInstanceState方法的时候，系统会向其传递一个Bundle类对象，可以在其中使用putString()和putInt等方法以键值对的形式保存有关Activity状态信息。 若是Activity被GC回收，也就是系统终止了本应用进程，而后用户又返回到该Activity，系统会重建Activity，在回调完onCreate()和onStart()方法后去回调onRestoreInstanceState()方法。 在onRestoreInstanceState()方法中会有一个Bundle对象，若为空则没有状态信息需要恢复，若是不为空则要提取保存状态的信息。 其实，即使我们不做保存状态信息的操作，系统默认也会在onSavaInstanceState()方法上实现部分Activity状态的保存。具体讲，默认实现会为布局中的每个View调用相应的onSaveInstanceState()方法，让每个视图都能提供有关自身应保存的信息。Android框架中几乎每个小部件都会根据需要实现此方法，以便在重建Activity时自动保存和恢复对UI所做的任何可见更改。例如，EditText会保存用户输入的任何文本，CheckBox则会保存复选框的选中或未选中状态。系统默认实现此方法需要有每个小部件的唯一ID，若是没有指定ID，则不会保存其状态。 尽管onSavaInstanceState()方法的默认实现会保存一些UI有关的状态信息，但是有时候并不能满足需求，所以才需要自己去定制，从而保存更多的信息。例如，有可能需要保存在Activity生命周期内发生了变化的成员值。 在重写onSavaInstanceState方法时，正确的做法应该是先去调用super类的此方法，然后再作品定制操作，一遍默认实现能够恢复视图的状态，还能传递信息。 切记，onSavaInstanceState()方法是不能保证一定会被调用的，若是用户按下“返回”键显示关闭活动，那就没法保存了。所以，此方法应该只利用来记录Activity的瞬态（UI状态），而不是用来保存一些持久性的数据。保存持久性数据可以在onPause方法中将数据存入数据库等容器中。 Bundle类Bundle类是final的，也就是无法被继承，其实现了克隆和Parcelable序列化接口。123public final class Bundle extends BaseBundle implements Cloneable, Parcelable &#123; ...&#125; 信息传递例子：123456Intent intent = new Intent();intent.setClass(ThisActivity.this, TargetActivity.class);Bundle bundle = new Bundle();bundle.putString(&quot;data&quot;, &quot;hello&quot;);intent.putExtras(bundle);startActivity(intent); 在TargetActivity.java中12345public void onCreate(Bundle savadInstanceState) &#123; ... Bundle bundle = getIntent().getExtras(); String data = bundle.getString(&quot;data&quot;);&#125; 保存Activiyt状态在onPause前调用12345678910111213static final String STATE_SCORE = &quot;playerScore&quot;;static final String STATE_LEVEL = &quot;playerLevel&quot;;...@Overridepublic void onSaveInstanceState(Bundle savaInstanceState) &#123; //保存用户当前的游戏状态 savaInstanceState.putInt(STATE_SCORE, mCurrentScore); savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel); //调用系统默认实现的onSavaInstanceState来保存UI状态 super.onSaveInstanceState(savedInstanceState);&#125; 恢复Acitivity状态Activity在先前销毁后重新创建时（非用户主动销毁），可以从系统向Activity传递的Bundle对象恢复已保存的状态，onCreate()和onRestoreInstanceState()回调方法均接收包含实例状态信息的相同Bundle。 无论是新创建还是重建Activity，系统都会调用onCreate()方法，所以如果是在onCreate方法中去恢复信息，那必须在读取Bundle信息前去检测Bundle是否为null。如果为null，则系统将创建Activity的新实例，而不是恢复已销毁的先前实例。 例如以下例子，在onCreate()方法中去识别Bundle是否为null，然后再选择去恢复与否1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Always call the superclass first // Check whether we&apos;re recreating a previously destroyed instance if (savedInstanceState != null) &#123; // Restore value of members from saved state mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL); &#125; else &#123; // Probably initialize members with default values for a new instance &#125; ...&#125; 可以选择实现系统在 onStart()方法之后调用的onRestoreInstanceState()来实现恢复状态信息，而不是在 onCreate()期间恢复状态。系统只在存在要恢复的已保存状态时调用onRestoreInstanceState()，因此此时无需检查 Bundle 是否为 null：12345678public void onRestoreInstanceState(Bundle savedInstanceState) &#123; // Always call the superclass so it can restore the view hierarchy super.onRestoreInstanceState(savedInstanceState); // Restore state members from saved instance mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);&#125; 其他信息传递方法详见Android的广播机制和Android的数据存储。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的广播机制","date":"2017-05-25T18:10:10.000Z","path":"2017/05/26/android-broadcast/","text":"Android的广播机制Android的广播机制Broadcast Receiver可以实现应用程序之间、Activity之间的信息传递。广播的通信是跨进程的。 广播类型Android提供的广播类型有两种，标准广播和有序广播。 标准广播是一种完全异步执行的广播，其是无序的，在发出后，所有接收器都能在同一时刻接收到此广播。这种广播的效率比较高，但同时也意味着无法被截断，也就是可能是不安全的。 有序广播正如其名，其是有序的。在广播发出后，同一时刻只能有一个广播接收器能够接收到，且根据优先级来传递此广播，若在中间被截断，则后面的广播接收器无法接收到此广播。 动态注册广播动态注册广播的方法是在Java代码中实现。1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver); &#125; class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125; 例子中的内部类NetworkChangeReceiver继承自BroadcastReceiver，并且重写了onReceive方法，其实就是作为了广播接收器。在初始化的时候我们用意图筛选器筛选出了网络状态变化这个广播，并且将意图筛选器和广播接收器注册，所以当网络变化的时候，相应的接收器的onReceive方法就会被回调。 注意，竟然注册了广播，那么在销毁此活动时，广播接收器也要取消注册。 静态注册广播静态注册广播就是在清单元件中去注册，其优点在于可以快速响应。动态注册比较灵活，可控，但是在一些情况下，就力不从心了，比如程序启动前我们要接收到广播后作出响应，但是动态注册只能等到程序启动后才能实现，而静态就不一样了。 例子：接收开机广播123456789101112131415161718192021public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. Toast.makeText(context, &quot;Boot Complete&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;//AndroidManifest.xml...&lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;... 以上操作注意权限问题 自定义发送广播以上的操作都是接收广播，接下来自定义标准和有序广播的发送。 发送标准广播定制接收器123456789101112131415public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送标准广播12345678Button button = (Button)findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); sendBroadcast(intent); &#125;&#125;); 发送有序广播广播的信息传递是跨进程的，有序广播可以在优先级不同的进程中不断传递。有序的广播和标准广播的配置差不多，唯一的区别在于sendBroadcast方法变成了sendOrderBroadcast。1sendOrderBroadcast(intent, null); 有序广播是有优先级的，可以在清单文件中设置优先级。1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; &gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 截断广播传递12345678public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125; 本地广播前面所涉及的发送和接收广播都是全局的，也就是发出的广播可以被其他任何应用程序所接收，这是非常不安全的。Android提供了另一种安全的广播机制，本地广播，使用这个机制发出的广播智能在本应用程序内部传递。 使用例子：12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;); localBroadcastManager.sendBroadcast(intent); &#125; &#125;); intentFilter = new IntentFilter(); intentFilter.addAction(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(localReceiver); &#125; class LocalReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; &#125; &#125;&#125; 本地广播借助的是LocalBroadcastManager来传递传播，其他和有序、标准广播用法差不多。 注意点广播机制传播的这些信息往往是轻量级的，因为广播接受者的生命周期非常短。当执行onReceiver方法之后，广播就会被销毁。 在广播接受者中不能进行耗时较长的操作，也不要在Receiver中创建子线程，Receiver在接收完成后，所有进程都会变成空进程，很容易被GC回收掉。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的ListView实现","date":"2017-05-25T18:07:58.000Z","path":"2017/05/26/android-listview/","text":"Android自定义View和ViewGroup Android中提供了丰富、复杂的视图系统，widget类的组件：Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner都是直接或间接继承于super类View，布局类：LinearLayout, FrameLayout, RelativeLayout等则继承于ViewGroup， ViewGroup则继承于View。 所以，要设计构建自己的视图或者布局，就要去继承View或者ViewGroup。本文从使用的角度来总结自定制View和ViewGroup。 自定义View自定义View，最基本的就是继承Android提供的基本视图类View。自定义步骤： 自定义View的属性 编写attr.xml文件 在layout布局文件中引用，同时引用命名空间 在View的构造方法中获得我们自定义的属性，在自定义控件中进行读取（构造方法拿到attr.xml文件值） 重写onMesure 重写onDraw 12345678910111213141516171819public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125;&#125; 继承了View类，还需要重写2个以上的构造方法（以上示例为常用重写构造方法）和onMeasure(), onDraw()方法，在View继承中，onLayout()是非必须的。 拓展onMeasure()自定义View都要自己来测量控制宽高尺寸，算出自己需要占用多大的面积。我们常在xml布局文件中用match_parent和wrap_content，这两属性都是依赖于父布局的，没有父布局就没法正确定位宽高。 这里存在一个疑问，就是如果我们在activity_main.xml中的代码如下，layout_width和layout_height指定的值也都为match_parent，其父布局又在哪呢？123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/main_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; 我们在MainActivity.java中进行测试：123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private LinearLayout linearLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); linearLayout = (LinearLayout)findViewById(R.id.main_layout); LayoutInflater layoutInflater = LayoutInflater.from(this); View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null); linearLayout.addView(buttonLayout); ViewParent viewParent = linearLayout.getParent();//获取父布局的名字 Log.d(&quot;MainActivity&quot;, &quot;The parent of main linear layout is &quot; + viewParent); &#125;&#125; 运行以上App，可以在logcat中打印出如下信息：1The parent of main linear layout is android.support.v7.widget.ContentFrameLayout&#123;2ef2e36 V.E...... ......I. 0,0-0,0 #1020002 android:id/content&#125; 注：以上运行API level 为25 从logcat的信息可知，我们在每个xml文件的布局的最外层，Android还自动帮我们加了一个FrameLayout/ContentFrameLayout，在自动嵌套的父布局里，有一部分是content，就是默认放label的地方，对应setContentView方法，在此之下才是我们自己定义的布局文件的内容。 onMeasure方法的原型如下：1protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 在参数中，widthMeasureSpec和heightMeasureSpec都为int，但是每个int都包含着两个信息，分别是尺寸和测量模式，一般情况下，int是32位的，Android把其中的30位用做尺寸大小存储，2bit用做测量模式存储。 2bit来存测量模式信息，也就是最多有4种模式，Android提供了3种测量模式，如下： 测量模式 说明 UNSPECIFIED 父容器没有对当前View有任何限制，当前View可以任意取尺寸 极少用 EXACTLY 父布局要求的精确尺寸，必须用这个尺寸作为View尺寸 AT_MOST 父布局给予View最大的尺寸，当前的View能取的尺寸为这个 测量模式和实际布局应用的属性值的关系： match_parent -&gt; EXACTLY wrap_content -&gt; AT_MOST 指定尺寸 -&gt; EXACTLY 如何获取widthMeasureSpec和heightMeasureSpec中的测量模式和尺寸大小？Android库中提供了两个方法，用来提取这两个信息，其实现细节就是进行了位运算，将前2-bit当做测量模式，后30-bit作为尺寸大小。12int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec); 重写onMeasure方法示例：1234567891011121314151617181920212223242526272829303132333435363738private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; &#125; case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size //我们将大小取最大值,你也可以取其他值 mySize = size; break; &#125; case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它 mySize = size; break; &#125; &#125; return mySize;&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height);//设置测量尺寸&#125; 完成自定义类的继承拓展后，就可以使用该View了，在xml布局文件中使用：1234&lt;[package name].MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#ff0000&quot; /&gt; 拓展onDraw()onDraw方法用于绘制效果图，super类默认提供了Canvas对象，其具备基本的绘图功能，比如绘制背景颜色、背景图片等，可以直接使用。 若是在上面的onMeasure例子上，在正方形的基础上画圆，可以重写onDraw方法为如下：1234567891011121314@Override protected void onDraw(Canvas canvas) &#123; //调用父View的onDraw函数，因为View这个类帮我们实现了一些 // 基本的而绘制功能，比如绘制背景颜色、背景图片等 super.onDraw(canvas); int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了 int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径 int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径 Paint paint = new Paint(); paint.setColor(Color.GREEN); canvas.drawCircle(centerX, centerY, radius, paint); &#125; 自定义布局属性可以在res/values/styles.xml文件中定义自己的属性（或者新建attr.xml文件），在需要用户来指定某些属性的值的时候，这个是很有用的。 示例：12345678&lt;resources&gt; &lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt; &lt;declare-styleable name=&quot;MyView&quot;&gt; &lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt; &lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在xml布局文件中使用：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;[package name].MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; hc:default_size=&quot;100dp&quot; /&gt;&lt;/LinearLayout&gt; 在Java文件中解析获取该属性的值：1234567891011121314private int defalutSize; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签 //即属性集合的标签，在R文件中名称为R.styleable+name TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView); //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称 //第二个参数为，如果没有设置这个属性，则设置的默认的值 defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100); //最后记得将TypedArray对象回收 a.recycle(); &#125; 自定义View完整示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example.linzh.myview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;/** * Created by linzh on 2017/3/28. */public class MyView extends View &#123;//继承View至少实现两个构造方法 private int defaultSize; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签 //即属性集合的标签，在R文件中名称为R.styleable+name TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView); //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称 //第二个参数为，如果没有设置这个属性，则设置的默认的值 defaultSize = typedArray.getDimensionPixelSize(R.styleable.MyView_default_size, 100); typedArray.recycle();//回收 &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; //调用父View的onDraw函数，因为View这个类帮我们实现了一些 // 基本的而绘制功能，比如绘制背景颜色、背景图片等 super.onDraw(canvas); int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了 int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径 int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径 Paint paint = new Paint(); paint.setColor(Color.GREEN); canvas.drawCircle(centerX, centerY, radius, paint); &#125; private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED://如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST://如果测量模式是最大取值为size 类似于wrap_content mySize = size;//这里把值去最大，也可以取其他值 break; case MeasureSpec.EXACTLY://如果是固定大小，拿就不要去改变它， 类似于match_parent mySize = size; break; &#125; return mySize; &#125;&#125; 自定义ViewGroupViewGroup是一到多个View的容器，ViewGroup多大也是要测量好的，而且要根据View来测量。 重写onMeasure逐个测量View的大小，并且设定ViewGroup的大小：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; //如果宽高都是包裹内容 if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; /*** * 获取子View中宽度最大的值 */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) maxWidth = childView.getMeasuredWidth(); &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125; 重写onLayout自定义ViewGroup，重写onLayout方法是有用的，在此方法我们将View逐个摆放到设定好大小的ViewGroup中：123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); //记录当前的高度位置 int curHeight = t; //将子View逐个摆放 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); int height = child.getMeasuredHeight(); int width = child.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 child.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125;&#125; 完成Java代码的定制，即可在xml布局文件中使用：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.example.linzh.myview.MyViewGroup android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ff9900&quot;&gt; &lt;Button android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:layout_width=&quot;50dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;/com.example.linzh.myview.MyViewGroup&gt; &lt;com.example.linzh.myview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; linzh:default_size=&quot;100dp&quot;/&gt;&lt;/LinearLayout&gt; 自定制ViewGroup完成示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.linzh.myview;import android.content.Context;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;/** * Created by linzh on 2017/3/28. */public class MyViewGroup extends ViewGroup &#123;//至少实现两个Super类的构造器 public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子view，当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//如果宽高都是包裹内容 //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); int curHeight = t;//记录当前的高度位置 for (int i = 0; i &lt; count; i++) &#123;//将View逐个摆放 View view = getChildAt(i); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 view.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125; &#125; /** * 获取子View中宽度最大的值 * @return */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) &#123; maxWidth = childView.getMeasuredWidth(); &#125; &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125;&#125; 参考 Android API指南 Custom Components 自定义View，有这一篇就够了","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的单元测试和UI测试基础","date":"2017-05-25T18:07:10.000Z","path":"2017/05/26/android-test/","text":"Android自定义View和ViewGroup Android中提供了丰富、复杂的视图系统，widget类的组件：Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner都是直接或间接继承于super类View，布局类：LinearLayout, FrameLayout, RelativeLayout等则继承于ViewGroup， ViewGroup则继承于View。 所以，要设计构建自己的视图或者布局，就要去继承View或者ViewGroup。本文从使用的角度来总结自定制View和ViewGroup。 自定义View自定义View，最基本的就是继承Android提供的基本视图类View。自定义步骤： 自定义View的属性 编写attr.xml文件 在layout布局文件中引用，同时引用命名空间 在View的构造方法中获得我们自定义的属性，在自定义控件中进行读取（构造方法拿到attr.xml文件值） 重写onMesure 重写onDraw 12345678910111213141516171819public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125;&#125; 继承了View类，还需要重写2个以上的构造方法（以上示例为常用重写构造方法）和onMeasure(), onDraw()方法，在View继承中，onLayout()是非必须的。 拓展onMeasure()自定义View都要自己来测量控制宽高尺寸，算出自己需要占用多大的面积。我们常在xml布局文件中用match_parent和wrap_content，这两属性都是依赖于父布局的，没有父布局就没法正确定位宽高。 这里存在一个疑问，就是如果我们在activity_main.xml中的代码如下，layout_width和layout_height指定的值也都为match_parent，其父布局又在哪呢？123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/main_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; 我们在MainActivity.java中进行测试：123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private LinearLayout linearLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); linearLayout = (LinearLayout)findViewById(R.id.main_layout); LayoutInflater layoutInflater = LayoutInflater.from(this); View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null); linearLayout.addView(buttonLayout); ViewParent viewParent = linearLayout.getParent();//获取父布局的名字 Log.d(&quot;MainActivity&quot;, &quot;The parent of main linear layout is &quot; + viewParent); &#125;&#125; 运行以上App，可以在logcat中打印出如下信息：1The parent of main linear layout is android.support.v7.widget.ContentFrameLayout&#123;2ef2e36 V.E...... ......I. 0,0-0,0 #1020002 android:id/content&#125; 注：以上运行API level 为25 从logcat的信息可知，我们在每个xml文件的布局的最外层，Android还自动帮我们加了一个FrameLayout/ContentFrameLayout，在自动嵌套的父布局里，有一部分是content，就是默认放label的地方，对应setContentView方法，在此之下才是我们自己定义的布局文件的内容。 onMeasure方法的原型如下：1protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 在参数中，widthMeasureSpec和heightMeasureSpec都为int，但是每个int都包含着两个信息，分别是尺寸和测量模式，一般情况下，int是32位的，Android把其中的30位用做尺寸大小存储，2bit用做测量模式存储。 2bit来存测量模式信息，也就是最多有4种模式，Android提供了3种测量模式，如下： 测量模式 说明 UNSPECIFIED 父容器没有对当前View有任何限制，当前View可以任意取尺寸 极少用 EXACTLY 父布局要求的精确尺寸，必须用这个尺寸作为View尺寸 AT_MOST 父布局给予View最大的尺寸，当前的View能取的尺寸为这个 测量模式和实际布局应用的属性值的关系： match_parent -&gt; EXACTLY wrap_content -&gt; AT_MOST 指定尺寸 -&gt; EXACTLY 如何获取widthMeasureSpec和heightMeasureSpec中的测量模式和尺寸大小？Android库中提供了两个方法，用来提取这两个信息，其实现细节就是进行了位运算，将前2-bit当做测量模式，后30-bit作为尺寸大小。12int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec); 重写onMeasure方法示例：1234567891011121314151617181920212223242526272829303132333435363738private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; &#125; case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size //我们将大小取最大值,你也可以取其他值 mySize = size; break; &#125; case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它 mySize = size; break; &#125; &#125; return mySize;&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height);//设置测量尺寸&#125; 完成自定义类的继承拓展后，就可以使用该View了，在xml布局文件中使用：1234&lt;[package name].MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#ff0000&quot; /&gt; 拓展onDraw()onDraw方法用于绘制效果图，super类默认提供了Canvas对象，其具备基本的绘图功能，比如绘制背景颜色、背景图片等，可以直接使用。 若是在上面的onMeasure例子上，在正方形的基础上画圆，可以重写onDraw方法为如下：1234567891011121314@Override protected void onDraw(Canvas canvas) &#123; //调用父View的onDraw函数，因为View这个类帮我们实现了一些 // 基本的而绘制功能，比如绘制背景颜色、背景图片等 super.onDraw(canvas); int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了 int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径 int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径 Paint paint = new Paint(); paint.setColor(Color.GREEN); canvas.drawCircle(centerX, centerY, radius, paint); &#125; 自定义布局属性可以在res/values/styles.xml文件中定义自己的属性（或者新建attr.xml文件），在需要用户来指定某些属性的值的时候，这个是很有用的。 示例：12345678&lt;resources&gt; &lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt; &lt;declare-styleable name=&quot;MyView&quot;&gt; &lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt; &lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在xml布局文件中使用：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;[package name].MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; hc:default_size=&quot;100dp&quot; /&gt;&lt;/LinearLayout&gt; 在Java文件中解析获取该属性的值：1234567891011121314private int defalutSize; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签 //即属性集合的标签，在R文件中名称为R.styleable+name TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView); //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称 //第二个参数为，如果没有设置这个属性，则设置的默认的值 defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100); //最后记得将TypedArray对象回收 a.recycle(); &#125; 自定义View完整示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example.linzh.myview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;/** * Created by linzh on 2017/3/28. */public class MyView extends View &#123;//继承View至少实现两个构造方法 private int defaultSize; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签 //即属性集合的标签，在R文件中名称为R.styleable+name TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView); //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称 //第二个参数为，如果没有设置这个属性，则设置的默认的值 defaultSize = typedArray.getDimensionPixelSize(R.styleable.MyView_default_size, 100); typedArray.recycle();//回收 &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; //调用父View的onDraw函数，因为View这个类帮我们实现了一些 // 基本的而绘制功能，比如绘制背景颜色、背景图片等 super.onDraw(canvas); int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了 int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径 int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径 Paint paint = new Paint(); paint.setColor(Color.GREEN); canvas.drawCircle(centerX, centerY, radius, paint); &#125; private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED://如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST://如果测量模式是最大取值为size 类似于wrap_content mySize = size;//这里把值去最大，也可以取其他值 break; case MeasureSpec.EXACTLY://如果是固定大小，拿就不要去改变它， 类似于match_parent mySize = size; break; &#125; return mySize; &#125;&#125; 自定义ViewGroupViewGroup是一到多个View的容器，ViewGroup多大也是要测量好的，而且要根据View来测量。 重写onMeasure逐个测量View的大小，并且设定ViewGroup的大小：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; //如果宽高都是包裹内容 if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; /*** * 获取子View中宽度最大的值 */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) maxWidth = childView.getMeasuredWidth(); &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125; 重写onLayout自定义ViewGroup，重写onLayout方法是有用的，在此方法我们将View逐个摆放到设定好大小的ViewGroup中：123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); //记录当前的高度位置 int curHeight = t; //将子View逐个摆放 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); int height = child.getMeasuredHeight(); int width = child.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 child.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125;&#125; 完成Java代码的定制，即可在xml布局文件中使用：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.example.linzh.myview.MyViewGroup android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ff9900&quot;&gt; &lt;Button android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:layout_width=&quot;50dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;/com.example.linzh.myview.MyViewGroup&gt; &lt;com.example.linzh.myview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; linzh:default_size=&quot;100dp&quot;/&gt;&lt;/LinearLayout&gt; 自定制ViewGroup完成示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.linzh.myview;import android.content.Context;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;/** * Created by linzh on 2017/3/28. */public class MyViewGroup extends ViewGroup &#123;//至少实现两个Super类的构造器 public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子view，当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//如果宽高都是包裹内容 //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); int curHeight = t;//记录当前的高度位置 for (int i = 0; i &lt; count; i++) &#123;//将View逐个摆放 View view = getChildAt(i); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 view.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125; &#125; /** * 获取子View中宽度最大的值 * @return */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) &#123; maxWidth = childView.getMeasuredWidth(); &#125; &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125;&#125; 参考 Android API指南 Custom Components 自定义View，有这一篇就够了","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android自定义View和ViewGroup","date":"2017-05-25T18:05:33.000Z","path":"2017/05/26/android-view-def/","text":"Android自定义View和ViewGroup Android中提供了丰富、复杂的视图系统，widget类的组件：Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner都是直接或间接继承于super类View，布局类：LinearLayout, FrameLayout, RelativeLayout等则继承于ViewGroup， ViewGroup则继承于View。 所以，要设计构建自己的视图或者布局，就要去继承View或者ViewGroup。本文从使用的角度来总结自定制View和ViewGroup。 自定义View自定义View，最基本的就是继承Android提供的基本视图类View。自定义步骤： 自定义View的属性 编写attr.xml文件 在layout布局文件中引用，同时引用命名空间 在View的构造方法中获得我们自定义的属性，在自定义控件中进行读取（构造方法拿到attr.xml文件值） 重写onMesure 重写onDraw 12345678910111213141516171819public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125;&#125; 继承了View类，还需要重写2个以上的构造方法（以上示例为常用重写构造方法）和onMeasure(), onDraw()方法，在View继承中，onLayout()是非必须的。 拓展onMeasure()自定义View都要自己来测量控制宽高尺寸，算出自己需要占用多大的面积。我们常在xml布局文件中用match_parent和wrap_content，这两属性都是依赖于父布局的，没有父布局就没法正确定位宽高。 这里存在一个疑问，就是如果我们在activity_main.xml中的代码如下，layout_width和layout_height指定的值也都为match_parent，其父布局又在哪呢？123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/main_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; 我们在MainActivity.java中进行测试：123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private LinearLayout linearLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); linearLayout = (LinearLayout)findViewById(R.id.main_layout); LayoutInflater layoutInflater = LayoutInflater.from(this); View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null); linearLayout.addView(buttonLayout); ViewParent viewParent = linearLayout.getParent();//获取父布局的名字 Log.d(&quot;MainActivity&quot;, &quot;The parent of main linear layout is &quot; + viewParent); &#125;&#125; 运行以上App，可以在logcat中打印出如下信息：1The parent of main linear layout is android.support.v7.widget.ContentFrameLayout&#123;2ef2e36 V.E...... ......I. 0,0-0,0 #1020002 android:id/content&#125; 注：以上运行API level 为25 从logcat的信息可知，我们在每个xml文件的布局的最外层，Android还自动帮我们加了一个FrameLayout/ContentFrameLayout，在自动嵌套的父布局里，有一部分是content，就是默认放label的地方，对应setContentView方法，在此之下才是我们自己定义的布局文件的内容。 onMeasure方法的原型如下：1protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 在参数中，widthMeasureSpec和heightMeasureSpec都为int，但是每个int都包含着两个信息，分别是尺寸和测量模式，一般情况下，int是32位的，Android把其中的30位用做尺寸大小存储，2bit用做测量模式存储。 2bit来存测量模式信息，也就是最多有4种模式，Android提供了3种测量模式，如下： 测量模式 说明 UNSPECIFIED 父容器没有对当前View有任何限制，当前View可以任意取尺寸 极少用 EXACTLY 父布局要求的精确尺寸，必须用这个尺寸作为View尺寸 AT_MOST 父布局给予View最大的尺寸，当前的View能取的尺寸为这个 测量模式和实际布局应用的属性值的关系： match_parent -&gt; EXACTLY wrap_content -&gt; AT_MOST 指定尺寸 -&gt; EXACTLY 如何获取widthMeasureSpec和heightMeasureSpec中的测量模式和尺寸大小？Android库中提供了两个方法，用来提取这两个信息，其实现细节就是进行了位运算，将前2-bit当做测量模式，后30-bit作为尺寸大小。12int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec); 重写onMeasure方法示例：1234567891011121314151617181920212223242526272829303132333435363738private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; &#125; case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size //我们将大小取最大值,你也可以取其他值 mySize = size; break; &#125; case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它 mySize = size; break; &#125; &#125; return mySize;&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height);//设置测量尺寸&#125; 完成自定义类的继承拓展后，就可以使用该View了，在xml布局文件中使用：1234&lt;[package name].MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#ff0000&quot; /&gt; 拓展onDraw()onDraw方法用于绘制效果图，super类默认提供了Canvas对象，其具备基本的绘图功能，比如绘制背景颜色、背景图片等，可以直接使用。 若是在上面的onMeasure例子上，在正方形的基础上画圆，可以重写onDraw方法为如下：1234567891011121314@Override protected void onDraw(Canvas canvas) &#123; //调用父View的onDraw函数，因为View这个类帮我们实现了一些 // 基本的而绘制功能，比如绘制背景颜色、背景图片等 super.onDraw(canvas); int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了 int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径 int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径 Paint paint = new Paint(); paint.setColor(Color.GREEN); canvas.drawCircle(centerX, centerY, radius, paint); &#125; 自定义布局属性可以在res/values/styles.xml文件中定义自己的属性（或者新建attr.xml文件），在需要用户来指定某些属性的值的时候，这个是很有用的。 示例：12345678&lt;resources&gt; &lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt; &lt;declare-styleable name=&quot;MyView&quot;&gt; &lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt; &lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在xml布局文件中使用：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;[package name].MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; hc:default_size=&quot;100dp&quot; /&gt;&lt;/LinearLayout&gt; 在Java文件中解析获取该属性的值：1234567891011121314private int defalutSize; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签 //即属性集合的标签，在R文件中名称为R.styleable+name TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView); //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称 //第二个参数为，如果没有设置这个属性，则设置的默认的值 defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100); //最后记得将TypedArray对象回收 a.recycle(); &#125; 自定义View完整示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example.linzh.myview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;/** * Created by linzh on 2017/3/28. */public class MyView extends View &#123;//继承View至少实现两个构造方法 private int defaultSize; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签 //即属性集合的标签，在R文件中名称为R.styleable+name TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView); //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称 //第二个参数为，如果没有设置这个属性，则设置的默认的值 defaultSize = typedArray.getDimensionPixelSize(R.styleable.MyView_default_size, 100); typedArray.recycle();//回收 &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; setMeasuredDimension(width, height); &#125; @Override protected void onDraw(Canvas canvas) &#123; //调用父View的onDraw函数，因为View这个类帮我们实现了一些 // 基本的而绘制功能，比如绘制背景颜色、背景图片等 super.onDraw(canvas); int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了 int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径 int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径 Paint paint = new Paint(); paint.setColor(Color.GREEN); canvas.drawCircle(centerX, centerY, radius, paint); &#125; private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED://如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST://如果测量模式是最大取值为size 类似于wrap_content mySize = size;//这里把值去最大，也可以取其他值 break; case MeasureSpec.EXACTLY://如果是固定大小，拿就不要去改变它， 类似于match_parent mySize = size; break; &#125; return mySize; &#125;&#125; 自定义ViewGroupViewGroup是一到多个View的容器，ViewGroup多大也是要测量好的，而且要根据View来测量。 重写onMeasure逐个测量View的大小，并且设定ViewGroup的大小：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; //如果宽高都是包裹内容 if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; /*** * 获取子View中宽度最大的值 */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) maxWidth = childView.getMeasuredWidth(); &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125; 重写onLayout自定义ViewGroup，重写onLayout方法是有用的，在此方法我们将View逐个摆放到设定好大小的ViewGroup中：123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); //记录当前的高度位置 int curHeight = t; //将子View逐个摆放 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); int height = child.getMeasuredHeight(); int width = child.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 child.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125;&#125; 完成Java代码的定制，即可在xml布局文件中使用：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.example.linzh.myview.MyViewGroup android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ff9900&quot;&gt; &lt;Button android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:layout_width=&quot;50dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;/com.example.linzh.myview.MyViewGroup&gt; &lt;com.example.linzh.myview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; linzh:default_size=&quot;100dp&quot;/&gt;&lt;/LinearLayout&gt; 自定制ViewGroup完成示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.linzh.myview;import android.content.Context;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;/** * Created by linzh on 2017/3/28. */public class MyViewGroup extends ViewGroup &#123;//至少实现两个Super类的构造器 public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子view，当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//如果宽高都是包裹内容 //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); int curHeight = t;//记录当前的高度位置 for (int i = 0; i &lt; count; i++) &#123;//将View逐个摆放 View view = getChildAt(i); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 view.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125; &#125; /** * 获取子View中宽度最大的值 * @return */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) &#123; maxWidth = childView.getMeasuredWidth(); &#125; &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125;&#125; 参考 Android API指南 Custom Components 自定义View，有这一篇就够了","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的数据储存","date":"2017-05-25T18:04:00.000Z","path":"2017/05/26/android-data-save/","text":"Android的数据存储与共享 Android提供了多种数据储存与共享的方式，其中文件存储、SharedPreferences、数据库等只能用于当前应用程序中，而Content Provider不仅可以在应用程序内部进行数据存储和共享，还可以跨程序数据共享，而且是更加安全可靠的。 文件存储文件存储数据是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。 文件储存是不可以包含文件目录的，默认存储在/data/data//files下。 写操作使用Context的openFileOutput()方法，有两个参数： 文件名 文件操作模式 默认为MODE_PRIVATE，表示当指定文件名的时候，所写入内容覆盖源文件内容。还可以指定MODE_APPEND模式，即表示源文件存在的时候追加内容，不存在的时候创建 MODE_WORLD_READAVLE和MODE_WORLD_WRITEABLE模式已被弃用，使用存在风险 demo:123456789101112131415161718String data = &quot;Data to save&quot;;FileOutputStream out = null;BufferWriter writer = null;try &#123; out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); writer = new BufferWriter(new OutputStreamWriter(out)); writer.write(data);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 读操作使用Context的openFileInput()方法，接收一个文件名字符串参数。 demo:1234567891011121314151617181920212223FileInputStream in = null;BufferReader reader = null;StringBuffer content = new StringBuffer();try &#123; in = openFileInput(&quot;data&quot;); reader = new BufferWirter(new InputStreamWriter(in)); String line = &quot;&quot;; while ((line = reader.readLine() != null) &#123; content.append(line); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (reader != null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;System.out.println(content.toString()); SharedPreferencesSharedPreferences是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据以键值对的形式存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。 SharedPreferences的默认文件位置是/data/data//shared_prefs/，Android提供了3种用于获取SharedPreferences对象的方法。 Context.getSharedPreferences() 此方法接收两个参数，第一个为文件名，不存在就创建。第二个参数为操作模式，Android6.0开始只有一个默认操作模式，为MODE_PRIVATE，也就是指定为0。 Activity.getPreferences() 这个方法是getSharedPreferences()方法的特殊形式，只有一个操作模式参数，文件名自动设置为当前活动类名。 PreferenceManager.getDefaultSharedPreferences() 这是一个静态方法，接收一个Context参数，并自动使用当前应用程序的报名作为前缀来命名SharedPreference文件。 存储数据步骤首选根据以上三种方法中的一种获取SharedPreferences对象，然后： 调用SharedPreferences.edit()方法获取一个SharedPreferences.Editor对象； 想SharedPreferences.Editor对象添加数据，以putXXX的形式； 调用apply()方法将添加的数据提交完成保存。 demo:12345SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();editor.putString(&quot;name&quot;, &quot;Tom&quot;);editor.putInt(&quot;age&quot;, 28);editor.putBoolean(&quot;married&quot;, false);editor.apply(); 读取数据demo:1234SharedPreferences pref = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);String name = pref.getString(&quot;name&quot;, &quot;&quot;);//第二参数为键没有对应的值时会以这个参数的数据返回int age = pref.getInt(&quot;age&quot;, 0);boolean married = pref.getBoolean(&quot;married&quot;, false); SQLiteSQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。 Android提供了一个抽象类，SQLiteOpenHelper帮助类来更加方便地管理数据库，借助这个类可以轻松地对数据库进行创建和升级。 SQLiteOpenHelper抽象类有两个抽象方法： onCreate() onUpgrade() 另外还提供了两个实例方法： getReadableDataBase() getWritableDatavase() 这两个方法都可以创建或者打开一个现有的数据库，没有则创建，并返回一个可对数据库进行读写操作的对象。若磁盘已满，则R方法只能读，W方法则会抛出异常。 SQLiteOpenHelper提供了两个可重写构造方法：12public SQLiteOpenHelper(Context context, String name, CursorFactory factory, int version)public SQLiteOpenHelper(Context context, String name, CursorFactory factory, int version,DatabaseErrorHandler errorHandler) 参数： context name 数据库名 默认存放在/dat/data//databases/ factory 查询数据返回的Cursor，一般为null version 数据库版本号，可用于升级数据库 执行数据库语句：1db.execSQL(string); 实现模板：123456789101112131415161718192021222324252627public class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK = &quot;create table Book (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;author text, &quot; + &quot;price real, &quot; + &quot;pages integer, &quot; + &quot;name text)&quot;; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 创建数据库12MyDatabaseHelper dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 1);dbHelper.getWritableDatabase(); 升级数据库123456789101112131415161718192021public static final String CREATE_CATEGORY = &quot;create table Category (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;category_name text, &quot; + &quot;category_code integer)&quot;; @Overridepublic void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show();&#125;@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;drop table if exists Book&quot;); db.execSQL(&quot;drop table if exists Category&quot;); onCreate(db);&#125;MyDatabaseHelper dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2);dbHelper.getWritableDatabase(); 添加数据123456789101112131415SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();// 开始组装第一条数据values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 454);values.put(&quot;price&quot;, 16.96);db.insert(&quot;Book&quot;, null, values); // 插入第一条数据values.clear();// 开始组装第二条数据values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 510);values.put(&quot;price&quot;, 19.95);db.insert(&quot;Book&quot;, null, values); // 插入第二条数据 更新数据1234SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(&quot;price&quot;, 10.99);db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] &#123; &quot;The Da Vinci Code&quot; &#125;); 删除数据12SQLiteDatabase db = dbHelper.getWritableDatabase();db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[] &#123; &quot;500&quot; &#125;); 查询数据1234567891011121314151617SQLiteDatabase db = dbHelper.getWritableDatabase();// 查询Book表中所有的数据Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null);if (cursor.moveToFirst()) &#123; do &#123; // 遍历Cursor对象，取出数据并打印 String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;)); double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;)); Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author); Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages); Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price); &#125; while (cursor.moveToNext());&#125;cursor.close(); Content ProviderContent Provider是Android的四大组件之一，主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。 内容提供器有两种用法： 使用现用内容提供器来读取或者操作相应程序中的数据 创建自己的内容提供器供程序使用的外部接口 访问内容提供器共享数据，必须使用Context.getContentResolver()静态方法获取ContentResolver对象实例来进行数据的CRUD操作。 insert() delete() query() update() 不同于数据库，内容提供器的访问是安全的，其需要提供一个指定的uri才能够访问。 访问现有内容提供器查询现有的联系人内容提供器demo：123456789101112131415161718192021List&lt;String&gt; contactsList = new ArrayList&lt;&gt;();Cursor cursor = null;try &#123; // 查询联系人数据 cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; // 获取联系人姓名 String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); // 获取联系人手机号 String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); contactsList.add(displayName + &quot;\\n&quot; + number); &#125; &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; if (cursor != null) &#123; cursor.close(); &#125;&#125; 定制内容提供器创建自己的内容提供器，需要去继承抽象类ContentProvider，并实现6个抽象方法，以下为模板：12345678910111213141516171819202122232425262728293031public class MyProvider extends ContentProvider &#123; @Overrride public boolean onCreate() &#123; return fasle; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; return null; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125;&#125; 参数说明： 返回值boolean 创建是否成功 projection 用于确定查询哪些列 selection和selectionArgs用于约束查询哪些行 sortOder 用于对结果进行排序 Cursor查询结果对象 getType返回相应的MIME类型 Uri通配符 *：表示匹配任意长度的任意字符 #：表示匹配任意长度的数字 demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM); uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR); uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM); &#125; @Override public boolean onCreate() &#123; dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // 查询数据 SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] &#123; bookId &#125;, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;, null, null, sortOrder); break; default: break; &#125; return cursor; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // 添加数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert(&quot;Book&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert(&quot;Category&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId); break; default: break; &#125; return uriReturn; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // 更新数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); int updatedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] &#123; bookId &#125;); break; case CATEGORY_DIR: updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;); break; default: break; &#125; return updatedRows; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // 删除数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] &#123; bookId &#125;); break; case CATEGORY_DIR: deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;); break; default: break; &#125; return deletedRows; &#125; @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.book&quot;; case CATEGORY_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.category&quot;; case CATEGORY_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.category&quot;; &#125; return null; &#125;&#125; 网络存储","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android的BLE简易收发助手","date":"2017-04-30T03:41:48.000Z","path":"2017/04/30/ble-helper/","text":"Android简易蓝牙BLE收发助手 本文参考Android开发者说明文档，通过制作一个简易的BLE收发助手，和外置BLE模块进行通信，来学习Android的BLE开发基础知识。 GitHub源码：Android简易BLE收发助手、Android官方BluetoothLeGatt源码 前言从Android4.3（API 18）开始，Android开始支持低功耗蓝牙（Bluetooth Low Energy, BLE）功能，也就是Bluetooth 4.0版本，相比之前的蓝牙功能，BLE最显著的特点是功耗更低。基于Android系统API开发的App，可以通过BLE查找其他设备、查询服务、读写特征值（Characterstic）。现在BLE已基本取代了旧版本的蓝牙，特别是现在嵌入式设备（智能手表手环、无线耳机等）越来越多，基本用的都是BLE。最近蓝牙协议已经升级到5.0版本，效率等大幅度提高。目前三星S8和小米6已支持蓝牙5.0。 准备抽象概念在进行开发之前，需要对蓝牙协议栈的构架有一定的了解，特别是一些关键性名词。可以参考笔者简陋的总结：BLE协议栈简析。 BLE协议栈有三个层次，分别是物理层Controller、主机协议封装Host、应用Apps。 三个层次中，对于开发来说比较重要的是Host，里面主要包含： ATT（Attibute Protocal） 属性协议，是BLE通信的基础，ATT封装数据，向外暴露为“属性”，提供“属性”的为服务端，读取“属性”的为客户端。 GATT（Generic Attribute Profile） 通用属性配置文件，建立在ATT的基础上，对ATT做进一步的逻辑封装，定义数据的交互方式和含义。每个GATT里面包含3个层次：服务（service）、特征（Characteristic）、描述（Descriptor）。 GAP（Generic Access Profile） 停用访问控制配置文件。它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。 GATT最外层是Profile配置文件，里面又包含了服务（service）、特征（Characteristic）、描述（Descriptor），他们之间的关系是一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。 GATT里面包含的服务、特征和描述都是多个的，BLE通过UUID来标识区分。 UID 是全球唯一标识符，它是 128bit 的值，为了便于识别和阅读，一般写成8-4-4-12 的16进制形式。如123e4567-e89b-12d3-a456-426655440000。16-bit的蓝牙基本UUID形式为 0000XXXX-0000-1000-8000-00805f9b34fb。实际UUID为128位，但是除了XXXX部分需要更改，其他的基本一致，这样对于BLE的数据非常受限的设备使用起来更加方便。Android中为了避免UUID的冲突，可以使用UUID.randomUUID()方法来生成一个随机的UUID。 外设模块笔者在完成低功耗蓝牙收发助手的程序测试的时候，采用的BLE透传模块为CC2541（可在某宝上搜索），基于蓝牙4.0，对于玩单片机或者嵌入式的爱好者来说，这个是很常见的，可以用于蓝牙小车，小四轴飞行器等小智能硬件设备。 在透传模块给出的AT指令集里，指明了可以通过串口助手向BLE模块发送AT指令12345678910## 开发正文先看一下简易的主界面图![image](http://linzhs.cn/img/ble_helper_main_activity.png) 。主界面中上半部分为数据的接收区，下半部分为发送数据编辑框，发送按钮（其实应该加入字符和hex格式的数据接收或发送方式的选择的）。点击工具单栏上的菜单选项可进行蓝牙设备搜索和连接。程序的运行思路是：主界面启动的时候，去建立自定义BLE后台服务链接，服务和MainActivity之间通过Broadcast来通信，所以还需要在MainActivity的生命周期中注册、BroadcastReceiver。完成服务、广播、界面的初始化工作后，点击链接BLE设备启动ScanActivity来搜索蓝牙设备，将识别到的外设（当前只能识别Android以外的BLE模块）显示在Activity的RecyclerView中，若点击其中一个蓝牙，则自动获取BLE的名称地址，然后退出扫描活动，将BLE的名称和地址返回主活动建立链接，接下来根据主界面的命令，向后台蓝牙服务发出读写Characteristic操作来完成与外部设备的通信，这个读写操作中需要用到UUID。Android使用BLE需要开启以下两个权限： 12MainActivity中建立、断开绑定BLE服务，注册、注销通信广播： @Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // initial View... //绑定BLE收发服务 Intent gattServiceIntent = new Intent(this, BluetoothLeService.class); bindService(gattServiceIntent, mServiceConnection, BIND_AUTO_CREATE); } @Overrideprotected void onResume() { super.onResume(); //注册BLE收发服务广播接收器mGattUpdateReceiver registerReceiver(mGattUpdateReceiver, makeGattUpdateIntentFilter()); if (mBluetoothLeService != null) { Log.d(TAG, &quot;onResume: mBluetoothLeService NOT null&quot;); } } @Overrideprotected void onPause() { super.onPause(); //注销BLE收发服务广播接收器 unregisterReceiver(mGattUpdateReceiver); } @Overrideprotected void onDestroy() { super.onDestroy(); //解绑BLE收发服务 unbindService(mServiceConnection); mBluetoothLeService = null; }12后台BluetoothLeService连接后的回调和广播通信接受者： // Code to manage Service lifecycle.// 管理BLE数据收发服务整个生命周期private final ServiceConnection mServiceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mBluetoothLeService = ((BluetoothLeService.LocalBinder) service).getService(); if (!mBluetoothLeService.initialize()) { Log.e(TAG, “onServiceConnected: Unable to initialize Bluetooth”); finish(); } } @Override public void onServiceDisconnected(ComponentName name) { mBluetoothLeService = null; } }; // Handles various events fired by the Service.// ACTION_GATT_CONNECTED: connected to a GATT server.// ACTION_GATT_DISCONNECTED: disconnected from a GATT server.// ACTION_GATT_SERVICES_DISCOVERED: discovered GATT services.// ACTION_DATA_AVAILABLE: received data from the device. This can be a result of read// or notification operations.// 定义处理BLE收发服务的各类事件接收机mGattUpdateReceiver，主要包括下面几种：// ACTION_GATT_CONNECTED: 连接到GATT// ACTION_GATT_DISCONNECTED: 断开GATT// ACTION_GATT_SERVICES_DISCOVERED: 发现GATT下的服务// ACTION_DATA_AVAILABLE: BLE收到数据private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final String action = intent.getAction(); if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) { mConnected = true; } else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) { mConnected = false; } else if (BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) { // Show all the supported services and characteristics on the user interface. // 获得所有的GATT服务，对于BLE透传模块，包括GAP（General Access Profile）， // GATT（General Attribute Profile），还有Unknown（用于数据读取） mBluetoothLeService.getSupportedGattServices(); } else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) { bleReceiveText.setText(intent.getStringExtra(BluetoothLeService.EXTRA_DATA)); } } } };1234广播中有四种隐式意图，都是在BluetoothLeService，也就是自定义后台服务中定义的，分别为链接到GATT、断开GATT、搜索到GATT服务、BLE收到数据，根据四个不同的广播状态来完成相应的标志位或者显示操作。以上的工作只是初始化，还需要建立扫描蓝牙的界面操作工作，选择菜单栏上的选项，来完成蓝牙的连接和断开。 @Overridepublic boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.menu_connect_ble: if (!mConnected) {// 若未连接蓝牙，则进入蓝牙扫描连接activity Intent serverIntent = new Intent(this, DeviceScanActivity.class); startActivityForResult(serverIntent, REQUEST_CONNECT_DEVICE); } else { mBluetoothLeService.disconnect(); } break; } return true; } @Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { case REQUEST_CONNECT_DEVICE: if (resultCode == Activity.RESULT_OK) { // 获取准备建立连接的蓝牙设备地址和名字 mDeviceName = data.getExtras().getString(EXTRAS_DEVICE_NAME); mDeviceAddress = data.getExtras().getString(EXTRAS_DEVICE_ADDRESS); Log.i(TAG, &quot;onActivityResult: &quot; + &quot;mDeviceName: &quot; + mDeviceName + &quot;, mDeviceAddress:&quot; + mDeviceAddress); //连接该BLE模块 if (mBluetoothLeService != null) { final boolean result = mBluetoothLeService.connect(mDeviceAddress); Log.d(TAG, &quot;onActivityResult: Connect request result = &quot; + result); } } break; default: break; } }12蓝牙设备的扫描工作都放置在DeviceScanActivity中，从主活动切换到这个活动中，在完成前台显示前，先完成Android设备的蓝牙检测和初始化工作，在onPause中还需要去检查Android是否还在进行扫描，若是则关闭扫描操作，整个生命周期的操作: @Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_device_scan); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) { actionBar.setTitle(&quot;Scan Bluetooth Device&quot;); actionBar.setDisplayHomeAsUpEnabled(true); } // Initializes recycler view adapter. RecyclerView recyclerView = (RecyclerView)findViewById(R.id.le_device_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); mLeDeviceListAdapter = new LeDeviceListAdapter(); recyclerView.setAdapter(mLeDeviceListAdapter); mLeDeviceListAdapter.setOnItemClickListener(new LeDeviceListAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { final BluetoothDevice device = mLeDeviceListAdapter.getDevice(position); if (device == null) return; final Intent intent = new Intent(); intent.putExtra(MainActivity.EXTRAS_DEVICE_NAME, device.getName()); intent.putExtra(MainActivity.EXTRAS_DEVICE_ADDRESS, device.getAddress()); if (isScanning) { mBluetoothLeScanner.stopScan(mLeScanCallback); //mBluetoothAdapter.stopLeScan(mLeScanCallback); isScanning = false; } Log.d(TAG, &quot;onItemClick: start bluetooth control activity.&quot;); //设置返回值并结束程序 setResult(RESULT_OK, intent); finish(); } }); mHandler = new Handler(); // Use this check to determine whether BLE is supported on the device. Then you can // selectively disable BLE-related features. if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) { Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish(); } // Initializes a Bluetooth adapter. For API level 18 and above, get a reference to // BluetoothAdapter through BluetoothManager. final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bluetoothManager.getAdapter(); // Checks if Bluetooth is supported on the device. if (mBluetoothAdapter == null) { Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish(); return; } } @Overrideprotected void onResume() { super.onResume(); // Ensures Bluetooth is enabled on the device. If Bluetooth is not currently enabled, // fire an intent to display a dialog asking the user to grant permission to enable it. if (!mBluetoothAdapter.isEnabled()) { if (!mBluetoothAdapter.isEnabled()) { Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } } mBluetoothLeScanner = mBluetoothAdapter.getBluetoothLeScanner();//获取蓝牙扫描器实例 scanLeDevice(true); } @Overrideprotected void onPause() { super.onPause(); scanLeDevice(false); mLeDeviceListAdapter.clear(); }1234BLE的扫描从API21 开始就不太一样了，之前使用BluetoothAdapter.startLeScan和BluetoothAdapter.stopLeScan来完成，API21开始弃用这两个方法，改成由```BluetoothAdapter.getBluetoothLeScanner()```来获取BLE扫描器，用这个对象来完成扫描的工作。扫描方法和扫描结果回调： //扫描蓝牙设备private void scanLeDevice(final boolean enable) { if (enable) {//使能扫描 //将Runnable接口对象装入消息队列(message queue)每隔一段时间(SCAN_PERIOD)执行Runnable的run方法 mHandler.postDelayed(new Runnable() { @Override public void run() {//循环周期到，标志位复位，关闭扫描 isScanning = false; mBluetoothLeScanner.stopScan(mLeScanCallback); //mBluetoothAdapter.stopLeScan(mLeScanCallback);//此方法API21开始已被弃用 invalidateOptionsMenu(); } }, SCAN_PERIOD); isScanning = true; mBluetoothLeScanner.startScan(mLeScanCallback); //mBluetoothAdapter.startLeScan(mLeScanCallback); } else {//关闭扫描 isScanning = false; mBluetoothLeScanner.stopScan(mLeScanCallback); //mBluetoothAdapter.stopLeScan(mLeScanCallback); } invalidateOptionsMenu(); } // 扫描结果回调private ScanCallback mLeScanCallback = new ScanCallback() { @Override public void onScanResult(int callbackType, ScanResult result) {//扫描结果 //super.onScanResult(callbackType, result); final BluetoothDevice device = result.getDevice(); runOnUiThread(new Runnable() { @Override public void run() { mLeDeviceListAdapter.addDevice(device); //刷新RecyclerView mLeDeviceListAdapter.notifyDataSetChanged(); } }); } @Override public void onBatchScanResults(List&lt;ScanResult&gt; results) {//批量结果 super.onBatchScanResults(results); } @Override public void onScanFailed(int errorCode) {//扫描失败 super.onScanFailed(errorCode); } };123## BLE后台服务UUID的设置： //用于数据接收、发送的service和character对应的UUID，由改ble透传模块决定public final static UUID UUID_NOTIFY = UUID.fromString(“0000ffe1-0000-1000-8000-00805f9b34fb”);12BLE通信管理对象初始化： /** Initializes a reference to the local Bluetooth adapter.* @return Return true if the initialization is successful.*/public boolean initialize() { // For API level 18 and above, get a reference to BluetoothAdapter through // BluetoothManager. if (mBluetoothManager == null) { mBluetoothManager = (BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE); if (mBluetoothManager == null) { Log.e(TAG, &quot;initialize: Unable to initialize BluetoothManager&quot;); return false; } } mBluetoothAdapter = mBluetoothManager.getAdapter(); if (mBluetoothAdapter == null) { Log.e(TAG, &quot;initialize: Unable to obtain a BluetoothAdapter&quot;); return false; } return true;} 12建立BLE链接和断开链接： /** Connects to the GATT server hosted on the Bluetooth LE device.* @param address The device address of the destination device.* @return Return true if the connection is initiated successfully. The connection result is reported asynchronously through the {@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)} callback.*/public boolean connect(final String address) {if (mBluetoothAdapter == null || address == null) {Log.w(TAG, “connect: BluetoothAdapter not initialized or unspecified address”);return false;} // Previously connected device. Try to reconnect.if (mBluetoothDeviceAddress != null &amp;&amp; address.equals(mBluetoothDeviceAddress) &amp;&amp; mBluetoothGatt != null) {Log.d(TAG, “Trying to use an existing mBluetoothGatt for connection.”);if (mBluetoothGatt.connect()) { mConnectionState = STATE_CONNECTING; return true;} else { return false;}} final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);if (device == null) {Log.w(TAG, “Device not found. Unable to connect.”);return false;}// We want to directly connect to the device, so we are setting the autoConnect// parameter to false.mBluetoothGatt = device.connectGatt(this, false, mGattCallback);Log.d(TAG, “Trying to create a new connection.”);mBluetoothDeviceAddress = address;mConnectionState = STATE_CONNECTING; return true;} /** Disconnects an existing connection or cancel a pending connection. The disconnection result is reported asynchronously through the {@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)} callback.*/public void disconnect() { if (mBluetoothAdapter == null || mBluetoothGatt == null) { Log.w(TAG, &quot;BluetoothAdapter not initialized&quot;); return; } mBluetoothGatt.disconnect();} 12建立GATT服务后，数据、链接变动的回调，根据不同的回调结果，将要处理的信息以广播的形式发送给主活动： // Implements callback methods for GATT events that the app cares about. For example, // connection change and services discovered.private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() { @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { String intentAction; if (newState == BluetoothProfile.STATE_CONNECTED) { intentAction = ACTION_GATT_CONNECTED; mConnectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, &quot;Connected to GATT server.&quot;); // Attempts to discover services after successful connection. Log.i(TAG, &quot;Attempting to start service discovery:&quot; + mBluetoothGatt.discoverServices()); } else if (newState == BluetoothProfile.STATE_DISCONNECTED) { intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, &quot;Disconnected from GATT server.&quot;); broadcastUpdate(intentAction); } } @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); } else { Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status); } } @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } } @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } };12其中，需要携带接收到数据的广播如下，接收到的是byte数组，需要进行数据处理，这里将其装换为hex，十六进制。 /** 发送携带数据广播 @param action @param characteristic*/private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) { final Intent intent = new Intent(action); final byte[] data = characteristic.getValue();//读取BLE接收到的数据 if (data != null &amp;&amp; data.length &gt; 0) { final StringBuilder stringBuilder = new StringBuilder(data.length); for(byte byteChar : data) stringBuilder.append(String.format(&quot;%02X &quot;, byteChar)); intent.putExtra(EXTRA_DATA, new String(data) + &quot;\\n&quot; + stringBuilder.toString()); Log.i(TAG, &quot;broadcastUpdate: RX Data is &quot; + stringBuilder); } //intent.putExtra(EXTRA_DATA, data); sendBroadcast(intent);} 12发送数据到BLE外设，则是向Characteristic中写入数据，BLE会将其自动发出。 /** 写入数据到Characteristic 从BLE发送出去 @param data*/public void writeCharacteristic(byte[] data){ if (mBluetoothAdapter == null || mBluetoothGatt == null) { Log.w(TAG, &quot;BluetoothAdapter not initialized&quot;); return; } mNotifyCharacteristic.setValue(data); mBluetoothGatt.writeCharacteristic(mNotifyCharacteristic);}```","tags":[{"name":"Android,BLE","slug":"Android-BLE","permalink":"http://linzhs.cm/tags/Android-BLE/"}]},{"title":"BLE协议栈简析","date":"2017-04-30T03:36:45.000Z","path":"2017/04/30/ble-protocal/","text":"BLE协议栈简析 本文针对蓝牙4.0，也就是低功耗蓝牙BLE的协议栈进行简单分析。 Arch图以下为蓝牙协议栈架构图： 蓝牙协议栈分为三个层次，从底层到顶层的名字和其所起到的作用分别如下： Controller 这一层主要是物理层，定义了蓝牙工作的频段（2.4GHz）和频段的通道、广播等。Host层和Controller层之间有个接口层，这个接口建立了Host和Controller之间的交互，也是顶层的应用和芯片的交互关键通道。 Host 这一层相对比较复杂，包含了裸机链路控制、适配协议、安全管理、GATT、ATT、GAP等。 ATT（Attibute Protocal），属性协议，是BLE通信的基础，ATT封装数据，向外暴露为“属性”，提供“属性”的为服务端，读取“属性”的为客户端。 GATT（Generic Attribute Profile），通用属性配置文件，建立在ATT的基础上，对ATT做进一步的逻辑封装，定义数据的交互方式和含义。每个GATT里面包含3个层次：服务（service）、特征（Characteristic）、描述（Descriptor）。 GAP（Generic Access Profile），停用访问控制配置文件。它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。 Applications 这一层为BLE的应用层，可分为两大类，分别为基于连接和非连接。 基于非连接的也叫Beacon，依赖于BLE的广播，常用语BLE搜索其他设备。这里的BLE存在两种角色，发送广播方为Broadcaster，监听广播方为Observer。 基于连接的需要通过GATT连接来收发数据。这里的BLE也存在两种角色，分别是中心主机设备Central，和被连接的从机外设Peripheral。 GATT内部层次GATT内部抽象图： image GATT最外层是Profile配置文件，里面又包含了服务（service）、特征（Characteristic）、描述（Descriptor），他们之间的关系是一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。 UUIDService、Characteristic 还有 Descriptor 之间都是使用 UUID 唯一标识来区分的。 UID 是全球唯一标识符，它是 128bit 的值，为了便于识别和阅读，一般写成8-4-4-12 的16进制形式。如123e4567-e89b-12d3-a456-426655440000。 16-bit的蓝牙基本UUID形式为 0000XXXX-0000-1000-8000-00805f9b34fb。实际UUID为18位，但是除了XXXX部分需要更改，其他的基本一致，这样对于BLE的数据非常受限的设备使用起来更加方便。 Android中为了避免UUID的冲突，可以使用UUID.randomUUID()方法来生成一个随机的UUID。 16-bit的UUID数量只有65536个，数量远不如128-bit的，所以官方事先保留了一些UIID，若是16-bit的基本UUID不够用，可以选择购买。 参考文章 Android 上的低功耗蓝牙实践 GATT Profile 简介","tags":[{"name":"BLE","slug":"BLE","permalink":"http://linzhs.cm/tags/BLE/"}]},{"title":"Android中Activity的启动模式","date":"2017-04-20T17:16:52.000Z","path":"2017/04/21/android-activity-startmode/","text":"Android中Activity的启动模式在Android中，每一个任务（应用程序）都有一个放回栈（back stack），每一个应用都有一到多个Activity，返回栈就是来存储这些活动的，当Activity处于栈顶的时候，该Activity也是正显示在手机屏幕上的。若用户按下“返回”按钮后，一个Activity将会被弹出栈，也就等于被销毁，而前一个Activity也将被执行。返回栈中永远不会重新排序，而是根据入栈和出栈的顺序来排列的。 在没有设置Activity的启动模式的时候，栈是可以被重复创建的，比如一个应用有很多个Activity，这些Activity大部分都可以创建同一个Activity，那么每次创建都会被推入栈中，返回栈也就有了多次被实例化的Activity。 Activity和任务的默认行为如下： 当 Activity A 启动 Activity B 时，Activity A 将会停止，但系统会保留其状态（例如，滚动位置和已输入表单中的文本）。如果用户处于Activity B时按“返回”按钮，则Activity A将恢复其状态，继续运行。（活动与活动之间如何进行数据交流，活动怎么在一个应用程序的生命周期中保存好自己的关键数据，以防中途活动被销毁后，又要从头开始加载，丢失关键数据？这些问题将在另一篇随笔上做总结） 用户通过按下Home键按钮离开任务时，当前Activity将停止运行，并且任务会将入后台。系统将保留任务中的每个Activity的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务又会回到前台并恢复当前任务返回栈栈顶的Activity继续执行。 如果用户按“返回”按钮，则当前 Activity 会从堆栈弹出并被销毁。 堆栈中的前一个 Activity 恢复执行。销毁 Activity 时，系统不会保留该 Activity 的状态。 当前任务的Activity也可以被其他任务多次实例化。 自定义Activity的启动模式我们可以为每个Activity定义一种启动模式，注册的方法就是在AndroidManifest.xml文件声明时，为相应的Activity元素加上launchMode属性，并且指定该属性为如下一种： “standard”（默认标准模式） 这个标准模式是默认的启动模式。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。默认模式下的Activity可以被多次实例化，而且每个实例都可以属于不用的任务，并且一个任务可以拥有多个实例，举个例子，比如我们现在界面上有个按钮，点击按钮就会启动一个新的活动，这个活动是默认模式的，新的活动里也有一个按钮，这个新的按钮还是启动这个新的界面，所以每个当我们点击按钮后，同一个Activity将会多多次实例化，实例化了多少次，就要按下“返回”按钮来销毁多少次。 “singleTop” 在“singleTop”模式下，如果当前的任务的栈顶已经存在此种模式的Activity实例，那么系统会通过调用该实例的onNewIntent()方法向其传输intent，而不是创建Activity新的实例。也就是说，在“singleTop”模式下，如果活动位于栈顶，那么此活动只会被实例化一次，若不是在栈顶，那么还是会被多次实例化。 例如，假设任务的返回栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈是 A-B-C-D；D 位于顶部）。收到针对 D 类 Activity 的 Intent。如果 D 具有默认的 “standard” 启动模式，则会启动该类的新实例，且堆栈会变成 A-B-C-D-D。但是，如果 D 的启动模式是 “singleTop”，则 D 的现有实例会通过 onNewIntent() 接收 Intent，因为它位于堆栈的顶部；而堆栈仍为 A-B-C-D。但是，如果收到针对 B 类 Activity 的 Intent，则会向堆栈添加 B 的新实例，即便其启动模式为 “singleTop” 也是如此。 注：为某个 Activity 创建新实例时，用户可以按“返回”按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 onNewIntent() 之前，用户无法按“返回”按钮返回到 Activity 的状态。 “singleTask” 当前活动的模式如果是“singleTask”模式，拿每次启动该活动时系统首先会在返回栈中检查是否存在该实例，如果发现先已经存在则不会重新实例化，而是使用已经存在的，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，并把这个活动统统出栈，让这个活动处于栈顶，如果返回栈中没有该活动的实例，则会创建一个新的实例。 “singleInstance” “singleInstance”模式下的活动比较特别，该活动会被系统单独放在一个返回栈上去管理，这个活动在整个应用程序的生命里面只有一个实例，这个和单例模式很像了。在这种模式下，这个活动是共享的，也可以被其他应用程序调用。 动态设置Activity启动模式在程序中用startActivity()启动Activity的时候，可以在Intent中加入相应的标志来修改Activity与其他任务的默认关联方式。可用于修改的标志如下所示： FLAG_ACTIVITY_NEW_TASK 在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。这个状态与”singlTask”模式是一样的。 FLAG_ACTIVITY_SINGLE_TOP 如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。这种模式与“singleTop”模式一致。 FLAG_ACTIVITY_CLEAR_TOP 如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。 FLAG_ACTIVITY_CLEAR_TOP 通常与 FLAG_ACTIVITY_NEW_TASK 结合使用。一起使用时，通过这些标志，可以找到其他任务中的现有 Activity，并将其放入可从中响应 Intent 的位置。 清理返回栈如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。 当用户再次返回到任务时，仅恢复根 Activity。系统这样做的原因是，经过很长一段时间后，用户可能已经放弃之前执行的操作，返回到任务是要开始执行新的操作。 可以使用下列几个 Activity 属性修改此行为： alwaysRetainTaskState 如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。 clearTaskOnLaunch 如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。 finishOnTaskLaunch 此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android中Activity、Fragment、Service的生命周期","date":"2017-04-20T17:15:48.000Z","path":"2017/04/21/android-lifecycle/","text":"Android中Activity、Fragment、Service的生命周期 在Android系统中，常见的应用组件都有它的生命周期，以便于系统对内存的管理，接下来总结一下Activity，Fragment，Service这三个常见、重要的组件的生命周期。 Activity的生命周期用回调方法的方式来管理Activity的生命周期对于开发强大、灵活的应用来说那是至关重要的。Activity的生命周期会直接影响到其他Activity、其任务和返回栈。 Activity有三种状态存在： 运行状态 此时Activity处于屏幕的前台，可以与用户进行交互，具有用户焦点。 暂停状态 我们经常会遇到这种情况：屏幕上出现一个对话框，或者加载动画框，从屏幕下面弹出不会沾满屏幕的一个选项卡，而且在屏幕里面还能看到另一个界面。对于这种情况，另一个Activity位于屏幕前台并且具有用户焦点，但在背后的Activity仍然可见。也就是说，另一个Activity显示在此Activity的上方，并且Activity部分透明或者未被覆盖整个屏幕，我们把这个时候的Activity成为暂停状态。 暂停状态的Activity仍然处于完全活动的状态（Activity对象保留在内存中，它保留了所有状态和成员信息，并与窗口管理器 保持连接），但是这个状态的Activity在内存不足的时候，也会被系统终止并且回收。处于此状态的Activity一般不要做太多事情，在正常切换的时候如果有太多占用时间的任务完成，那么有可能会导致卡顿的情况，影响了用户体验。 停止状态 当一个Activity被另一个Activity完全覆盖的时候，也就进入了后台。已停止的 Activity 同样仍处于活动状态（Activity 对象保留在内存中，它保留了所有状态和成员信息，但未与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。 如果 Activity 处于暂停或停止状态，系统可通过要求其结束（调用其 finish() 方法）或直接终止其进程，将其从内存中删除。（将其结束或终止后）再次打开 Activity 时，必须重建。 生命周期对应的回调当一个Activity转入或者转出不同的状态的时候，会有相应的回调方法被调用，也就是向Activity发出通知。我们可以在不同的状态回调方法中加入不同的操作任务，来完成相应的行为，比如实例化的时候初始化一些信息，暂停或者停止状态的时候可能Activity会被销毁，在此状态做信息状态保留等。 以下框架 Activity 包括每一个基本生命周期方法：123456789101112131415161718192021222324252627282930313233public class ExampleActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // The activity is being created. // 在创建Activity的时候，这个回调必须重写 &#125; @Override protected void onStart() &#123; super.onStart(); // The activity is about to become visible. &#125; @Override protected void onResume() &#123; super.onResume(); // The activity has become visible (it is now &quot;resumed&quot;). &#125; @Override protected void onPause() &#123; super.onPause(); // Another activity is taking focus (this activity is about to be &quot;paused&quot;). &#125; @Override protected void onStop() &#123; super.onStop(); // The activity is no longer visible (it is now &quot;stopped&quot;) &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // The activity is about to be destroyed. &#125;&#125; onCreate() 首次创建Activity的时候调用（Activity被销毁后重建也是首次创建）。该回调方法传入一个Bundle对象，这个对象很重要，用于保存上一次Activity被创建后的状态。-&gt; onStart() onStart() 在Activity对用户可见之前被调用。如果Activity转入前台可见，则接下来调用onResume()，若是转入隐藏状态，则接下来调用onStop()。 onResume() 在 Activity 即将开始与用户进行交互之前调用。 此时，Activity 处于 Activity 堆栈的顶层，并具有用户输入焦点。-&gt; onPause() onPause() 当系统要去执行另一个Activity的时候被调用，此时Activity还处于可见的状态，不过已经有一些界面已被另一个Activity覆盖。此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。 它应该非常迅速地执行所需操作，因为它返回后，下一个 Activity 才能继续执行。 如果 Activity 返回前台，则后接 onResume()，如果 Activity 转入对用户不可见状态，则后接 onStop()。 onStop() 在 Activity 对用户不再可见时调用。如果 Activity 被销毁，或另一个 Activity（一个现有 Activity 或新 Activity）继续执行并将其覆盖，就可能发生这种情况。 如果 Activity 恢复与用户的交互，则后接 onRestart()，如果 Activity 被销毁，则后接 onDestroy()。 onRestart() 在 Activity 已停止并即将再次启动前调用。始终后接 onStart() onDestroy() 在 Activity 被销毁前调用。这是 Activity 将收到的最后调用。 当 Activity 结束（有人对 Activity 调用了 finish()），或系统为节省空间而暂时销毁该 Activity 实例时，可能会调用它。 您可以通过 isFinishing() 方法区分这两种情形。 这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环： 完整生命周期 在 onCreate() 调用与 onDestroy() 调用之间。 您的 Activity 应在 onCreate() 中执行“全局”状态设置（例如定义布局），并释放 onDestroy() 中的所有其余资源。例如，如果您的 Activity有一个在后台运行的线程，用于从网络上下载数据，它可能会在 onCreate() 中创建该线程，然后在 onDestroy() 中停止该线程。 可见生命周期 在 onStart() 调用与 onStop() 调用之间。 在这段时间，用户可以在屏幕上看到 Activity 并与其交互。 例如，当一个新 Activity 启动，并且此 Activity 不再可见时，系统会调用 onStop()。您可以在调用这两个方法之间保留向用户显示 Activity 所需的资源。 例如，您可以在 onStart() 中注册一个 BroadcastReceiver 以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop() 中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 onStart() 和 onStop()。 前台声明周期 在 onResume() 调用与 onPause() 调用之间。 在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。 实例：旋转屏幕Activity的生命周期变化（带保存状态）假设一开始是竖屏状态，旋转后为横屏。 横屏状态下：onCreate() -&gt; onStart() -&gt; onResume() 旋转屏幕：onSavaInstanceState() -&gt; onPause() -&gt; onStop() -&gt; onDestroy() - &gt;onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume() Fragment的生命周期管理片段生命周期与管理 Activity 生命周期很相似。和 Activity 一样，片段也以三种状态存在： 运行状态 片段在运行中的 Activity 中可见。 暂停状态 另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。 停止状态 片段不可见。宿主 Activity 已停止，或片段已从 Activity中移除，但已添加到返回栈。 停止片段仍然处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。同样与 Activity 一样，假使 Activity 的进程被终止，而需要在重建 Activity 时恢复片段状态，也可以使用 Bundle 保留片段的状态。可以在片段的 onSaveInstanceState() 回调期间保存状态，并可在 onCreate()、onCreateView() 或 onActivityCreated() 期间恢复状态。 Activity 生命周期与片段生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。 默认情况下，Activity 停止时会被放入由系统管理的 Activity返回栈（以便用户通过返回按钮回退到Activity，任务和返回栈对此做了阐述）。不过，仅当您在移除片段的事务执行期间通过调用 addToBackStack()显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。 在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似。 因此，管理 Activity 生命周期的做法同样适用于片段。 Fragment结合Activity的生命周期一起运行 onAttach() Fragment和Activity建立关联 onCreate() onCreateView() 调用它可创建与片段关联的视图层次结构 onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用 onStart() onResume() onPause() onStop() onDestroyView() 在移除与片段关联的视图层次结构时调用 onDestroy() onDetach() 在取消片段与 Activity 的关联时调用 Service的生命周期服务基本上分为两种形式： 启动 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 绑定 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 虽然本文档是分开概括讨论这两种服务，但是您的服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。 无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Android系统的体系架构","date":"2017-04-20T17:13:30.000Z","path":"2017/04/21/android-system-architecture/","text":"Android系统的体系架构前言 Android 5.0 （API 21）开始，Android开发者官网给出的平台架构层次稍微有些不一样，从原先的四层结构变成五层，更加易懂。Android系统的平台架构从下至上分为： Linux内核层 -&gt; 硬件抽象层（HAL） -&gt; 原生C/C++层 + Android Runtime层 -&gt; Java API框架层 -&gt; 系统应用程序层 Linux内核层众所周知，Android是基于Linux内核构建的，所以最底层肯定是Linux的内核，Android Runtime也需要依靠Linux内核来执行底层任务，比如线程和内存的管理，当然，这一层还包含了嵌入式的硬件驱动程序，包括蓝牙、WiFi、摄像头等等。 硬件抽象层（Hardware Abstract Layout, HAL）硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。 系统运行库层这一层包含两部分，一部分是原生的C/C++库，另一部分是Android Runtime，也就是Android的虚拟机。 Android Runtime Android 5.0（API 21）开始，ART（Android Runtime）取代了之前的Dalvik虚拟机。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如 Jack）将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。 ART的部分主要功能包括： 预先 (AOT) 和即时 (JIT) 编译 优化的垃圾回收 (GC) 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段 Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能，包括一些 Java 8 语言功能。 原生C/C++库 很多Android的系统组件和服务都由C/C++构建，Android也将原生的开发提供给开发者。开发者可以 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。 Java API 框架层这个层提供了用Java编写的API，这些API是Android系统的整个功能集，开发者可以根据这些API来开发不同的App。核心的模块组件和服务如下： View系统。可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件 通知管理器，可让所有应用在状态栏中显示自定义提醒 Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈 内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据 系统应用层系统中内置的应用和开发者开发的应用程序，都归属系统的应用层，主要是和用户进行交互，这一层都是用Java来发开的。","tags":[{"name":"Android","slug":"Android","permalink":"http://linzhs.cm/tags/Android/"}]},{"title":"Java随笔 - 内部类和闭包","date":"2017-04-20T17:11:22.000Z","path":"2017/04/21/java-innerclass/","text":"Java随笔 - 内部类和闭包前言 内部类（inner class），就是类中类，与其对应的就是外部类。接下来将学习内部类的各种形式，内部类和外部类的联系，还Java中的闭包。 内部类的作用每一项技术的诞生都有它的用处，内部类的出现，我们为什么要使用内部类，主要有以下三点： 内部类作为外部类的成员，其方法可以访问外部类作用域中的数据，包括私有数据，这个是很重要的一点 内部类可以实现进一步的封装，在Java中，常规类默认是包可见的，或者公有可见，只有内部类可以对同一个包中的其他类不可见，即隐藏起来 当想要定义一个回调函数，又不想编写太多的代码时，使用匿名的内部类可以比较便捷地实现 成员内部类在普通的类内部放置一个类，外层的我们称之为外部类，在外部类里面的为内部类，相当于内部类成为了外部类的一个成员，成员内部类是包不可见的，成员内部类可以无条件访问外部类的作用域，包括数据和方法，private的也可以。例子：123456789101112131415161718public class OutterClass &#123;//外部类 private int intValue = 0; private static int staticValue = 0; public OutterClass(int intValue) &#123; this.intValue = intValue; &#125; class InnerClass &#123;//内部类 int a = intValue; public void output() &#123; System.out.println(intValue); System.out.println(staticValue); intValue++; System.out.println(intValue); &#125; &#125;&#125; Java中，实现内部类能够访问外部类成员的思路是，内部类的对象总有一个隐式的引用，它指向了创建它的外部类的对象，假设这个引用为outer（实际不是Java的关键字），那么上面例子的内部类可以等价于：12345678910class InnerClass &#123;//内部类 int a = outer.intValue; public void output() &#123; System.out.println(outer.intValue); System.out.println(outer.staticValue); outer.intValue++; System.out.println(outer.intValue); &#125; &#125; 内部类的特殊语法Java的语法当中，变量名的命名除了使用下划线、数字、字母外，还可以使用$来命名，但是一般不推荐使用，因为这个美刀字符，只要是用于对内部类的命名，上面的例子中，编译器编译过后，内部类所形成的类名实际为OutterClass$InnerClass。内部类正规的引用外部类的成员是使用如下形式1OutterClass.this 这种表达方式中的this限定词很多时候可能是累赘，没什么作用，但是如果内部类中的方法和数据与外部的相同时，作用就很大了，就像在类的构造方法中经常用到的方式。1System.out.println(OutterClass.this.intValue);//调用外部类的intValue成员 外部类是没法直接访问内部类的，要访问内部类，就必须在外部类中实例化一个内部类对象，通过这个对象引用到访问内部类12345678910111213public class OutterClass &#123;//外部类 private int intValue = 0; private static int staticValue = 0; private InnerClass inner; public OutterClass(int intValue) &#123; this.intValue = intValue; Inner = new InnerClass();//实例化一个内部类对象 &#125; class InnerClass &#123;//内部类 ... &#125;&#125; 内部类也是有所限制的，它必须依附于外部类存在的，如果需要创建一个内部类对象，那就必须存在一个外部类对象，通过这个外部类对象来实例化一个内部类对象。创建内部类对象的例子：12OutterClass out = new OutterClass(...);OutterClass.InnerClass in = out.new InnerClass(); 局部内部类有时候会遇到这种情况：我们需要在一个方法当中去回调一个实现了相应操作接口的类的方法，对应创建的对象只使用一次，如果在外部类中内置一个内部类，那么每个外部类对象都会有这个内部类。但是，Java给我们提供一个便捷的方式，让程序员更加“懒惰”，我们可以在方法中定义一个局部的内部类，从而实现该对象只使用一次就被GC回收，例子如下：12345678public OutterClass() &#123; class InnerClass &#123; private int i = 0; &#125; InnerClass in = new InnerClass(); System.out.println(in.i);&#125; 在方法中的局部类，和定义变量一样，不能用private、public等修饰符来声明，它的作用域仅限于这个块中。 匿名内部类匿名内部类比较好理解，就是创建一个没有名字的内部类，这个是非常常见的，举一个Android中按钮点击触发的事件例子：123456button.setOnClickListener(new View.OnClickListener &#123; @Override public void onClick(View v) &#123; //do something... &#125;&#125;); 静态内部类Java中，只有内部类可以声明为static，若是声明为static的内部类，我们称之为静态内部类。静态内部类的对象不具备对生成它的外部类对象的引用特权，其他的基本是普通内部类一致。静态内部类无法访问外部类的非静态成员。1234567891011121314public class OutterClass &#123;//外部类 private int intValue = 0; private static int staticValue = 0; static class StaticInnerClass &#123; public int a = staticValue; //public int b = intValue;//error &#125;&#125;public class InnerClassTest &#123; public static void main(String[] args)&#123; OutterClass.StaticInnerClass in = new OutterClass.StaticInnerClass(); &#125;&#125; 闭包（Closure）Java没有像C#中的委托机制，但是Java引入了闭包，非显式地支持闭包。Java中的闭包一般和回调关联在一起，可以通过接口和内部类来实现。上面谈到，非静态内部类可以理解为外部类的一个对象引用，内部类可以访问外部类的详细信息，所以可以把非静态内部类当做面向对象领域的闭包。 例子：存在一个类Teacher，表示教师，它有一个成员方法work12345public class Teacher &#123; public void work() &#123; //do something... &#125;&#125; 存在一个接口Programmable，表示具备编程能力的人，它提供一个方法work123public interface Programmable &#123; void work();&#125; 以上两者都提供了work方法，方法的签名是一样的，但是功能不一样。现在有这么一个人，他是老师，教的是编程课，那么我们既要实现Programmable接口，也要继承教师类。现在的问题是实现的这个类只能定义一个work方法，怎么来实现？采用闭包可以有效解决这个问题。 code：1234567891011121314151617public Man extends Teacher &#123; @Override public void work() &#123; //do something... &#125; public void coding() &#123; //program &#125; class Programmer implements Programmabele &#123; @Override public void work() &#123; coding(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"Java随笔 - 枚举类","date":"2017-04-20T17:10:21.000Z","path":"2017/04/21/java-enum/","text":"Java随笔 - 枚举类前言 枚举类是JDK 5开始引入的，其知识点比较少，又较C/C++中的枚举类型不一样，在这里，枚举以类的形式存在，下面学习枚举类的常见语法和在单例模式（设计模式）中的应用。 常用语法先看一个典型例子，在C/C++/C#中都是很常见的例子：123enum Week &#123; Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125;; 所有的枚举类都继承于Enum，Enum有一些比较好用的方法，比如toString()，ordinal()，compareTo()，下面为使用例子:12345678System.out.println(Week.Friday);// print &quot;Friday&quot; 直接输出枚举常量Week week = Enum.valueOf(Week.class, &quot;Friday&quot;);//获取指定类和名字的枚举常量System.out.println(week);// print &quot;Friday&quot;System.out.println(Week.Friday.ordinal());//获取当前枚举常量的位置 print 4Week[] values = Week.values();//values()为静态方法，将包含的全部枚举常量以数组的形式返回 for (Week w : values) &#123;// print Monday Tuesday Wednesday Thursday Friday Saturday Sunday System.out.print(w + &quot; &quot;);&#125; 枚举强调常量这个概念，可以理解为静态的，不要试图去构造一个枚举对象，这样是不允许的，比如1Week week = new Week();// error 在比较两个枚举类型的值的时候，永远不需要调用equals方法，虽然有实现，直接用==就可以。 有需要的话，可以在枚举类中添加一些构造器、方法和数据域。当然，其中的构造器只能在构造枚举常量的时候被调用。以下为例子：123456789101112131415161718enum Size &#123; SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;); private String abbreviation; private Size(String abbreviation) &#123; this.abbreviation = abbreviation; &#125; public String getAbbreviation() &#123; return abbreviation; &#125;&#125;System.out.println(Size.SMALL.getAbbreviation());Size size = Enum.valueOf(Size.class, &quot;SMALL&quot;);//print &quot;S&quot;System.out.println(size.equals(Size.SMALL));//trueSystem.out.println(size == Size.SMALL);//trueSystem.out.println(size == Size.LARGE);//false 单例模式的枚举实现用枚举来实现单例模式是最佳方法。它更简洁，不仅可以避免多线程同步问题，自动支持序列化机制，也可以绝对防止多次被实例化。Code:123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"Java随笔 - 接口和抽象","date":"2017-04-20T17:08:54.000Z","path":"2017/04/21/java-interface-abstract/","text":"Java随笔 - 接口和抽象类 接口和抽象类有着相似和不同的地方，相似的地方在于都是为了在继承层次中，让上层更加通用的类更好地将数据隔离、封装、抽象出来，不同之处是两者使用的一些特性。 抽象类在继承的层次中，处在上层的类更具通用性，也就是通用的超类，让此类作为抽象类，抽象类中的通用的方法进行抽象，在类中起到占位的作用，自己不去实现它，而让继承它的之类去实现它。 抽象类的修饰词是abstract，不仅仅可以修饰类，还可以修饰方法。为了提高程序的清晰度，在一个类中，包含一到多个抽象方法的类，其本身必须被声明为抽象类。也就是说，具备一到多个方法的类一定是抽象类。123456789public abstract class Person &#123; public abstract String getDescription();//抽象方法必须为public或者default&#125;public class Student extends Person &#123; public String getDescription() &#123; //... &#125;&#125; 在抽象类中，除了可以拥有抽象方法，还可以有具体的数据和具体方法，子类继承抽象类时，可以不用去重写具体方法。 抽象类中，可以包含具体的数据域和具体方法，还可以不包含抽象方法。也就是说，类即使不包含抽象方法，也可以被声明为抽象类。但是！抽象类是不能被实例化的，下面的例子就是错误的：12Person p = new Person();//errorPerson p = new Student();//ok 抽象类可以定义对象变量，但是其只能引用非抽象子类的对象。 在抽象类中尽量不要包含具体方法，不管是不是抽象的，都应该将通用的域和方法尽量放在super类中。 拓展抽象类的方式 在抽象中定义部分抽象类方法或者不定义抽象方法，这样子类就必须声明为抽象类，去定义剩余部分的抽象方法或者去定义没有定义的抽象方法 在抽象类中定义全部的抽象方法，这样子类就不是抽象的了 接口接口，修饰符为interface，声明方式如下：123public interface Comparable&lt;T&gt; &#123; int compareTo(T other);&#125; 接口不是类，而是一种特殊的类，其意义在于描述了类的行为，具有什么功能，这些行为和功能往往具备通用性。接口只是“描述”，而不去实现。一个类只能继承一个类，在Java和C#中都是单继承的，但是对于接口来说，一个类可以实现多继承，也就是一个类可以继承多个接口，其含义是一个类可以具备多种通用的行为。 Java库中内置的Comparable接口，也就是上面的例子，对于实现了这个接口的类，都必须是实现comparaTo方法，从而拥有这个方法，而且这个方法必须和接口中声明的一致，包括参数和返回类型。 接口中的所有方法都是public的，所以在接口声明中写不写public修饰符都是一样的。但是！在实现类中，必须有public修饰符。因为在实现的具体类中，若不写明为public，那么编译器会认为此方法为default，也就是默认包可见的，从而引发后面的一系列警告。12345class Person implements Comparable&lt;Person&gt; &#123; public compareTo(Person other) &#123; return age - other.age; &#125;&#125; 接口可以包含多个方法，但是在设计模式的六大原则中，职责单一原则建议实现接口的职责单一，而不是将所有不同功能的接口都放在一个接口中，最好是一个接口一个方法。 在接口中，是绝对不能有具体的实例域和具体方法或者静态方法的，这个有别于抽象类。提供实例域和方法的实现的任务应该交由实现接口的类来完成。但是，接口可以具备常量，且接口中的域会被自动设置为public static final。接口是没有构造方法的。 因此，我们可以把接口看成是没有实例域的抽象类。 和抽象类一样，接口是不能被实例化的，但是可以声明接口对象变量，去引用实现了这个接口的类的对象，这也体现了类的多态性。 接口的其他特性 静态方法 Java8开始，允许在接口中增加静态方法。理论上讲，这是合乎常理的，只是这由位于将接口作为抽象规范的初衷。 默认方法 可以为接口方法提供一个默认的实现，但必须用default修饰符来标记。12345public interface Comparable&lt;T&gt; &#123; default int compareTo(T other) &#123; return 0; &#125;&#125; 当然，添加这个默认的实现意义不大，因为在实现这个接口的同时，这个方法也会被重写，也就是被覆盖。意义不大，还是有些意义的，在过多类似的回调接口实现中，有些没有去实现，那就可以拿默认的来用。 接口的默认方法冲突接口的默认方法出现冲突的情况是这样的：先是在一个接口中将一个方法定义为默认方法，然后又在超类或者另一个接口中定义了同样的方法。 Java为解决此问题，指定了如下规则： 超类优先。如果超类提供了一个具体的方法，同名而且有相同参数类型的默认方法都会被忽略。 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（无论是否是默认参数）相同的方法，拿就必须覆盖这个方法来解决冲突。 如果两个接口都没有为共享方法提供默认的实现，实现类可以选择两者都实现，也可以选择干脆都不实现。","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"Java随笔 - 对象克隆","date":"2017-04-17T16:48:32.000Z","path":"2017/04/18/java-note-object-copy/","text":"Java随笔 - 对象克隆 本文总结Java对象的浅复制和深复制，以及Clonable接口。 前言对象在传递的时候，会进行对象复制。对象的复制，可以分为浅复制和深复制。 浅复制在下面的例子中，可以实现对象的复制，origin和copy对象变量引用同一个内存区域，copy调用raiseSalary方法可以修改origin对象所引用的内容。12345678910111213141516171819public class Employee &#123; private double salary; &#123; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125;&#125;Employee origin = new Employee();Employee copy = origin;copy.raiseSalary(10); 在这次的复制过程中，实现的细节是：Object这个Java的万类祖先有个protect的clone方法，可以在相同类的对象上做拷贝。 但是，在整个复制的过程中，复制是有限制的，也就是不完全的，所以我们称之为浅复制，浅克隆，浅拷贝。Object这个超类在实现clone这个方法的时候，并不知道子孙类到底是什么，所以在复制的时候也就有了局限性，若需要复制的内容是数值或者其他基本类型，那没什么问题，直接复制即可；若是复制的内容是另一对象的引用呢？那clone复制的新内存区域仍然和原对象共享着一些信息。 浅复制有什么影响吗？我们来举两个例子。 例子112345678910111213141516171819202122public class Employee &#123; private String name; private double salary; &#123; name = &quot;&quot;; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125; ...&#125;Employee origin = new Employee();Employee copy = origin; 在例子1中，我们在Employee中新增String类型的name变量，还是像之前的那样进行拷贝操作。拷贝之后，原对象和克隆对象的name指向了同一块区域，String是不可变的，也就是指向了常量池。 对于不可变对象的拷贝，其实是安全的，没什么影响，拷贝与否没什么影响，因为不管拷贝与否，不可变对象都是同一块内存，并不会因为拷贝了就另外分配一块内存。所以对于不可变对象，浅复制是安全的，可以安全的共享信息。 例子21234567891011121314151617181920212223public class Employee &#123; private String name; private double salary; private Date hireDay; &#123; name = &quot;&quot;; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125; ...&#125;Employee origin = new Employee();Employee copy = origin; 在新的例子中，我们新增了可变对象Date，这个时候不完全的拷贝，是有影响的。原本复制的用意是让克隆对象有单独的内存来管理自己的数据，但是由于浅复制导致原对象和克隆对象都指向了同一个可变的对象，那么任一对象进行修改，那就是灾难级别的，所以这时候我们需要深度复制。 深复制通常，在复制对象的时候会考虑下面三个选项： 默认的clone方法是否能满足要求； 是否可以在可变的子对象上调用clone方法来修补默认的clone方法； 是不是不应该使用clone方法 对于第三个选项，其实是默认的，对于前两个选项，类必须： 实现Cloneable接口 重新定义clone方法，并制定为public访问修饰符 在Object类中制定了clone方法为protect，但是在新的Java语法规则中，已经变得宽松了，可以将clone方法重写成public的方法。 要建立深度复制来复制对象中另一个对象，那么就要实行Cloneable接口、重写clone方法，在clone方法里来完成这些复制，如下例子：12345678910111213141516171819202122232425262728public class Employee implements Cloneable &#123; private String name; private double salary; private Date hireDay; &#123; name = &quot;&quot;; salary = 0.0; &#125; public double getSalary() &#123; return this.salary; &#125; public void raiseSalary(int t) &#123; this.salary = salary * t; &#125; public Employee clone() throws CloneNotSupportedException &#123; Employee cloned = (Employee)super.clone(); cloned.hireDay = (Date)hireDay.clone(); &#125; ...&#125;Employee origin = new Employee();Employee copy = origin; 在新的clone实现里，指定了throws CloneNotSupportedException异常，其用意在于要实现Cloneable接口，否则就不支持深度拷贝，从而抛出异常。 在重写clone方法的时候，首先应该要调用超类的clone方法来完成浅复制，然后才去定制自己需要完成的深度复制。 在重写clone方法的时候，我们返回的类型是Employee，而不是原本自带的Object，与super类有别，这个是Java5后的特性，为clone指定正确的返回类型，这就是协变返回类型。 标记为Clone的类，在执行克隆方法的时候是内存二进制克隆，比new一个对象性能更好，但是直接在内存中拷贝，构造方法并不会被执行。","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"Android中的动画和图形绘制","date":"2017-03-25T06:29:28.131Z","path":"2017/03/25/Android中的Animation/","text":"Android中的动画和图形绘制前言Android框架中提供了比较丰富的动画UI和2D、3D图形绘制API，包括底层的OpenGL和封装好的Animation。 动画Android框架提供了两种动画模式，分别是属性动画（property animation）和视图动画（view animation）。Android官方比较推荐属性动画，它比较灵活，也具备更多的功能。除此之外，还可以利用drawable动画，来加载绘制的资源，连续播放每一帧。 属性动画(Property Animation) 在Android 3.0 （即API 11）之后，Android加入了属性动画，功能很强大。属性动画允许你通过修改任意的属性值来控制动画，包括未渲染到屏幕上的。属性动画也是可拓展的，可以让你自定义动画的属性类型。 视图动画(View Animation) 视图动画是比较老的模式了，在Android 3.0之后，集成了3.0之前的补间动画（Tween）和帧动画（Frame），只能用于浏览。视图动画比较简单，也提供了能足够的能力来满足应用程序的需求。 可绘制动画(Drawable Animation) 在Android3.0之后出现了这一概念，其实功能和帧动画一毛一样。 2D和3D图形在Android的框架里，除了提高了丰富的2D图形绘制之外，还内置了3D绘图引擎，可以根据不同的需求来设计自己的应用程序。 Canvas和Drawanles Android提供了一组View，用于提供各种各样的用户界面的一般功能部件。我们可以扩展这些小部件来修改它们的样式和行为。此外，也可以使用包含在各种绘图方式做自定义2D渲染Canvas类或创建Drawable的事情对象，如纹理按钮或帧动画。 硬件加速 Android3.0开始，可以用硬件来加速Canvas API的图形绘制，从而提升其性能。 OpenGL Android中内置了OpenGL的3D图形绘制嵌入式版本，也就是OpenGL ES，可以通过NDK和C/C++相结合开发，其具备平台独立性。对于游戏开发来说，OpenGL是很重要的。 视图动画（View Animation）作为最早出现的动画模式，视图动画集成了Android3.0之前的补间动画和帧动画，由于帧动画和Drawable动画很类似，所以在这一小节只学习Tween动画。 Tween主要用于显示淡入淡出（alpha）、缩放（scale）、旋转（rotate）、移动（translate）等效果，这些操作可以通过XML和Android代码的动画集（Animation Set）来实现。在XML中定义动画集，就像是在XML定义布局一样，简洁，可读性、复用性也强， 下面通过在XML定义动画集的例子来学习Tween动画的旋转、缩放、移动、淡入淡出效果。 File Location: /res/anim/anim_alpla.xml /res/anim/anim_scale.xml /res/anim/rotate_scale.xml /res/anim/translate_scale.xml XML和Java代码实现： anim_alpha.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shareInterpolator=&quot;false&quot; android:fillAfter=&quot;true&quot; android:fillBefore=&quot;true&quot; &gt; &lt;!-- shareInterpolator 分享插值器，这里静止 fillAfter和fillBefore两者同时设置，最终只显示fillAfter的效果 --&gt; &lt;!-- fromAlpha:Float.起始动画时的不透明度，0.0表示透明，1.0表示不透明 toAlpha:Float.结束动画时的不透明度，0.0表示透明，1.0表示不透明 --&gt; &lt;!-- 透明度从1.0变化到0.1，且动画结束后保留最后一帧的效果 --&gt; &lt;alpha android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot;/&gt;&lt;/set&gt; anim_scale.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- fromXScale &amp; fromYScale : float 伸缩起始时坐标 toXScale &amp; toYScale : float 伸缩结束时坐标 pivotX &amp; pivotY : float 当对象伸缩的时候X &amp; Y坐标保持不变 这里未使用 --&gt; &lt;!-- 从(0.1, 0.1)到(1.0, 1.0) --&gt; &lt;scale android:fromXScale=&quot;0.1&quot; android:fromYScale=&quot;0.1&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt;&lt;/set&gt; anim_rotate.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- fromDegrees &amp; toDegrees : float 动画开始和结束时的角度 pivotX &amp; pivotY：float or percentage 用Float（如(x,y)=(5,5)）代表中心为整个布局的左上角(5,5)， 用百分比(如(x,y)=(50%，50%))代表中心为该控件的中心，用百分比(如(x,y)=(50%p，50%p))代表中心为该控件的父控件的中心 --&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot; /&gt;&lt;/set&gt; anim_translate.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- fromXDelta &amp; toXDelta : 位移开始和结束时x的位置。 fromYDelta &amp; toYDelta : 位移开始和结束时y的位置。 --&gt; &lt;!-- 从（0，0）位移到（100，100）--&gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100&quot; android:toYDelta=&quot;100&quot; /&gt;&lt;/set&gt; Animation.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button_alpha_xml: //AnimationUtils.loadAnimation()方法返回Animation对象，所以alphaAnimation为Animation alphaAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha); alphaAnimation.setDuration(1500);//设置动画时间为1.5ms imageView.startAnimation(alphaAnimation);//启动动画 break; case R.id.button_alpha_code: //AlphaAnimation(float fromAlpha,float toAlpha) //fromAlpha:起始动画时的不透明度，0.0表示透明，1.0表示不透明 //toAlpha:结束动画时的不透明度，0.0表示透明，1.0表示不透明 //透明度从0.1——&gt;1.0 alphaAnimation = new AlphaAnimation(0.1f, 1.0f); alphaAnimation.setDuration(1500); imageView.startAnimation(alphaAnimation); break; case R.id.button_scale_xml: scaleAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_scale); scaleAnimation.setDuration(3000); imageView.startAnimation(scaleAnimation); break; case R.id.button_scale__code: //ScaleAnimation(float fromX, float toX, float fromY, float toY) //另外还有pivotXType、pivotYType：伸缩模式， //pivotXValue、pivotYValue伸缩动画相对于x,y 坐标的开始位置 scaleAnimation = new ScaleAnimation(1.0f, 0.1f, 1.0f, 0.1f); scaleAnimation.setDuration(3000); imageView.startAnimation(scaleAnimation); break; case R.id.button_rotate_xml: rotateAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_rorate); rotateAnimation.setDuration(3000); imageView.startAnimation(rotateAnimation); break; case R.id.button_rotate__code: //RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,int pivotYType, float pivotYValue) //pivotXType、pivotYType:中心点类型，主要有Animation.ABSOLUTE、Animation.RELATIVE_TO_PARENT、Animation.RELATIVE_TO_SELF //pivotXValue、pivotYValue:根据pivotType决定旋转效果 rotateAnimation = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnimation.setDuration(3000); rotateAnimation.setFillAfter(true);//设置动画结束时是否停留在最后一帧 imageView.startAnimation(rotateAnimation); break; case R.id.button_translate_xml: translateAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_translate); translateAnimation.setFillAfter(true); translateAnimation.setDuration(3000); imageView.startAnimation(translateAnimation); break; case R.id.button_translate__code: //TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) translateAnimation = new TranslateAnimation(0, 100, 0, 100); translateAnimation.setDuration(3000); translateAnimation.setFillAfter(true); imageView.startAnimation(translateAnimation); break; default: break; &#125; 组合使用 xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot; android:duration=&quot;3000&quot; &gt; &lt;alpha android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot; /&gt; &lt;scale android:fromXScale=&quot;0.1&quot; android:fromYScale=&quot;0.1&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt; &lt;translate android:fillAfter=&quot;true&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100&quot; android:toYDelta=&quot;100&quot; /&gt;&lt;/set&gt; java123456789101112131415161718192021222324public void onClick(View v) &#123; switch (v.getId()) &#123; //Mutiple Animation实现方法一 case R.id.btn_mutiple_anim_one: animationSet = new AnimationSet(true); Animation alphaAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_alpha); Animation scaleAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_scale); Animation rotateAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_rotate); Animation translateAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_translate); animationSet.addAnimation(alphaAnimation); animationSet.addAnimation(scaleAnimation); animationSet.addAnimation(rotateAnimation); animationSet.addAnimation(translateAnimation); imageView.startAnimation(animationSet); break; //Mutiple Animation实现方法二 case R.id.btn_mutiple_anim_two: Animation mutipleAnimation = AnimationUtils.loadAnimation(getActivity(), R.anim.anim_mutiple); imageView.startAnimation(mutipleAnimation); break; default: break; &#125; &#125; 帧动画帧动画，包括Frame Animation和Drawable Animation，可以通过连续加载资源实现连续动画，类似于GIF等，就像在放电影。和Tween Animation一样，帧动画也可在XML和Java代码中实现。 下面为简单的例子，预先在res/drawable目录放一些图片，然后在该目录下创建文件连续动画文件：/res/drawable/fruit_animlist.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/apple_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/banana_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/cherry_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/grape_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/mango_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/orange_pic&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/pineapple_pic&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; java code1234567891011121314151617181920212223public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button_anim_list_xml: imageView.setImageResource(R.drawable.fruit_animlist);//设置动画集 AnimationDrawable animationDrawable = (AnimationDrawable)imageView.getDrawable(); animationDrawable.start(); break; case R.id.button_anim_list_code: AnimationDrawable anim = new AnimationDrawable(); for (int i = 1; i &lt; 10; ++i) &#123; int id = getResources().getIdentifier(&quot;fruit_&quot; + i, &quot;drawable&quot;, getPackageName()); Drawable drawable = getResources().getDrawable(id); anim.addFrame(drawable, 200); &#125; anim.setOneShot(false); imageView.setImageDrawable(anim); anim.start(); //anim.stop() anim.isRunning() break; default: break; &#125; &#125; 在较大型的帧动画显示中，会出现卡顿的情况，这是View和OOM的原因，可以使用双缓冲的surfaceView来实现。 属性动画属性动画是Android3.0后引入的，是一个强大的框架，可以让你绘制几乎任何东西。无论有没有显示在屏幕上，属性动画可以随着时间去修改属性的值来控制动画。 属性动画相关类： 类名 用途 ValueAnimation 属性动画主要的计时器，也计算动画后的属性的值，动画的执行类 ObjectAnimator ValueAnimator的一个子类，允许你设置一个目标对象和对象的属性进行动画，动画的执行类 AnimatorSet 提供组织动画的结构，使它们能相关联得运行，用于控制一组动画的执行 AnimatorInflater 用户加载属性动画的xml文件 Evaluators 属性动画计算器，告诉了属性动画系统如何计算给出属性的值 Interpolators 动画插入器，定义动画的变化率 类之间的关系： iamge 接下来用几个例子来学习一下怎么使用属性动画，注意，==xml文件必须放在/res/animator中==。 ObjectAnimation（用属性动画实现视图动画的淡入淡出效果，缩放、移动、旋转等类似） alpha_anim.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:propertyName=&quot;alpha&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:startOffset=&quot;200&quot; android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;1.0&quot; android:valueType=&quot;floatType&quot;&gt; &lt;!-- duration 表示动画执行的时间 propertyName 表示修改的物件的哪个属性值，这里是透明度 valueFrom 表示从哪个状态值开始动画 valueTo 表示到哪个状态值结束动画 valueType 类型估值，主要用于设置动画操作属性的值 repeatCount 动画重复的计数，动画将会执行该值+1次 repeatMode 动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。restart为重新执行，方向不变 startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间，单位毫秒 interpolator 指定动画插入器 --&gt;&lt;/objectAnimator&gt; 对应Java code123456789101112131415161718//ImageView预先设置好图片//xml实现//ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()这几个方法//都是设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值//ofFloat(Object target, String propertyName, float... values)Animator anim = AnimatorInflater.loadAnimator(this, R.animator.property_animation);anim.setTarget(imageView);anim.start();//java codeObjectAnimator alphaAnimation = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0f, 1f);alphaAnimation.setDuration(500);alphaAnimation.setRepeatCount(0);alphaAnimation.setRepeatMode(ValueAnimator.REVERSE);alphaAnimation.setStartDelay(200);alphaAnimation.setInterpolator(new AccelerateDecelerateInterpolator());alphaAnimation.start(); scale_anim.xml12345678&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:propertyName=&quot;scaleX&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;1.5&quot; android:valueType=&quot;floatType&quot; /&gt; java code12345ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f); scaleXAnimator.setDuration(500); scaleXAnimator.setRepeatCount(1); scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE); scaleXAnimator.start(); rotate_anim.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:propertyName=&quot;rotation&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;360&quot; android:valueType=&quot;floatType&quot; /&gt; java code12345ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;rotation&quot;, 0f, 360f); objectAnimator.setDuration(500); objectAnimator.setRepeatCount(1); objectAnimator.setRepeatMode(ValueAnimator.REVERSE); objectAnimator.start(); translate_anim.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot; android:propertyName=&quot;translationX&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;100&quot; android:valueType=&quot;floatType&quot; /&gt; java code12345ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;translationX&quot;, 0f, 100f); objectAnimator.setDuration(500); objectAnimator.setRepeatCount(1); objectAnimator.setRepeatMode(ValueAnimator.REVERSE); objectAnimator.start(); Animation（组合动画） anim_set.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:ordering=&quot;together&quot;&gt; &lt;objectAnimator android:duration=&quot;500&quot; android:propertyName=&quot;scaleX&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;1.5&quot; android:valueType=&quot;floatType&quot; /&gt; &lt;objectAnimator android:duration=&quot;500&quot; android:propertyName=&quot;scaleY&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;1.5&quot; android:valueType=&quot;floatType&quot; /&gt;&lt;/set&gt; java code123456789101112131415161718192021//加载动画Animator anim = AnimatorInflater.loadAnimator(this, R.animator.animator_scale); anim.setTarget(imageView); anim.start(); //纯代码实现AnimatorSet animatorSet = new AnimatorSet(); ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f); scaleXAnimator.setDuration(500); scaleXAnimator.setRepeatCount(1); scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE); scaleXAnimator.start(); ObjectAnimator scaleYAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 1.5f); scaleYAnimator.setDuration(500); scaleYAnimator.setRepeatCount(1); scaleYAnimator.setRepeatMode(ValueAnimator.REVERSE); animatorSet.playTogether(scaleXAnimator, scaleYAnimator); animatorSet.start(); 视图动画和属性动画的区别在视图动画中，止提供了唯一的View动画对象，如果要完成非View对象，那就玩自己去完成这部分带吗。在View视图中，其仅仅提供了一些功能，比如旋转、缩放等，但没有实现背景颜色这些，是有一定的局限性的。 视图动画只是修改了被画的东西，而不是自己本身。 属性动画把这些限制的缺点都去除了，使动画更加健壮，动画更加丰富。 视图动画的实现只需要少量的代码和时间，所以如果是小型的动画，可以用视图动画来完成。Android还保留着view动画，也是有它的用处。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"数据结构与算法理论学习 -- 队列","date":"2017-03-25T06:26:51.208Z","path":"2017/03/25/queue/","text":"队列(Queue)基本概念队列(Queue)是一种先进先出(FIFO)的数据结构，编程中可通过使用数组或者链表来实现。 基本操作enqueue 入队，向队列尾部添加一个元素 dequeue 出队，在队列头部移除一个元素 isEmpty 检查队列是否为空 size 查看队列大小 Coding时刻 使用链表实现队列 12345678910111213141516171819202122232425262728293031323334353637public class Queue&lt;T&gt; &#123; private Node first;//指向队列中最早添加的结点 private Node last;//指向队列中最近添加的结点 private int N; private class Node &#123;//结点类，只在内部使用 T item; Node next; &#125; public boolean isEmpty() &#123; return first == null; //return N == 0; &#125; public int size() &#123; return N; &#125; public void enqueue(T item) &#123; Node oldlast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty() == true) first = last; else oldlast.next = last; N++; &#125; public Item dequeue() &#123; Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; &#125;&#125; 实现两个栈实现队列 123456789101112131415161718192021222324public class Solution&lt;T&gt; &#123; private static Stack&lt;T&gt; stack1 = new Stack&lt;&gt;();//入队 private static Stack&lt;T&gt; stack2 = new Stack&lt;&gt;();//出队 public void enqueue(T element) &#123; stack1.push(element); &#125; public T dequeue() &#123; if (stack2.isEmpty() == true) &#123;//出队，将stack1中的元素弹出，并且在stack2中入栈 while (stack1.isEmpty() == false) &#123; T data = stack1.pop(); stack2.push(data); &#125; &#125; if (stack2.isEmpty() == true) &#123; throw new Exception(&quot;queue is empty.&quot;); &#125; return stack2.pop(); &#125;&#125; 常见应用普通队列在现实计算机当中应用非常广泛，比如播放器的播放列表，数据流对象，异步数据传输结构(文件IO，管道通信，套接字等)，多线程中的阻塞队列，打印机队列，消息队列等等。 队列的常见衍生版本1.循环队列在普通队列的基础上，将队列的头部和尾部相连接，就构成了循环队列这种数据结构。循环队列可以充分利用结构的空间，克服队列的“假溢出”这种现象。循环队列可以通过数据和链表来实现。 循环队列的一些基本的判断条件和性质： 初始化条件为：队头指针是front，队尾是rear，队列的最大长度为QueueSize 1.队列为空 rear == front 2.队列满 (rear + 1) % QueueSize == front 3.队列的长度 n = (rear - front + 1) % QueueSize 4.入队后rear指向 (rear + 1) % QueueSize 5.出队后front指向 (front + 1) % QueueSize 2.双端队列双端队列是一种同时具有队列和栈的性质的一种数据结构，在队列的两头都可以进行插入和删除的操作，同时也可以对双端队列做一些限制。 输入受限的双端队列是指只能从队列一端输入，但可以从两端输出的双端队列； 输出受限的双端队列是指只能从队列一端输出，但可以从两端输入的双端队列； 如果双端队列允许从一端输入，从一端输出，则是普通的队列，如果双端队列只允许从一端输入和输出则是栈， 因此说双端队列同时具有队列和栈两种数据结构的性质。 3.优先队列(堆, Heap)堆也是队列，但强调的是“优先”二字，每个在队列中取出的元素都具备最高优先权，若是最大堆，则每次取出必定是当前堆中最大的元素，同理，若是最小堆而取出元素为最小。堆有着广泛的应用，比如抢占式优先级的系统等。堆还有着各种衍生结构，这里就不在详细说明，有关堆的知识，将专门开一篇文章来了解。 总结本文所述的队列知识比较简单，队列在数据结构中确实算是比较简单的，但是应用却是非常广泛。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"数据结构与算法理论学习 -- 栈","date":"2017-03-25T06:25:40.600Z","path":"2017/03/25/stack/","text":"栈 (Stack)1. 栈的概念栈是一种先进后出(First in last off, FILO/LIFO)线性数据结构。很多人叫栈为堆栈，但是堆和栈是不同的数据结构。 2. 栈的实现栈可以用数组和链表来实现。栈的基本操作有入栈、出栈、查看栈顶、判空等。 3. 栈的常见应用栈的应用很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、浏览器中的回退操作、编译器中的函数调用实现、表达式的计算等。相关介绍深度好文推荐。 3.1 线程栈线程栈是操作系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器。 3.2 Object-C和OpenGL中的“绘图上下文”3.3 用户按下键盘过滤无效按键3.4 算术表达式的计算(此文重点)编程中算术表达式计算在此主要介绍栈在编程语言中的一大用处。编程语言中，算术表达式有前缀、中缀、后缀之分，他们都是对算术表达式的编程语言表达、记忆方式。 举例：前缀表达式: - * + 3 4 5 6 中缀表达式: (3 + 4) * 5 - 6 后缀表达式: 3 4 + 5 * 6 - 如上面例子所示，前中后缀表达式各不相同，其中很容易发现，中缀表达式是人在数学中所常用，且习惯的一种。算术表达式中，主要由算术运算符和操作数组成，前中后缀表达式也是由此来区分的，也导致了表示的顺序不一样。 概念：前缀表达式：算术运算符在前，操作数在后，不包含括号; 为纪念波兰数学家、此表达式发明者Jan Lukasiewicz，此表达式也成为&quot;波兰表达式&quot;； 中缀表达式：算术运算符在操作数中间，相比前后缀表达式，多了表示优先级的括号； 后缀表达式：算术运算符在后，操作数在前，正好与前缀相反，所以也成为&quot;逆波兰表达式&quot;。 传统算术表达式的运算规则中缀表达式是人类最容易理解的和分析的表达方式，回忆我们对中缀表达式的运算规则： 1.在有括号的情况下，括号优先级最高，优先计算括号内的内容； 2.在无括号的情况下，按运算符优先级进行先后计算，先乘除，后加减； 3.在相同优先级的情况下，从左到右计算。 各表达式的优缺点 在中缀表达式的计算当中，需要不断遍历找出表达式中的括号和优先级较高的运算符，并且考虑操作出现的先后，这对于人来说是简而易举的，但是对于计算机这种一根筋，只能处理0和1的机器来说，显然太复杂了，就算是实现了，时间复杂度也是很恐怖的，毕竟运算符和操作数不可能总是只有几个，这时候出现的前缀和后缀表达式就很有用处了，也是专门为计算机设计的。 在前缀和后缀表达式中，计算顺序不必随着运算符和括号不断变换，而是从左到右或是从右到左顺序遍历一次，不需要考虑括号对运算的影响，再辅之的数据结构(Stack)，可完美完成计算，大大降低了计算的时间复杂度，也符合计算机的工作方式。前缀和后缀表达式大大提高了计算机计算的性能，但对于人来说是不易理解的，特别是对于没有编程基础的人来说，所以在输入和输出表达式给计算机计算的时候需要进行表达式转换，中缀(输入) -&gt; 前缀/后缀(计算) -&gt; 结果(输出)。 例子1.中缀表达式 -&gt; 后缀表达式 [ 例子：a + b * c - (d + e) ] 人工转换： 1.给中缀表达式的所有运算加上括号 ( (a + (b * c)) - (d + e) ) 2.将运算符放到括号后面 ( (a (b c)*)+ (de)+ )- 3.去除括号 a b c * + d e + - 计算机转换(用栈辅助)： 1.建立运算符栈(大小合适，这里只存储运算符)； 2.从左到右遍历中缀表达式： 如果遇到操作数，则直接输出； 如果遇到运算符，则与栈顶的运算符比较优先级： 若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈； 若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为 空，或者栈顶的运算符的优先级低于当前的运算符)。 如果遇到括号： 若为 &quot;(&quot; ，则直接入栈； 若为 &quot;)&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;(&quot;，才同时把 &quot;()&quot; 删除。 计算机转换模拟 [ 例子：a + b * c - (d + e) ] 输出终端 运算符栈(栈底 -&gt; 栈顶) a | a | + ab | + ab | +* abc | +* abc* | + abc*+ | abc*+ | - abc*+ | -( abc*+ | -(+ abc*+d | -(+ abc*+de | -(+ abc*+de+ | -( abc*+de+ | - abc*+de+- | 2.中缀表达式 -&gt; 前缀表达式 [ 例子：a + b * c - (d + e) ] 人工转换： 1.给中缀表达式的所有运算加上括号 ( (a + (b * c)) - (d + e) ) 2.将运算符放到括a号前面 ( -(+(a *(bc)) +(de) ) 3.去除括号 - + a * b c + d e 计算机转换(用栈辅助): 1.建立运算符栈和输出栈(大小合适)，其中输出栈用于存储输出数据，完成遍历后出栈的元素顺序即为前缀表达式； 2.从右向左遍历中缀表达式: 如果遇到操作数，则直接输出; 如果遇到运算符，则与栈顶的运算符比较优先级： 若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈； 若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为 空，或者栈顶的运算符的优先级低于当前的运算符)。 如果遇到括号： 若为 &quot;)&quot; ，则直接入栈； 若为 &quot;(&quot; ，记录，弹出所有运算符，直到在栈中找到&quot;)&quot;，才同时把 &quot;()&quot; 删除。 计算机转换模拟 [ 例子：a + b * c - (d + e) ] 输出栈(栈底 -&gt; 栈顶) 运算符栈(栈底 -&gt; 栈顶) | ) e | e | )+ ed+ | ed+ | - ed+c | - ed+c | -* ed+cb | - ed+cb* | - ed+cb* | -+ ed+cb*a | -+ ed+cb*a+ | - ed+cb*a+- | 所以，输出的前缀表达式为-+a*bc+de。 3.构建表达式树 下面将表达式和二叉树的知识结合，将后缀表达式转换为二叉树 [ 例子: a b c * + d e + - ] 1.建立栈，大小为操作数个数，这里为5； 2.将操作数从左到右入栈，若遇到操作符，则将前面两个元素弹出，并用当前栈顶指向形成的二叉树的根节点； 3.最终合并二叉树。 演示： 1. a b c 2. a | | / \\ b c 3. + / \\ a * / \\ b c 4. + d e / \\ a * / \\ b c 5. + + / \\ / \\ a * d e / \\ b c 6. - / \\ / \\ / \\ + + / \\ / \\ a * d e / \\ b c Coding时刻 栈的数组实现 接下来来实现栈，这里先使用Java级数组来实现，下面再使用链表来搭建栈结构及其相关操作。 下面为要实现的操作方法API： Stack123456public class Stack&lt;T&gt; &#123; public Stack(); public void push(T item); public boolean isEmpty(); public int size();&#125; 在写出最终的实现代码之前，我们必须考虑应用数组或者其他形式来实现栈这种数据结构怎么样才能让其功能和性能最优。下面为重点考虑的几点： 支持泛型。原因要使栈所支持的数据类型更加广泛通用，而不是需要String的时候写一遍栈的实现，再需要Integer类型的时候又重新写一遍针对Integer的实现。 支持数组大小自动调节。对于数组来说，没法动态调节大小是一大缺点，随机查找是它的优势，若存入有效的元素过多导致数组容纳不下，或者存入有效元素很少（有可能为空）且数组大小较大，这些情况在实际应用当中都是非常不合理的，所以我们需要实现数组大小的动态调节。这里采用流行的调节方法，在数组容纳不下的时候将大小调节为原先的2倍，若数组的有效元素为数组的大小的1/4时将大小调节为原先的1/2。 避免对象游离现象。Java的垃圾回收策略是回收所有无法被访问的对象的内存。在我们实现的栈当前，每一个pop弹出栈顶元素，栈顶指针向栈底移动一位（栈元素足够），但是实际这个被弹出的元素还存留在数组当前，也就是相应的占用这部分内存，GC无法回收。避免对象游离的办法其实很简单，在每次pop的时候将弹出的元素空间置为空。 支持迭代。支持foreach迭代，可以使代码更加整洁。迭代器接口还需要实现remove方法，这个在实现的时候可以不处理，也可以抛出UnsupportedOperationException异常，在实现next方法时候栈为空，则可不处理或者抛出NoSuchElementException。 解决完以上考虑的问题，即可构建出一个不错的栈结构，具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Iterator;//Java迭代器接口所属包public class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123; private T[] arr; private int len; public Stack() &#123;//默认构造器 arr = (T)new Object[1];//Java中不支持泛型对象数组 这里采用强制类型转换办法 len = 0;//默认元素数量 &#125; public void push(T item) &#123;//入栈 if (arr.len == len) resize(2 * arr.length); arr[len++] = item; &#125; public T pop() &#123;//出栈 T t = arr[--len]; arr[len] = null;//避免对象游离 if (len &gt; 0 &amp;&amp; len == arr.length / 4) resize(arr.length / 2); return t; &#125; public boolean isEmpty() &#123;//检查栈是否为空 return len == 0; &#125; public int size() &#123;//查看栈大小 return len; &#125; private void resize(int max) &#123;//重新分配数组大小 T[] t = (T[])new Object[max]; for (int i = 0; i &lt; len; i++) &#123; t[i] = arr[i]; &#125; arr = t; &#125; public Iterator&lt;T&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;T&gt; &#123;//内部类，实现迭代器接口 //支持先进后出迭代 private int i = len; public boolean hasNext() &#123; return i &gt; 0; &#125; public T next() &#123; return arr[--i]; &#125; public void remove &#123; &#125; &#125;&#125; 栈的链表实现 相比数组来实现栈，链表的优势在于可以很方便的插入删除元素，长度也不会受限，但是它的缺点是随机访问的能力变差了很多，所示访问的结点在末尾，那就等于每次都要遍历一次链表，效率是比较低的。这里在pop出元素的时候，Java程序员无需关心结点成为孤儿后会不会导致内存占用，GC会帮你完成收尾工作。12345678910111213141516171819202122232425262728293031323334353637public class Stack&lt;T&gt; &#123; private Node first; private int N; private class Node &#123; public T item; public Node next; &#125; public Stack() &#123; &#125; public boolean isEmpty() &#123; return first == null; &#125; public int size() &#123; return N; &#125; public void push(T item) &#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; public Item pop() &#123; T item = first.item; first = first.next; N--; return item; &#125;&#125; Dijkstra算法 - 双栈算法表达式求值 使用两个栈来实现中缀表达式的求值，这里考虑的是理想情况，将所有运算都加上括号，输入为字符串的形式，实现加减乘除开方操作。基本的思路： 将操作数压入操作数栈 将操作符压入操作符栈 忽略左括号 遇到右括号时，弹出一个运算符，弹出运算所需的操作数，并将运算完的结果压入操作数栈 具体代码实现：123456789101112131415161718192021222324252627282930public class DijkstraTwoStack &#123; private Stack&lt;Character&gt; ops = new Stack&lt;&gt;(); private Stack&lt;Double&gt; vals = new Stack&lt;&gt;(); public DijkstraTwoStack &#123; &#125; public static int cal(String expr) &#123; if (expr == null || expr.length &lt;= 1) return 0; for (char c : expr) &#123; if (c.equals(&apos;(&apos;)) ; else if (c.equals(&apos;+&apos;) || c.equals(&apos;-&apos;) || c.equals(&apos;*&apos;) || c.equals(&apos;/&apos;) || c.equals(&apos;s&apos;))//用s表示开方 ops.push(c); else if (c.equals(&apos;)&apos;)) &#123; char op = ops.pop(); double v = vals.pop(); if (op.equals(&apos;+&apos;)) v = vals.pop() + v; else if (op.equals(&apos;-&apos;)) v = vals.pop() - v; else if (op.equals(&apos;*&apos;)) v = vals.pop() * v; else if (op.equals(&apos;/&apos;)) v = vals.pop() / v; else if (op.equals(&apos;s&apos;)) v = Math.sqrt(v); vals.push(v); &#125; else &#123; vals.push(Double.parseDouble(c));//操作数字符转换为double类型入栈 &#125; &#125; &#125;&#125; 总结本文以栈为中心，主要介绍了栈的应用及算术表达式在编程语言中的表达形式。栈在大数据结构中用处很广，在其他数据结构中也能作为很好的辅助，比如迭代版的二叉树遍历、深度优先搜索和广度优先搜索等等。学好栈和队列的时候是算法设计的一大基础，务必要扎实学好。","tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://linzhs.cm/tags/DataStructure-Algorithm/"}]},{"title":"Java中方法(函数)参数的传递","date":"2017-03-22T12:05:45.114Z","path":"2017/03/22/JavaFuncParamCall/","text":"Java中方法(函数)参数的传递概述在程序设计语言中，按值调用（call by value）表示方法接收的是调用者提供的值，而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址（指针）。一个方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。 在Java程序设计语言中，总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 例子 例子1用一个方法试图将一个参数值增加到3倍 public static void tripleValue(int x) { // 无法实现 x = x * 3; } public static void main(String[] args) { int intValue = 1; tripleValue(intValue); System.out.println(intValue); // doubleValue = 1 } 说明：在main方法中，我们定义一个变量intValue，其值为1，再调用tripleValue方法，将x传入，完成函数调用后在console上打印x的值，结果还是为原来的值，并未改变。tripleValue方法被调用整个过程运行的步骤如下： 1. x被初始化，且其值为调用者传递参数doubleValue的一个拷贝，即 x = 10 2. 运算x = x * 3 ,即 x * 3 = 30 ，30赋值给x，x = 30 ，x为intValue的一个拷贝，x变了，但是intValue却未曾改变 3. 方法运行结束，释放x 例子2用一个方法实现将一个员工的工资提高2倍 public static void tripleSalary(Employee e) { // 可以实现 e.raiseSalary(200); //e的salary提高200% } public static void main(String... args) { Employee harry = new Employee(...); tripleSalary(harry); System.out.println(harry.salary); } 说明：在main方法中，我们实例化一个Employee对象harry，再调用tripleSalary方法来提高员工的工资，将harry传入，完成函数调用后在console上打印harry的工资，结果工资真的提高的两倍。tripleSalary方法被调用整个过程运行的步骤如下： 1. e被初始化，并且为harry的值的拷贝，这里是一个对象的引用 2. e和harry同时引用一个Employee对象，所以e提高了工资相当于提高了harry的工资 3. 方法运行结束，释放e 例子3很多程序员认为Java中对对象采用的是引用传递，实际上，这样理解是错误的。由于这种误解具有一定的普遍性，所以下面采用一个反例方法来说明，该方法是交换两个员工的对象 public static void swap(Employee x, Employee y) { //无法实现 Employee e = x; x = y; y = e; } public static void main(String[] args) { Employee a = new Employee(&quot;Alice&quot;, ...); Employee b = new Employee(&quot;Bob&quot;, ...); swap(a, b); } 说明：在main方法中，实例化了两个员工对象，分别是Alice和Bob，然后传递给swap方法。x和y拷贝了a和b，也就是引用了a和b对象，在swap方法内部将x和y进行交换，确实是可以的，交换完成后x引用Bob，y引用Alice，但是，重点是，a还是引用Alice，b还是引用Bob，并没有改变。最后，swap方法结束，x和y也别GC回收。所以，Java中对对象的传递是值传递而不是引用调用，此操作也就是白费了力气。 总结我们首先说明、强调了Java中方法的参数传递不同于其他语言，总是对值的传递而不是引用调用，再用三个例子来说明，下面用3点来总结一下Java中方法参数的使用： 一个方法不能修改一个基本数据类型的参数（即数值型或者布尔型） 一个方法可以修改一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 参考文章 Java核心技术 卷I 基础知识","tags":[{"name":"Java","slug":"Java","permalink":"http://linzhs.cm/tags/Java/"}]},{"title":"CentOS-7个人静态博客Hexo搭建（适合新手）","date":"2017-03-10T19:03:42.989Z","path":"2017/03/11/HowToBuildHexoBlog/","text":"CentOS-7个人静态博客Hexo搭建（适合新手）前言最近，借助网上强大的博客资源，自己在个人服务器上搭建了hexo静态博客。在整个搭建的过程中间学到了很多，虽然过程并不是一帆风顺。现写下自己的经验，来与大家分享，希望能够起到作用。 个人服务器和域名准备（本文操作基于个人服务器和GitHub）这里的个人服务器是指虚拟服务器（VPS），一般需要购买。现在国内比较有名的VPS供应商是阿里云和腾讯云。国外的服务器可以考虑AWS，现在支持12月免费体验，当然也可以选择搬瓦 工这些便宜实用的，国外的服务器还可以在上面部署ShadowSocks/SSR实现科学上网。只有服务器没有域名和相应的解析操作，那在浏览器上访问博客服务器只能用IP，那是何等的尴尬。可以在国内或者国外的域名申请服务商购买，本人无实际购买经验，在这里就先不推荐了。DNS解析可以用DNSPOD，还不错。 本博主为学生，所以干脆利落地选择了腾讯的学生云，1月1元起飞，域名1年1元起飞。 个人博客开源平台对比 WordPress: 动态博客基于php、MySQL，必须有VPS支持，功能很强大，可通过浏览器访问数据库进行博客后台管理，但平台的插件安装和博客迁移比较麻烦。 Jekyll: 静态博客，可托管到GitHub，功能比较强大，但是所采用的liquid语法对程序员不太友好。 Octopress: 基于Jekyll的静态网站生成引擎。 Hexo: 基于Node.js的静态博客，比较热门，其免费、方便、速度快、可托管到GitHub。 系统服务器配置本文搭建的博客基于如何系统服务器配置： 系统版本：CentOS-7.2-x64 USER: root Firewall: stop SeLinux: stop 建站所需服务支持 Nginx 网页服务器 Node.js 环境(JavaScript) Hexo博客平台 Git (非必须) 依赖服务安装 Nginx安装 [root@ ~#] yum -y install nginx Git安装 [root@ ~#] yum install -y git [root@ ~#] git config --global user.name &quot;linzh&quot; Node.js环境搭建 可以在Node.js官网下载binary package编译安装，这种方式需要安装gcc等编译器。本文使用nvm的方式安装 nvm的最新版本可以在GitHub上参看，附有安装教程（English version）,当前安装版本为v0.33.1。 下面的安装方法二选一(注意默认的安装路径为当前用户的home目录) [root@ ~#] curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash #二选一 [root@ ~#] wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash #二选一 [root@ ~#] source ~/.bashrc #使配置信息生效 安装好nvm后查看当前可用的版本，并选取最新的版本安装(当前使用的版本为v6.10.0) [root@ ~#] nvm ls-remote #查看可用版本 [root@ ~#] nvm install v6.10.0 #安装最新版本 [root@ ~#] nvm alias default v6.10.0 #将v6.10.0设置为默认版本 [root@ ~#] nvm use default Hexo平台搭建 这里使用npm安装hexo客户端和服务端 [root@ ~#] npm install -g hexo-cli #g -&gt; global [root@ ~#] npm install -g hexo-server 若用npm安装速度很慢的话，可以考虑更换npm镜像为淘宝镜像 [root@ ~#] npm install -g cnpm --registry=https://registry.npm.taobao.org 初次体验 初始化hexo环境 [root@ ~#] hexo init hexo_blog # 在当前目录下建立hexo博客目录 [root@ ~#] cd hexo_blog [root@ ~#] npm install 完成后会生成hexo相关文件，其中_config.yml为配置文件，具体配置可参考hexo官方文档。这里建议设置default_layout为draft，这样默认生成文章在Draft里，确认后再发布到Public。 发布文章 [root@ ~#] hexo new hello_post #新建文章 [root@ ~#] vim ~/hexo_blog/source/_drafts/hello_post.md #编辑文章内容 [root@ hexo_blog#] hexo publish hello_post #发布文章，hello_post.md会从_drafts目录移动到_post目录 运行服务启动服务器，默认起在4000端口，成功后访问http://localhost:4000 预览效果 [root@ ~#] hexo server 托管部署这里我们将博客的文件托管到GitHub，国内现在可以考虑托管到码云上，听名字就很霸气！ 新建 Repository 托管代码需要一个仓库（如何新建仓库，请自行search，此处省略数字），仓库名为hexo_repo（仓库名可以根据自己的爱好取，注意接下来的步骤需要对应此名称） 配置hexo部署方式 进入服务器的hexo博客主目录，编辑_config.yml文件，修改deploy项。这里的$username需要换成你的GitHub的账户 deploy: type: git repo: https://github.com/$username/hexo_repo.git branch: master 安装hexo一键git推送插件 [root@ hexo_blog#] npm install hexo-deployer-git --save 部署 [root@ hexo_blog#] hexo -g # 也可以使用全称 hexo -generate [root@ hexo_blog#] hexo -d # 也可以使用全称 hexo -deploy 输入命令后会提示输入GitHub的账号密码，输入完成后即已将代码提交到GitHub上了。 自动化部署发布每次发布博文都要经过创建文章，推送GitHub托管代码，hexo生成发布，挺麻烦的，现在来实现一键自动化。自动化的思路：编写一个脚本，该脚本执行的时候生成博客静态文件，通过hexo deploy实现自动提交到GitHub，然后通过本地更新代码，对关联的空分支进行git push操作，触发git的post-receive钩子，从而将静态文件同步到/var/www/hexo目录，而该目录正是Nginx将80端口转发到本地的路径（反向代理）。 在服务器上建立hexo博客git仓库 [root@ ~#] git init –bare ~/hexo_bare 创建git hooks 这里使用git的post-receive钩子，当本地绑定仓库执行git push后触发。 [root@ ~#] vim ~/hexo_bare/hooks/post-receive post-receive文件具体内容(注意$USER): #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/home/$USER/hexo_bare checkout -f 将空仓库关联到主仓库 [root@ ~#] git clone https://github.com/$username/hexo_repo.git ~/hexo_static [root@ ~#] cd ~/hexo_static [root@ ~#] git remote add live ~/hexo_bare 创建自动化脚本 [root@ ~#] vim ~/hexo_blog/hexo_git_deploy.sh 脚本内容如下 #!/bin/bash hexo clean hexo generate hexo deploy ( cd ~/hexo_static ; git pull ; git push live master) 配置Nginx反向代理 修改/var/www/html目录的权限，此目录默认为Nginx的请求映射目录 [root@ ~#] chown -R $USER:$USER /var/www/hexo [root@ ~#] chmod -R 755 /var/www/hexo 编辑Nginx配置文件(当前使用的系统为centos7.2，nginx和系统版本不一，配置文件的位置可能也不一) [root@ ~#] cp /ect/nginx/nginx.conf /ect/nginx/nginx.conf.bak #备份 [root@ ~#] vim /ect/nginx/nginx.conf #编辑 找到server块，内容大致如下 server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/www/hexo; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; #反向代理重点配置部分 location / { root /var/www/hexo; index index.html index.htm; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 编辑好Nginx配置文件后重启Nginx服务 [root@ ~#] systemctl restart nginx 总结到此，hexo静态博客的基本搭建已经完成，我们总结一下发布文章或者更新文章的流程 $ hexo new my-post $ vim ~/hexo_blog/source/_draft/my-post.md $ hexo publish my-post $ hexo generate $ hexo server $ ~/hexo_blog/hexo_git_deploy.sh 新建文章 -&gt; 编辑文章 -&gt; 发布文件 -&gt; 生成静态博客文件 -&gt; 预览 –&gt; 修改 –&gt; 最终发布 其他 美化hexo hexo官方和好心网友提供了丰富的网页主题和评论、数据统计、监控等插件，可参考hexo官方支持文档.本文借鉴了好心网友的indigo,沉浸式设计，还不错。 重点这是博主第一次写博客，好激动，但很多借鉴了网友的博文，如果有侵权问题，麻烦通知删除，谢谢！ 参考文章使用Hexo搭建个人静态博客 hexo官方文档 wordpress-jekyll-octopress-hexo四博客引擎比较 Markdown——入门指南","tags":[{"name":"hexo","slug":"hexo","permalink":"http://linzhs.cm/tags/hexo/"}]}]