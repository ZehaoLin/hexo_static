<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Linzh's Blog" type="application/atom+xml" />






<meta name="description" content="Standing on Shoulders of Giants">
<meta property="og:type" content="website">
<meta property="og:title" content="Linzh's Blog">
<meta property="og:url" content="http://linzhs.cm/index.html">
<meta property="og:site_name" content="Linzh's Blog">
<meta property="og:description" content="Standing on Shoulders of Giants">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linzh's Blog">
<meta name="twitter:description" content="Standing on Shoulders of Giants">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linzhs.cm/"/>





  <title>Linzh's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Linzh's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Standing on Shoulders of Giants</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/java-generic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/java-generic/" itemprop="url">Java随笔 - 泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:17:38+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java随笔-泛型"><a href="#Java随笔-泛型" class="headerlink" title="Java随笔 - 泛型"></a>Java随笔 - 泛型</h1><h2 id="泛型的基本用法"><a href="#泛型的基本用法" class="headerlink" title="泛型的基本用法"></a>泛型的基本用法</h2><p>泛型类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Pair&lt;T&gt; &#123;</div><div class="line">    private T first;</div><div class="line">    private T second;</div><div class="line">    </div><div class="line">    public T getFirst() &#123;</div><div class="line">        return first;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setFirst(T t) &#123;</div><div class="line">        this.first = t;W</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Pair&lt;K, V&gt; &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>泛型方法，可以在普通类中存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ArrayAlg &#123;</div><div class="line">    public static &lt;T&gt; T getMiddle(T...a) &#123;</div><div class="line">        return a[a.lenght / 2];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用一个泛型方法时，在方法名前的尖括号放入具体的类型，大多数情况下，编译器有能力推导出具体的类型，所以尖括号部分的类型可以省略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;John&quot;, &quot;Q.&quot;, &quot;Public&quot;);</div><div class="line">String middle = ArrayAlg.getMiddle(&quot;John&quot;, &quot;Q.&quot;, &quot;Public&quot;);</div></pre></td></tr></table></figure></p>
<p>少数情况下会报错的情形如下，参数的类型不对应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">double middle = ArrayAlg.getMiddle(3.14, 122, 0);</div></pre></td></tr></table></figure></p>
<p>以上例子参数中，参数分别是double和int，编译器会将他们分别打包成Double和Integer，然后生成两种类型的方法，这两个方法都是合法的，但是他们放在一起使用，没有共同的超类型。</p>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>单个限定<figure class="highlight plain"><figcaption><span>extends Comparable>```， 多个限定用&做间隔```<t extends="" comparable="" &="" serializable="">```。</t></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上例子限定T要去实现相应的接口，用的关键词是extends而不是implements，表示T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口，选定extends关键词的原因是其更接近子类的意思。</div><div class="line"></div><div class="line">Java中类是单继承的，所以限定类型为类时，只能是限定列表的第一个。</div><div class="line"></div><div class="line">## 泛型的实现细节</div><div class="line">编译器将代码编译完成后交给虚拟机来运行时，虚拟机中是不存在泛型这种类型对象的，所有泛型的对象都会变成指定类型的普通类对象。也就是说泛型其实是一种类，可以指定为很多种类型变量的类，很多工作都交给了编译器来完成。</div><div class="line"></div><div class="line">### 类型擦除</div><div class="line">为什么在编译过后，运行在虚拟机上的代码是没有泛型类型的，这是因为编译器对泛型做了类型擦除（type erasure）操作。经过类型擦除后，泛型类型都会自动转换为相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。</div><div class="line"></div><div class="line">擦除变量有以下两种情况：</div><div class="line">* 无限定类型</div><div class="line"></div><div class="line">此情况下T将被替换成Object类型，并擦除&lt;T&gt;，如下示例：</div></pre></td></tr></table></figure></p>
<p>public class Pair<t> {<br>    private T first;<br>    public T getFirst() {<br>        return first;<br>    }</t></p>
<pre><code>...
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">擦除后 -&gt;</div></pre></td></tr></table></figure></p>
<p>public class Pair {<br>    private Object first;<br>    public Object getFirst() {<br>        return first;<br>    }</p>
<pre><code>...
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; C\++的模板和Java泛型在这一点上的实现有很大的区别，C++的每个模板的实例化产生的类型都是不一样的，这样很容易导致“模板代码膨胀”现象。</div><div class="line"></div><div class="line">* 有限定类型</div><div class="line"></div><div class="line">泛型类型变量若有限定类型，那原始类型用限定表中的第一个类型变量来替换。</div></pre></td></tr></table></figure></p>
<p>public class Interval<t extends="" comparable="" &="" serializable=""> implements Serializable {<br>    private T lower;<br>    private T upper;<br>    …<br>    public Interval(T first, T second) {<br>        if (first.compareTo(second) &gt;= 0) {<br>            lower = first;<br>            upper = second;<br>        } else {<br>            lower = second;<br>            upper = first;<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">擦除后 -&gt;</div></pre></td></tr></table></figure></t></p>
<p>public class Interval implements Serializable {<br>    private ComparableComparable lower;<br>    private Comparable upper;<br>    …<br>    public Interval(Comparable first, Comparable second) {<br>        if (first.compareTo(second) &gt;= 0) {<br>            lower = first;<br>            upper = second;<br>        } else {<br>            lower = second;<br>            upper = first;<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">T的限定变量书写的顺序并没有严格的要求，也可以写成```class Interval&lt;T extends Serializable &amp; Comparable&gt;```。这样书写，编译器会把T替换成Serializable，而需要用到Comparable时，编译器会在相应的代码中插入强制类型转换。为了提高效率，比较好的习惯是将标签（tagging）接口，也就是没有方法的接口放在限定列表的末尾。</div><div class="line"></div><div class="line">### 翻译泛型表达式</div><div class="line">在T没有限定类型时，调用一个有返回值的泛型方法时，由于类型擦除，返回的是Object类型，所以编译器会在返回值的代码上插入强制类型转换。</div></pre></td></tr></table></figure></p>
<p>Pair<employee> buddies = …;<br>Employee buddy = buddies.getFirst();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">以上代码，翻译成虚拟指令就是：</div><div class="line">* 调用原始方法Pair.getFirst</div><div class="line">* 将返回的Object类型强制转换为Employee类型。</div><div class="line"></div><div class="line">同理，对于泛型的公有域也是如此，但是不推荐有公有泛型域。</div><div class="line"></div><div class="line">### 翻译泛型方法</div><div class="line">泛型方法的翻译要注意的问题是保持多态性。实例分析：</div></pre></td></tr></table></figure></employee></p>
<p>public class DateInterval extends Pair<localdate> {<br>    public void setSecond(LocalDate second) {<br>        if (second.compareTo(getFirst()) &gt;= 0) {<br>            super.setSecond(second);<br>        }<br>    }<br>    …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类型擦除后 -&gt;</div></pre></td></tr></table></figure></localdate></p>
<p>public class DateInterval extends Pair {<br>    public void setSecond(LocalDate second) {<br>        …<br>    }<br>    …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DateInterval继承自Pair，Pair中也有一个setSecond方法，为```public void setSecond(Object second)```，也就是DateInterval被编译器做完类型擦除处理后，内部存在两个setSecond方法:</div></pre></td></tr></table></figure></p>
<p>public void setSecond(LocalDate second);<br>public void setSecond(Object second);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在，要使用setSecond方法，</div></pre></td></tr></table></figure></p>
<p>DateInterval interval = new DateInterval(…);<br>Pair<localdate> pair = interval;//super类对象引用子类，多态性<br>pair.setSecond(aDate);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在调用setSecond方法的时候，为了适合多态性，编译器需要给调用的方法选择最合适的实现方法。因为pair应用的是子类DateInterval对象，正常来说调用的应该是DateInterval.setSecond，但是现在由于类型擦除的原因使得与多态性发生了冲突，不能去调用DateInterval.setSecond方法。</div><div class="line"></div><div class="line">要解决此问题，就需要编译器做一些中间工作，那就是z在DataInterval类中生成一个桥方法（bridge method）：</div></pre></td></tr></table></figure></localdate></p>
<p>public void setSecond(Object second) {<br>    setSecond((Date)second);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 泛型的约束和局限性</div><div class="line">&gt; Java中泛型的很多限制其实都来自其底层的实现，就是类型擦除。</div><div class="line"></div><div class="line">### 不能用基本类型实例化类型参数</div><div class="line">没有```Pair&lt;double&gt;```，只有```Pair&lt;Double&gt;```，原因是经过类型擦除后，类型会被替换成Object，double和Object不对应，所以不能存储double值，只有Object类型的域。</div><div class="line"></div><div class="line">### 运行时的类型查询只适用于原始类型</div><div class="line">泛型经过编译器的类型擦除后，虚拟中只剩下一个非泛型类型，比如Pair&lt;T&gt;，类型擦除后，放在虚拟机中运行，只有Pair。</div><div class="line"></div><div class="line">运行时试图查询一个对象是否属于某个泛型类型时，若使用instanceof编译器会报错，若用强制类型转换则会得到一个警告。</div></pre></td></tr></table></figure></p>
<p>if (a instanceof Pair<string>)//error<br>if (a instanceof Pair<t>)//error<br>Pair<string> p = (Pair<string>)a;//warning<br>if (a instanceof Pair)//ok,it is true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">另一个例子：</div></pre></td></tr></table></figure></string></string></t></string></p>
<p>Pair<string> stringPair = …;<br>Pair<employee> employeePair = …;<br>System.out.println(stringPair.getClass() == employeePair.getClass());// print “true”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">比较后的结果是true，因为虚拟机中只有Pair，返回的都是Pair.class。</div><div class="line"></div><div class="line">### 不能创建参数化类型的数组</div><div class="line">可以声明参数类化型的数组，但是不能实例化</div></pre></td></tr></table></figure></employee></string></p>
<p>Pair<string>[] table;//OK<br>table = new Pair<string>[10];//error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">原因是，经过编译器的类型擦除后，数组会变成Pair[]。</div><div class="line"></div><div class="line">### Varargs警告</div><div class="line">有时候泛型方法的参数是可变的，这时候参数其实是接收了一个参数数组，若这个数组接收的都是泛型，那么就存在上面的问题--不能创建参数化类型的数组。为了能通过编译，可以加入注解（二选一）：</div></pre></td></tr></table></figure></string></string></p>
<p>@SuppressWarnings(“unchecked”)<br>@SafeVarargs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">通过注解可以顺利运行，但是在处理table[0]的时候还是会抛出一个异常。</div><div class="line"></div><div class="line">### 不能实例化类型变量</div><div class="line">不能如此使用类型变量：</div></pre></td></tr></table></figure></p>
<p>new T(…)<br>new T[…]<br>T.calss<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原因是，类型擦除后都会变成Object，但是本意却不是想new  Object()。</div><div class="line"></div><div class="line">### 不能构造泛型数组</div></pre></td></tr></table></figure></p>
<p>public static <t extends="" comparable=""> T[] minmax(T[] a) {<br>    T[] t = new T[2];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">类型擦除后，得到的数组永远是Comapable[2]。</div><div class="line"></div><div class="line">可以使用强制类型转换，让类型擦除无法察觉，但是运行的时候还是会抛出异常。</div><div class="line"></div><div class="line">### 方形类的静态上下文中类型变量无效</div><div class="line">不能在静态域或者方法中应用类型变量。</div></pre></td></tr></table></figure></t></p>
<p>public class Singleton<t> {<br>    private static T singleInstance;//error</t></p>
<pre><code>public static T getSingleInstance() {//error
    if (singleInstance == null)
        singleInstance = new Singleton&lt;&gt;();
    return singleInstance;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">类型擦除后，只剩下Singleton类，且只包含singleInstance域，不能再被指定泛型并且创建。</div><div class="line"></div><div class="line">### 不能抛出或者捕获泛型类的实例</div><div class="line">不能抛出，也不能捕获泛型类对象，泛型类也不能扩展Throwable。</div></pre></td></tr></table></figure></p>
<p>public class Problem<t> extends Exception {}//error<br>public static <t extends="" throwable=""> void doWork(Class<t> t) {//error<br>    try {</t></t></t></p>
<pre><code>} catch (T e) {

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不过以下例子是允许的:</div></pre></td></tr></table></figure></p>
<p>public static <t extends="" throwable=""> void doWork(T t) throws T {<br>    try {</t></p>
<pre><code>} catch (Throwable e) {
    t.initCause(e);
    throw t;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 可以消除对受查异常的检查</div><div class="line">Java异常处理的一个原则是，对所有受查异常，必须提供一个处理器。若是使用泛型，可以绕开这个原则，然后包装到非受查异常中，就可以欺骗编译器。</div></pre></td></tr></table></figure></p>
<p>@SuppressWarnings(“unchecked”)<br>public static <t extends="" trowable=""> void doWorkAs(Throwable e) throws T {<br>    throw (T) e;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 注意擦除后的冲突</div></pre></td></tr></table></figure></t></p>
<p>public calss Pair<t> {<br>    public boolean equals(T values) {<br>        …<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">泛型类Pair，在类型擦除后，equal方法变成了boolean equals(Object)，这是和Object中的equals方法冲突的。</div><div class="line"></div><div class="line">## 泛型类型的继承规则</div><div class="line">假设Manager是Employee的子类，但是，Pair&lt;Manager&gt;不是Pair&lt;Employee&gt;的子类，两者并没有什么关系，所以不能用Pair&lt;Employee&gt;对象变量引用Pair&lt;Manager&gt;，但是两者都可以用Pair引用，因为两者都继承于Pair。</div></pre></td></tr></table></figure></t></p>
<p>Manager[] m = …;<br>Pair<employee> e = ArraAlg.minmax(m);//error<br>Pair<manager> p = new Pair&lt;&gt;(…);<br> Pair t = p;//ok<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 通配符类型</div><div class="line">通配符类型中，允许类型参数变化，比如：</div></pre></td></tr></table></figure></manager></employee></p>
<p> Pair&lt;? extends Employee&gt;<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair&lt;Manager&gt;，而Pair&lt;String&gt;就不是。</div><div class="line"></div><div class="line">### 通配符的超类限定</div></pre></td></tr></table></figure></p>
<p> ? super Manager<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个通配符限定Manger为所有类型的超类。</div><div class="line"></div><div class="line">### 无限定通配符</div></pre></td></tr></table></figure></p>
<p> public class Pair&lt;?&gt; {<br>     ? getFirst() {…}<br>     void setFirst(?) {…}<br> }<br> ```<br> 例子中getFirst的返回值只能赋给一个Object，而setFirst方法不能被调用，甚至不能用Object调用。</p>
<p> Pair&lt;?&gt;和Pair本质的区别在于，可以用任意Object对象调用原始Pair类的setOnjevt方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-aidl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-aidl/" itemprop="url">Android接口定义语言（AIDL）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:16:29+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-接口定义语言-AIDL"><a href="#Android-接口定义语言-AIDL" class="headerlink" title="Android 接口定义语言 (AIDL)"></a>Android 接口定义语言 (AIDL)</h1><p>AIDL可以定义客户端与服务使用IPC机型互相通信时都认可的编程接口。在Android，进程是fork形式存在的，独自占有一块内存，一个进程无法访问另一个进程的内存。但是，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。Android使用AIDL来执行这一编组操作的代码繁琐工作。</p>
<blockquote>
<p>注：只有允许不同应用的客户端用IPC方式访问服务，并且想要在服务中处理多线程，才有必要使用AIDL。如果不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。</p>
</blockquote>
<h2 id="定义AIDL接口"><a href="#定义AIDL接口" class="headerlink" title="定义AIDL接口"></a>定义AIDL接口</h2><p>Android Studio下新建AIDL文件（基本已经全自动完成了），会默认生成一个aidl文件夹，并把.aidl文件放入这里。Android SDK工具都会生成一个基于该.aidl文件的IBinder接口。并且保存到项目的 gen/ 目录中，生成的文件名与.aidl文件名一致，只是使用了.java（例如：IRemoteService.aidl 生成的文件名是 IRemoteService.java）。服务必须视情况实现IBinder接口，然后客户端应用便可绑定到该服务，并调用IBinder中的方法来执行IPC。</p>
<p>使用AIDL创建绑定服务，执行以下步骤：</p>
<ol>
<li><p>创建.aidl文件</p>
<p> 此文件定义带有方法签名的编程接口。</p>
</li>
<li><p>实现接口</p>
<p> Android SDK工具基于创建的.aidl文件，使用Java编程语言生成一个接口。此接口另有一个名为Stub的内部抽象类，用于拓展Binder类并实现AIDL接口中的方法。必须要拓展Stub类并实现方法。</p>
</li>
<li><p>向客户端公开该接口</p>
<p> 实现 Service 并重写 onBind() 以返回 Stub 类的实现。</p>
</li>
</ol>
<blockquote>
<p>注意：在 AIDL 接口首次发布后对其进行的任何更改都必须保持向后兼容性，以避免中断其他应用对服务的使用。 也就是说，因为必须将自己的 .aidl 文件复制到其他应用，才能让这些应用访问这个服务的接口，因此必须保留对原始接口的支持。</p>
</blockquote>
<h3 id="创建-aidl文件"><a href="#创建-aidl文件" class="headerlink" title="创建.aidl文件"></a>创建.aidl文件</h3><p>AIDL使用简单的语法，这样可以通过可带参数和返回值的一个或多个方法来声明接口。参数和返回值可以是任意类型，甚至可以是其他AIDL生成的接口。</p>
<p>.aidl文件有Java构建，每个.aidl文件都必须定义单个接口，并且只需包含接口声明和方法签名。</p>
<p>默认情况下，AIDL支持以下数据类型：</p>
<ul>
<li>Java支持的所有基本数据类型（int, double, float, boolean, char long等）</li>
<li>String</li>
<li>CharSequence</li>
<li>List</li>
<li>Map</li>
</ul>
<blockquote>
<p>List和Map中的所有元素都必须是以上列表中支持的数据类型，其他AIDL生成的接口或自己声明的可打包的类型。不支持通用 Map（如 Map<string,integer> 形式的 Map）。 另一端实际接收的具体类始终是 HashMap/ArrayList，但生成的方法使用的是 Map/List 接口。</string,integer></p>
</blockquote>
<p>定义服务接口时要注意：</p>
<ul>
<li>方法可带0到多个参数，返回值可以为空</li>
<li>所有非原语参数都需要指示数据走向的方向标记。可以是in、out、inout。原语（基本类型）默认是in，不能是其他方向。应该将方法限定为真正需要的方向，因为编组参数的开销极大。</li>
<li>.aidl文件中包括的所有代码注释都包含在生成的IBinder接口中（import和package语句之前的注释除外）</li>
<li>只支持方法，不能公开AIDL中的静态字段。</li>
</ul>
<p>.aidl demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// IRemoteService.aidl</div><div class="line">package com.example.android;</div><div class="line"></div><div class="line">// Declare any non-default types here with import statements</div><div class="line"></div><div class="line">/** Example service interface */</div><div class="line">interface IRemoteService &#123;</div><div class="line">    /** Request the process ID of this service, to do evil things with it. */</div><div class="line">    int getPid();</div><div class="line"></div><div class="line">    /** Demonstrates some basic types that you can use as parameters</div><div class="line">     * and return values in AIDL.</div><div class="line">     * 默认生成的方法，告知你可以使用哪些数据类型</div><div class="line">     */</div><div class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</div><div class="line">            double aDouble, String aString);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>创建的AIDL文件会被转换成同名的.java文件，并且内部包含一个Stub子类，这个子类是其父接口（例如：YourInterface.Stub）的抽象实现，用于声明.aidl文件中的所有方法。</p>
<p>要实现.aidl生成的接口，就要拓展生成的Binder接口并实现从.aidl文件继承的方法。</p>
<p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123;</div><div class="line">    public int getPid()&#123;</div><div class="line">        return Process.myPid();</div><div class="line">    &#125;</div><div class="line">    public void basicTypes(int anInt, long aLong, boolean aBoolean,</div><div class="line">        float aFloat, double aDouble, String aString) &#123;</div><div class="line">        // Does nothing</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>现在，mBinder 是 Stub 类的一个实例（一个 Binder），用于定义服务的 RPC 接口。 在下一步中，将向客户端公开该实例，以便客户端能与服务进行交互。</p>
<p>在实现 AIDL 接口时应注意遵守以下这几个规则：</p>
<ul>
<li>由于不能保证在主线程上执行传入调用，因此一开始就需要做好多线程处理准备，并将服务正确地编译为线程安全服务。</li>
<li>默认情况下，RPC 调用是同步调用。如果您明知服务完成请求的时间不止几毫秒，就不应该从 Activity 的主线程调用服务，因为这样做可能会使应用挂起（Android 可能会显示“Application is Not Responding”对话框）— 您通常应该从客户端内的单独线程调用服务。</li>
<li>引发的任何异常都不会回传给调用方。</li>
</ul>
<h3 id="向客户端公开该接口"><a href="#向客户端公开该接口" class="headerlink" title="向客户端公开该接口"></a>向客户端公开该接口</h3><p>服务实现该接口后，就需要向客户端公开该接口，以便客户端进行绑定。要为服务公开该接口，需要拓展Service类并且实现onBinder()，以返回一个类实例，这个类实现了生成的Stub。</p>
<p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class RemoteService extends Service &#123;</div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        // Return the interface</div><div class="line">        return mBinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123;</div><div class="line">        public int getPid()&#123;</div><div class="line">            return Process.myPid();</div><div class="line">        &#125;</div><div class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean,</div><div class="line">            float aFloat, double aDouble, String aString) &#123;</div><div class="line">            // Does nothing</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端还必须具有对 interface 类的访问权限，因此如果客户端和服务在不同的应用内，则客户端的应用 src/ 目录内必须包含 .aidl 文件（它生成 android.os.Binder 接口 — 为客户端提供对 AIDL 方法的访问权限）的副本。</p>
<p>当客户端在 onServiceConnected() 回调中收到 IBinder 时，它必须调用 YourServiceInterface.Stub.asInterface(service) 以将返回的参数转换成 YourServiceInterface 类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">IRemoteService mIRemoteService;</div><div class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">    // Called when the connection with the service is established</div><div class="line">    public void onServiceConnected(ComponentName className, IBinder service) &#123;</div><div class="line">        // Following the example above for an AIDL interface,</div><div class="line">        // this gets an instance of the IRemoteInterface, which we can use to call on the service</div><div class="line">        mIRemoteService = IRemoteService.Stub.asInterface(service);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Called when the connection with the service disconnects unexpectedly</div><div class="line">    public void onServiceDisconnected(ComponentName className) &#123;</div><div class="line">        Log.e(TAG, &quot;Service has unexpectedly disconnected&quot;);</div><div class="line">        mIRemoteService = null;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="通过IPC传递对象"><a href="#通过IPC传递对象" class="headerlink" title="通过IPC传递对象"></a>通过IPC传递对象</h2><p>通过IPC接口把某个类从一个进程发送到另一进程是可以实现的。不过必须要确保该类的代码对IPC通信的另一端可用，并且该类必须支持Parcelable接口。支持Parcelable接口是很重要的，Android系统可通过它将对象分解成可编组到各进程的原语。</p>
<blockquote>
<p>.aidl与C语言中的头文件类似，编译的时候不用添加.aidl文件，其并未被编译。</p>
</blockquote>
<p>以下这个 Rect.aidl 文件可创建一个可打包的 Rect 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package android.graphics;</div><div class="line"></div><div class="line">// Declare Rect so AIDL can find it and knows that it implements</div><div class="line">// the parcelable protocol.</div><div class="line">parcelable Rect;</div></pre></td></tr></table></figure></p>
<p>Rect类实现Parcelable接口实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import android.os.Parcel;</div><div class="line">import android.os.Parcelable;</div><div class="line"></div><div class="line">public final class Rect implements Parcelable &#123;</div><div class="line">    public int left;</div><div class="line">    public int top;</div><div class="line">    public int right;</div><div class="line">    public int bottom;</div><div class="line"></div><div class="line">    public static final Parcelable.Creator&lt;Rect&gt; CREATOR = new</div><div class="line">Parcelable.Creator&lt;Rect&gt;() &#123;</div><div class="line">        public Rect createFromParcel(Parcel in) &#123;</div><div class="line">            return new Rect(in);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Rect[] newArray(int size) &#123;</div><div class="line">            return new Rect[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public Rect() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Rect(Parcel in) &#123;</div><div class="line">        readFromParcel(in);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void writeToParcel(Parcel out) &#123;</div><div class="line">        out.writeInt(left);</div><div class="line">        out.writeInt(top);</div><div class="line">        out.writeInt(right);</div><div class="line">        out.writeInt(bottom);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void readFromParcel(Parcel in) &#123;</div><div class="line">        left = in.readInt();</div><div class="line">        top = in.readInt();</div><div class="line">        right = in.readInt();</div><div class="line">        bottom = in.readInt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="调用IPC方法"><a href="#调用IPC方法" class="headerlink" title="调用IPC方法"></a>调用IPC方法</h2><p>调用类必须执行以下步骤，才能调用使用AIDL定义的远程接口：</p>
<ol>
<li>在项目src/目录中加入.aidl文件（Android Studio已默认创建）。</li>
<li>声明一个IBinder接口实例（基于AIDL生成）。</li>
<li>实现ServiceConnection</li>
<li>调用Context.bindService()，以传入ServiceConnection的实现。</li>
<li>再实现的onServiceConnected()中，将收到一个名为service的IBinder实例。调用YourInt<a href="">erfaceName.Stub.asInterface((IBinder)service)</a>，以将返回的参数转换为 YourInterface 类型。</li>
<li>调用再接口上定义的方法。注意要始终捕获DeadObjectException异常，他们是连接中断时引发的，这也是远程方法引起的唯一异常。</li>
<li>如需断开连接，需要在接口中调用Conext.unBindService()。</li>
</ol>
<p>有关调用 IPC 服务的几点说明：</p>
<ul>
<li>对象是跨进程计数的引用。</li>
<li>可以将匿名对象作为方法参数发送。</li>
</ul>
<p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div></pre></td><td class="code"><pre><div class="line">public static class Binding extends Activity &#123;</div><div class="line">    /** The primary interface we will be calling on the service. */</div><div class="line">    IRemoteService mService = null;</div><div class="line">    /** Another interface we use on the service. */</div><div class="line">    ISecondary mSecondaryService = null;</div><div class="line"></div><div class="line">    Button mKillButton;</div><div class="line">    TextView mCallbackText;</div><div class="line"></div><div class="line">    private boolean mIsBound;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Standard initialization of this activity.  Set up the UI, then wait</div><div class="line">     * for the user to poke it before doing anything.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        setContentView(R.layout.remote_service_binding);</div><div class="line"></div><div class="line">        // Watch for button clicks.</div><div class="line">        Button button = (Button)findViewById(R.id.bind);</div><div class="line">        button.setOnClickListener(mBindListener);</div><div class="line">        button = (Button)findViewById(R.id.unbind);</div><div class="line">        button.setOnClickListener(mUnbindListener);</div><div class="line">        mKillButton = (Button)findViewById(R.id.kill);</div><div class="line">        mKillButton.setOnClickListener(mKillListener);</div><div class="line">        mKillButton.setEnabled(false);</div><div class="line"></div><div class="line">        mCallbackText = (TextView)findViewById(R.id.callback);</div><div class="line">        mCallbackText.setText(&quot;Not attached.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Class for interacting with the main interface of the service.</div><div class="line">     */</div><div class="line">    private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">        public void onServiceConnected(ComponentName className,</div><div class="line">                IBinder service) &#123;</div><div class="line">            // This is called when the connection with the service has been</div><div class="line">            // established, giving us the service object we can use to</div><div class="line">            // interact with the service.  We are communicating with our</div><div class="line">            // service through an IDL interface, so get a client-side</div><div class="line">            // representation of that from the raw service object.</div><div class="line">            mService = IRemoteService.Stub.asInterface(service);</div><div class="line">            mKillButton.setEnabled(true);</div><div class="line">            mCallbackText.setText(&quot;Attached.&quot;);</div><div class="line"></div><div class="line">            // We want to monitor the service for as long as we are</div><div class="line">            // connected to it.</div><div class="line">            try &#123;</div><div class="line">                mService.registerCallback(mCallback);</div><div class="line">            &#125; catch (RemoteException e) &#123;</div><div class="line">                // In this case the service has crashed before we could even</div><div class="line">                // do anything with it; we can count on soon being</div><div class="line">                // disconnected (and then reconnected if it can be restarted)</div><div class="line">                // so there is no need to do anything here.</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // As part of the sample, tell the user what happened.</div><div class="line">            Toast.makeText(Binding.this, R.string.remote_service_connected,</div><div class="line">                    Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onServiceDisconnected(ComponentName className) &#123;</div><div class="line">            // This is called when the connection with the service has been</div><div class="line">            // unexpectedly disconnected -- that is, its process crashed.</div><div class="line">            mService = null;</div><div class="line">            mKillButton.setEnabled(false);</div><div class="line">            mCallbackText.setText(&quot;Disconnected.&quot;);</div><div class="line"></div><div class="line">            // As part of the sample, tell the user what happened.</div><div class="line">            Toast.makeText(Binding.this, R.string.remote_service_disconnected,</div><div class="line">                    Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Class for interacting with the secondary interface of the service.</div><div class="line">     */</div><div class="line">    private ServiceConnection mSecondaryConnection = new ServiceConnection() &#123;</div><div class="line">        public void onServiceConnected(ComponentName className,</div><div class="line">                IBinder service) &#123;</div><div class="line">            // Connecting to a secondary interface is the same as any</div><div class="line">            // other interface.</div><div class="line">            mSecondaryService = ISecondary.Stub.asInterface(service);</div><div class="line">            mKillButton.setEnabled(true);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onServiceDisconnected(ComponentName className) &#123;</div><div class="line">            mSecondaryService = null;</div><div class="line">            mKillButton.setEnabled(false);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private OnClickListener mBindListener = new OnClickListener() &#123;</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            // Establish a couple connections with the service, binding</div><div class="line">            // by interface names.  This allows other applications to be</div><div class="line">            // installed that replace the remote service by implementing</div><div class="line">            // the same interface.</div><div class="line">            Intent intent = new Intent(Binding.this, RemoteService.class);</div><div class="line">            intent.setAction(IRemoteService.class.getName());</div><div class="line">            bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">            intent.setAction(ISecondary.class.getName());</div><div class="line">            bindService(intent, mSecondaryConnection, Context.BIND_AUTO_CREATE);</div><div class="line">            mIsBound = true;</div><div class="line">            mCallbackText.setText(&quot;Binding.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private OnClickListener mUnbindListener = new OnClickListener() &#123;</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            if (mIsBound) &#123;</div><div class="line">                // If we have received the service, and hence registered with</div><div class="line">                // it, then now is the time to unregister.</div><div class="line">                if (mService != null) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        mService.unregisterCallback(mCallback);</div><div class="line">                    &#125; catch (RemoteException e) &#123;</div><div class="line">                        // There is nothing special we need to do if the service</div><div class="line">                        // has crashed.</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Detach our existing connection.</div><div class="line">                unbindService(mConnection);</div><div class="line">                unbindService(mSecondaryConnection);</div><div class="line">                mKillButton.setEnabled(false);</div><div class="line">                mIsBound = false;</div><div class="line">                mCallbackText.setText(&quot;Unbinding.&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private OnClickListener mKillListener = new OnClickListener() &#123;</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            // To kill the process hosting our service, we need to know its</div><div class="line">            // PID.  Conveniently our service has a call that will return</div><div class="line">            // to us that information.</div><div class="line">            if (mSecondaryService != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    int pid = mSecondaryService.getPid();</div><div class="line">                    // Note that, though this API allows us to request to</div><div class="line">                    // kill any process based on its PID, the kernel will</div><div class="line">                    // still impose standard restrictions on which PIDs you</div><div class="line">                    // are actually able to kill.  Typically this means only</div><div class="line">                    // the process running your application and any additional</div><div class="line">                    // processes created by that app as shown here; packages</div><div class="line">                    // sharing a common UID will also be able to kill each</div><div class="line">                    // other&apos;s processes.</div><div class="line">                    Process.killProcess(pid);</div><div class="line">                    mCallbackText.setText(&quot;Killed service process.&quot;);</div><div class="line">                &#125; catch (RemoteException ex) &#123;</div><div class="line">                    // Recover gracefully from the process hosting the</div><div class="line">                    // server dying.</div><div class="line">                    // Just for purposes of the sample, put up a notification.</div><div class="line">                    Toast.makeText(Binding.this,</div><div class="line">                            R.string.remote_call_failed,</div><div class="line">                            Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // ----------------------------------------------------------------------</div><div class="line">    // Code showing how to deal with callbacks.</div><div class="line">    // ----------------------------------------------------------------------</div><div class="line"></div><div class="line">    /**</div><div class="line">     * This implementation is used to receive callbacks from the remote</div><div class="line">     * service.</div><div class="line">     */</div><div class="line">    private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() &#123;</div><div class="line">        /**</div><div class="line">         * This is called by the remote service regularly to tell us about</div><div class="line">         * new values.  Note that IPC calls are dispatched through a thread</div><div class="line">         * pool running in each process, so the code executing here will</div><div class="line">         * NOT be running in our main thread like most other things -- so,</div><div class="line">         * to update the UI, we need to use a Handler to hop over there.</div><div class="line">         */</div><div class="line">        public void valueChanged(int value) &#123;</div><div class="line">            mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private static final int BUMP_MSG = 1;</div><div class="line"></div><div class="line">    private Handler mHandler = new Handler() &#123;</div><div class="line">        @Override public void handleMessage(Message msg) &#123;</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case BUMP_MSG:</div><div class="line">                    mCallbackText.setText(&quot;Received from service: &quot; + msg.arg1);</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-message/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-message/" itemprop="url">Android的异步消息处理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:15:40+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android的异步消息处理机制"><a href="#Android的异步消息处理机制" class="headerlink" title="Android的异步消息处理机制"></a>Android的异步消息处理机制</h1><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Android中的异步消息处理机制由4个部分组成：Message、Handler、MessageQueue、Looper。</p>
<ol>
<li><p>Message</p>
<p> Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。</p>
</li>
<li><p>Handler</p>
<p> Handler（处理者）主要是用于发送和处理信息的。发送一般是使用Handler的sendMessage方法，而发出去的信息经过一些地处理后，最终会传递到Handler的handleMessage方法中。</p>
</li>
<li><p>MessageQueue</p>
<p> MessageQueue（消息队列）主要用于存放所有通过Handler发送出来的信息。这部分信息会一直存在于消息队列中等待被处理。每个线程中只会有一个MessageQueue对象。</p>
</li>
<li><p>Looper</p>
<p> Looper是每个线程中的MessageQueue管家，调用Looper的loop方法后，就会进入到一个无线循环当中，然后每当发现MessageQueue中存在信息，就会将队列头部的信息取出，并传递给Handler的handleMessage方法。每个线程只有一个Looper对象。</p>
</li>
</ol>
<p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">pubblic class MainActivity extends AppCompatActivity &#123;</div><div class="line">    public static final int UPDATE_TEXT = 1;</div><div class="line">    </div><div class="line">    private Handler handler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case UPDATE_TEXT:</div><div class="line">                    // 刷新UI</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override </div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        switch (v.getId()) &#123;</div><div class="line">            case R.id.test_button:</div><div class="line">                new Thread(new Runnable() &#123;</div><div class="line">                    @Overrride</div><div class="line">                    public void run() &#123;</div><div class="line">                        Message message = new Message();</div><div class="line">                        message.what = UPDATE_TEXT;</div><div class="line">                        handler.sendMessage(message);</div><div class="line">                    &#125;</div><div class="line">                &#125;).start();</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>为了更好地在子线程中对UI主线程进行操作，Android提供了一个异步的工具–AsyncTask，其能轻易地从子线程切换到主线程。</p>
<p>AsyncTask是一个抽象类，要使用必须是集成并且实现抽象方法。AsyncTask类指定了三个参数，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>参数的作用：</p>
<ul>
<li><p>Params </p>
<p>  在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</p>
</li>
<li><p>Progress</p>
<p>  在后台任务执行时，如果需要在界面上显示当前的进度，则使用这个泛型参数来作为进度单位。</p>
</li>
<li><p>Result</p>
<p>  当任务执行完毕后，如果需要对结果进行返回，则使用这里的指定泛型作为返回类型。</p>
</li>
</ul>
<p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public abstract class AsyncTask&lt;Void, Integer, Boolean&gt; &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>继承AsyncTask经常用到的重写方法有：</p>
<ol>
<li><p>onPreExecute()</p>
<p> 这个方法在后台任务开始执行之前调用，用于进行一些界面上的初始化操作。</p>
</li>
<li><p>doInBackground(Params…)</p>
<p> 这个方法的所有代码都在子线程中运行，可以用来执行所有耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果返回，如果AsyncTask的第三个参数为Void，就可以不返回任务的执行结果。注意，此方法在子线程中运行，不可以刷新UI线程，应该调用publishProgress方法触发onProgressUpdate()方法来完成。</p>
</li>
<li><p>onProgressUpdate(Progress…)</p>
<p> 当在后台任务中调用publishProgress()方法后，onProgressUpdate方法很快就会被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p>
</li>
<li><p>onPostExecute(Result)</p>
<p> 当后台任务执行完毕并通过return语句进行返回时，这个方法就很快被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如提醒任务执行的结果，以及关闭进度对话框等。</p>
</li>
</ol>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onPreExecute() &#123;</div><div class="line">        progressDialog.show();//显示进度对话框</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected Boolean doInBackground(Void... params) &#123;</div><div class="line">        try &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                int downloadPercent = doDownload();</div><div class="line">                pubulishProgress(downloadPercent);//触发onProgressUpdate</div><div class="line">                if (downloadPercent &gt;= 100) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onProgressUpdate(Integer... values) &#123;</div><div class="line">        //在这里更新下载进度</div><div class="line">        progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onPostExecute(Boolean result) &#123;</div><div class="line">        progressDialog.dismiss();//关闭进度对话框</div><div class="line">        //显示结果</div><div class="line">        if (result) &#123;</div><div class="line">            Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show():</div><div class="line">        &#125; else &#123;</div><div class="line">            Toast.makeText(context, &quot;Download failed&quot;, Toast.LENGTH_SHORT).show():</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new DownloadTask().execute();</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-service/" itemprop="url">Android的Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:14:48+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android的Service"><a href="#Android的Service" class="headerlink" title="Android的Service"></a>Android的Service</h1><p>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信(IPC)。例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p>
<p>服务基本上分为两种形式：</p>
<ol>
<li><p>启动</p>
<p> 当应用组件（如 Activity）通过调用<a href="">startService()</a>启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。操作完成后，服务会自行停止运行。</p>
</li>
<li><p>绑定</p>
<p> 当应用组件通过调用 <a href="">bindService()</a> 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
</li>
</ol>
<p>一个服务可以同时以这两种方式运行，也就是既可以启动服务（不手动关闭就限期运行），也允许绑定。问题只是在于是否实现了一组回调方法：<a href="">onStartCommand()</a>（允许组件启动服务）和 <a href="">onBind()</a>（允许绑定服务）。</p>
<p>不管应用是处于启动状态还是绑定状态，或者是处于启动且绑定状态，任何应用组件均可以使用Activity那样通过调用Intent来使用服务，即使此服务是来自另一个应用。若是服务不想被其他应用访问，可知在AndroidManifest.xml中将服务声明为私有服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;manifest ... &gt;</div><div class="line">  ...</div><div class="line">  &lt;application ... &gt;</div><div class="line">      &lt;service android:name=&quot;.ExampleService&quot;</div><div class="line">        android:enabled=&quot;true&quot;</div><div class="line">        android:exported=&quot;false&quot;/&gt;</div><div class="line">      ...</div><div class="line">  &lt;/application&gt;</div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：服务默认是托管在主线程的，它既不创建自己的线程，也不在单独的进程中运行（除非另行制定）。若是有太占用时间的事务要完成，应该在服务中创建子线程来完成，从而降低ANR的风险，主线程扔可以与Activity交互。</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>要创建服务，必须使用或者创建Service的子类。定制service子类的时候，需要去实现一些回调方法，以处理服务生命周期中某些关键操作。应重写的重要回调方法有：</p>
<ol>
<li><p><a href="">onStartCommand()</a></p>
<p> 当另一个组件（如 Activity）通过调用<a href="">startService()</a>请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。如果实现了此方法，则在服务工作完成后，需要自己在此服务中调用 stopSelf() 或在服务外的地方调用 stopService() 来停止服务。绑定的服务无需手动停止服务。</p>
</li>
<li><p><a href="">onBind</a></p>
<p> 这个方法是Service类中唯一一个抽象方法。当另一个组件想通过调用<a href="">bindService</a>与绑定绑定（例如执行RPC）时，系统就会调用此方法。此方法要求返回一个IBinder接口，供客户端与服务进行通信。此方法是抽象方法，是一定要重写的，但是不绑定的话，返回null就可以了。</p>
</li>
<li><p><a href="">onCreate</a></p>
<p> 首次创建服务时，系统将在<a href="">onStartCommand</a>或<a href="">onBind</a>前调用此方法来执行服务的创建。如果服务已在运行，则不会再被调用。</p>
</li>
<li><p><a href="">onDestroy</a></p>
<p> 当服务不再使用且将被销毁时，系统将会调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。</p>
</li>
</ol>
<p>如果以[startCommand()]方式启动服务，则服务将一直运行，直到服务本身使用stopSelf()自行停止运行或者其他组件使用<a href="">stopService()</a>停止。</p>
<p>如果以<a href="">bindService()</a>的方式创建服务，并且未调用<a href="">startCommand()</a>，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<p>仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的Activity，则它不太可能会终止；如果将服务声明为==在前台运行==），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务（不过这还取决于从 <a href="">onStartCommand()</a> 返回的值。</p>
<blockquote>
<p>为了确保应用的安全性，要始终使用显式Intent启动或绑定Service，且不要为服务声明inten过滤器，启动哪个服务存在一定的不确定性，而如果对这种不确定性的考虑非常有必要，则可为服务提供Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。</p>
</blockquote>
<h2 id="创建启动服务"><a href="#创建启动服务" class="headerlink" title="创建启动服务"></a>创建启动服务</h2><p>由<a href="">startService()</a>方法来启动服务，系统会回调<a href="">onStartCommand()</a>方法。服务通过该方式启动后，其生命周期是独立于启动它的组件的，并且可以无限期地在后台运行，即使启动它的组件已被销毁。因此，如果要终止该服务，则需要自身调用[stopSelf()]方法或者其他组件调用[stopService()]来停止。</p>
<p>应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。</p>
<p>例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。</p>
<h3 id="拓展IntentService类"><a href="#拓展IntentService类" class="headerlink" title="拓展IntentService类"></a>拓展IntentService类</h3><p>IntentService是Service的一个子类，也是抽象类，在实现Service基础上添加了一个onHnaldeIntent抽象方法，其是<a href="">startService()</a>启动的，<a href="">onBind()</a>方法返回null。</p>
<p>如果不要求服务同时处理多个请求，这是最好的选择。只要<a href="">onHandleIntent()</a>方法，该方法接收一个请求的Intent。此类的优点是不用关心启动服务后怎么去关闭它，onHandeIntent方法执行完成后服务会自动停止。</p>
<p>IntentService执行一下操作：</p>
<ul>
<li>创建默认的工作线程，用于在应用的主线程外执行传递给<a href="">onStartCommand()</a>的所有Intent。</li>
<li>创建工作队列，用于将 Intent 逐一传递给 <a href="">onHandleIntent()</a> 实现，这您就永远不必担心多线程问题。</li>
<li>在处理完所有启动请求后停止服务，因此永远不必调用 <a href="">stopSelf()</a>。</li>
<li>提供 <a href="">onBind()</a> 的默认实现（返回 null）。</li>
<li>提供 <a href="">onStartCommand()</a> 的默认实现，可将 Intent 依次发送到工作队列和 <a href="">onHandleIntent()</a> 实现。</li>
</ul>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class HelloIntentService extends IntentService &#123;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * A constructor is required, and must call the super IntentService(String)</div><div class="line">   * constructor with a name for the worker thread.</div><div class="line">   */</div><div class="line">  public HelloIntentService() &#123;</div><div class="line">      super(&quot;HelloIntentService&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * The IntentService calls this method from the default worker thread with</div><div class="line">   * the intent that started the service. When this method returns, IntentService</div><div class="line">   * stops the service, as appropriate.</div><div class="line">   */</div><div class="line">  @Override</div><div class="line">  protected void onHandleIntent(Intent intent) &#123;</div><div class="line">      // Normally we would do some work here, like download a file.</div><div class="line">      // For our sample, we just sleep for 5 seconds.</div><div class="line">      try &#123;</div><div class="line">          Thread.sleep(5000);</div><div class="line">      &#125; catch (InterruptedException e) &#123;</div><div class="line">          // Restore interrupt status.</div><div class="line">          Thread.currentThread().interrupt();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本的IntentService只需要实现一个构造方法和<a href="">onHandleIntent()</a>方法，若是要实现onCreate()、onStartCommand()等方法，要确保调用超类的实现，这样才能使IntentService有效处理工作线程的生命周期。</p>
<p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class="line">    Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    return super.onStartCommand(intent,flags,startId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除 <a href="">onHandleIntent()</a> 之外，您无需从中调用超类的唯一方法就是 <a href="">onBind()</a>（仅当服务允许绑定时，才需要实现该方法）。</p>
<h3 id="拓展Service类"><a href="#拓展Service类" class="headerlink" title="拓展Service类"></a>拓展Service类</h3><p>使用 IntentService 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 Service 类来处理每个 Intent。</p>
<p>为了便于比较，以下提供了 Service 类实现的代码示例，该类执行的工作与上述使用 IntentService 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求，也就是异步处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class HelloService extends Service &#123;</div><div class="line">  private Looper mServiceLooper;</div><div class="line">  private ServiceHandler mServiceHandler;</div><div class="line"></div><div class="line">  // Handler that receives messages from the thread</div><div class="line">  private final class ServiceHandler extends Handler &#123;</div><div class="line">      public ServiceHandler(Looper looper) &#123;</div><div class="line">          super(looper);</div><div class="line">      &#125;</div><div class="line">      @Override</div><div class="line">      public void handleMessage(Message msg) &#123;</div><div class="line">          // Normally we would do some work here, like download a file.</div><div class="line">          // For our sample, we just sleep for 5 seconds.</div><div class="line">          try &#123;</div><div class="line">              Thread.sleep(5000);</div><div class="line">          &#125; catch (InterruptedException e) &#123;</div><div class="line">              // Restore interrupt status.</div><div class="line">              Thread.currentThread().interrupt();</div><div class="line">          &#125;</div><div class="line">          // Stop the service using the startId, so that we don&apos;t stop</div><div class="line">          // the service in the middle of handling another job</div><div class="line">          stopSelf(msg.arg1);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onCreate() &#123;</div><div class="line">    // Start up the thread running the service.  Note that we create a</div><div class="line">    // separate thread because the service normally runs in the process&apos;s</div><div class="line">    // main thread, which we don&apos;t want to block.  We also make it</div><div class="line">    // background priority so CPU-intensive work will not disrupt our UI.</div><div class="line">    HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;,</div><div class="line">            Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    // Get the HandlerThread&apos;s Looper and use it for our Handler</div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class="line">      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();</div><div class="line"></div><div class="line">      // For each start request, send a message to start a job and deliver the</div><div class="line">      // start ID so we know which request we&apos;re stopping when we finish the job</div><div class="line">      Message msg = mServiceHandler.obtainMessage();</div><div class="line">      msg.arg1 = startId;</div><div class="line">      mServiceHandler.sendMessage(msg);</div><div class="line"></div><div class="line">      // If we get killed, after returning from here, restart</div><div class="line">      return START_STICKY;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public IBinder onBind(Intent intent) &#123;</div><div class="line">      // We don&apos;t provide binding, so return null</div><div class="line">      return null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onDestroy() &#123;</div><div class="line">    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要注意的是，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务，而IntentService做了默认的实现。从onStartCommand()返回的值必须是以下常量之一：</p>
<ul>
<li><p>START_NOT_STICKY</p>
<p>  如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p>
</li>
<li><p>START_STICKY</p>
<p>  如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p>
</li>
<li><p>START_REDELIVER_INTENT</p>
<p>  如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
</li>
</ul>
<p>如果服务同时处理多个 onStartCommand() 请求，您不应在处理完一个启动请求之后停止服务，因您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，可以使用 stopSelf(int) 确保服务停止请求始终基于最近的启动请求。也就说，在调用 stopSelf(int) 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果在能够调用 stopSelf(int) 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。</p>
<h2 id="创建绑定服务"><a href="#创建绑定服务" class="headerlink" title="创建绑定服务"></a>创建绑定服务</h2><p>绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接（通常不允许组件通过调用 startService() 来启动它）。</p>
<p>如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。</p>
<p>要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。</p>
<p>要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。</p>
<p>多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。</p>
<p>客户端可通过调用 <a href="">bindService()</a> 绑定到服务。调用时，它必须提供 <a href="">ServiceConnection</a> 的实现，后者会监控与服务的连接。<a href="">bindService()</a> 方法会立即无值返回，但当 Android 系统创建客户端与服务之间的连接时，会对 <a href="">ServiceConnection</a> 调用 <a href="">onServiceConnected()</a>，向客户端传递用来与服务通信的 IBinder。</p>
<p>多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 <a href="">onBind()</a> 方法来检索 <a href="">IBinder</a>。系统随后无需再次调用 <a href="">onBind()</a>，便可将同一 <a href="">IBinder</a> 传递至任何其他绑定的客户端。</p>
<p>创建提供绑定的服务时，必须提供 IBinder，用以提供客户端用来与服务进行交互的编程接口。可以通过三种方法定义接口：</p>
<ol>
<li><p>扩展 Binder 类</p>
<p> 如果服务是供自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。</p>
<p> 如果服务只是自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，服务被其他应用或不同的进程占用。</p>
</li>
<li><p>使用 Messenger</p>
<p> 如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。</p>
<p> 这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样就不必对服务进行线程安全设计。</p>
</li>
<li><p>使用 AIDL</p>
<p> AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。</p>
<p> 如需直接使用 AIDL，必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，随后可在服务内对其进行扩展。</p>
</li>
</ol>
<blockquote>
<p>注意：大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用。</p>
</blockquote>
<h3 id="拓展-Binder-类"><a href="#拓展-Binder-类" class="headerlink" title="拓展 Binder 类"></a>拓展 Binder 类</h3><p>若服务仅供本地应用使用，不需要跨进程工作，则可以直接实现Binder类，让自己的客户端通过该类来访问服务中的公共方法。</p>
<blockquote>
<p>注意：此方法只有在客户端和服务位于同一应用和进程内的这一常见情况才有效。例如，对于需要将Activity绑定在后台播放音乐的自由服务的音乐应用，此方法非常有效。</p>
</blockquote>
<p>一下是具体的设置方法：</p>
<ol>
<li><p>在服务中，创建一个可满足下列任一要求的Binder实例：</p>
<ul>
<li>包含客户端可调用的公共方法</li>
<li>返回当前Service实例，其中包含客户端可调用的公共方法</li>
<li>或返回服务承载的其他类的实例，其中包含客户端可调用的公共方法</li>
</ul>
</li>
<li><p>从<a href="">onBind()</a>回调方法返回此Binder实例</p>
</li>
<li>在客户端中，从<a href="">onServiceConnected()</a>回调方法接收Binder，并使用提供的方法调用绑定服务。</li>
</ol>
<p>Service demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class LocalService extends Service &#123;</div><div class="line">    // Binder given to clients</div><div class="line">    private final IBinder mBinder = new LocalBinder();</div><div class="line">    // Random number generator</div><div class="line">    private final Random mGenerator = new Random();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Class used for the client Binder.  Because we know this service always</div><div class="line">     * runs in the same process as its clients, we don&apos;t need to deal with IPC.</div><div class="line">     */</div><div class="line">    public class LocalBinder extends Binder &#123;</div><div class="line">        LocalService getService() &#123;</div><div class="line">            // Return this instance of LocalService so clients can call public methods</div><div class="line">            return LocalService.this;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return mBinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** method for clients */</div><div class="line">    public int getRandomNumber() &#123;</div><div class="line">      return mGenerator.nextInt(100);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class BindingActivity extends Activity &#123;</div><div class="line">    LocalService mService;</div><div class="line">    boolean mBound = false;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        // Bind to LocalService</div><div class="line">        Intent intent = new Intent(this, LocalService.class);</div><div class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        // Unbind from the service</div><div class="line">        if (mBound) &#123;</div><div class="line">            unbindService(mConnection);</div><div class="line">            mBound = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Called when a button is clicked (the button in the layout file attaches to</div><div class="line">      * this method with the android:onClick attribute) */</div><div class="line">    public void onButtonClick(View v) &#123;</div><div class="line">        if (mBound) &#123;</div><div class="line">            // Call a method from the LocalService.</div><div class="line">            // However, if this call were something that might hang, then this request should</div><div class="line">            // occur in a separate thread to avoid slowing down the activity performance.</div><div class="line">            int num = mService.getRandomNumber();</div><div class="line">            Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Defines callbacks for service binding, passed to bindService() */</div><div class="line">    private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName className,</div><div class="line">                IBinder service) &#123;</div><div class="line">            // We&apos;ve bound to LocalService, cast the IBinder and get LocalService instance</div><div class="line">            LocalBinder binder = (LocalBinder) service;</div><div class="line">            mService = binder.getService();</div><div class="line">            mBound = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceDisconnected(ComponentName arg0) &#123;</div><div class="line">            mBound = false;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><p>想让服务与远程进程通信，则可使用Messenger为服务提供接口。利用这种方法，无需使用AIDL就可以执行IPC。</p>
<p>Messenger使用方法摘要：</p>
<ul>
<li>服务实现一个Handler，由其接收来自客户端的每个调用的回调</li>
<li>Handler用于创建Messenger对象（对Handler的引用）</li>
<li>Messenger创建一个IBinder，服务通过onBind() 使其返回客户端</li>
<li>客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务</li>
<li>服务在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message。</li>
</ul>
<p>Service demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class MessengerService extends Service &#123;</div><div class="line">    /** Command to the service to display a message */</div><div class="line">    static final int MSG_SAY_HELLO = 1;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Handler of incoming messages from clients.</div><div class="line">     */</div><div class="line">    class IncomingHandler extends Handler &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case MSG_SAY_HELLO:</div><div class="line">                    Toast.makeText(getApplicationContext(), &quot;hello!&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Target we publish for clients to send messages to IncomingHandler.</div><div class="line">     */</div><div class="line">    final Messenger mMessenger = new Messenger(new IncomingHandler());</div><div class="line"></div><div class="line">    /**</div><div class="line">     * When binding to the service, we return an interface to our messenger</div><div class="line">     * for sending messages to the service.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        Toast.makeText(getApplicationContext(), &quot;binding&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        return mMessenger.getBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public class ActivityMessenger extends Activity &#123;</div><div class="line">    /** Messenger for communicating with the service. */</div><div class="line">    Messenger mService = null;</div><div class="line"></div><div class="line">    /** Flag indicating whether we have called bind on the service. */</div><div class="line">    boolean mBound;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Class for interacting with the main interface of the service.</div><div class="line">     */</div><div class="line">    private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">        public void onServiceConnected(ComponentName className, IBinder service) &#123;</div><div class="line">            // This is called when the connection with the service has been</div><div class="line">            // established, giving us the object we can use to</div><div class="line">            // interact with the service.  We are communicating with the</div><div class="line">            // service using a Messenger, so here we get a client-side</div><div class="line">            // representation of that from the raw IBinder object.</div><div class="line">            mService = new Messenger(service);</div><div class="line">            mBound = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void onServiceDisconnected(ComponentName className) &#123;</div><div class="line">            // This is called when the connection with the service has been</div><div class="line">            // unexpectedly disconnected -- that is, its process crashed.</div><div class="line">            mService = null;</div><div class="line">            mBound = false;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public void sayHello(View v) &#123;</div><div class="line">        if (!mBound) return;</div><div class="line">        // Create and send a message to the service, using a supported &apos;what&apos; value</div><div class="line">        Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);</div><div class="line">        try &#123;</div><div class="line">            mService.send(msg);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        // Bind to the service</div><div class="line">        bindService(new Intent(this, MessengerService.class), mConnection,</div><div class="line">            Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        // Unbind from the service</div><div class="line">        if (mBound) &#123;</div><div class="line">            unbindService(mConnection);</div><div class="line">            mBound = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。</p>
<p>例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。</p>
<p>要请求让服务运行于前台，则调用<a href="">startForeground()</a>，此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),</div><div class="line">        System.currentTimeMillis());</div><div class="line">Intent notificationIntent = new Intent(this, ExampleActivity.class);</div><div class="line">PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);</div><div class="line">notification.setLatestEventInfo(this, getText(R.string.notification_title),</div><div class="line">        getText(R.string.notification_message), pendingIntent);</div><div class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：提供给 startForeground() 的整型 ID 不得为 0。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-process-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-process-thread/" itemprop="url">Android的进程和线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:14:01+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android的进程和线程"><a href="#Android的进程和线程" class="headerlink" title="Android的进程和线程"></a>Android的进程和线程</h1><p>当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p>
<p>各类组件元素的清单文件条目—<a href=""><activity></activity></a>、<a href=""><service></service></a>、<a href=""><receiver></receiver></a>和<a href=""><provider></provider></a>—均支持 android:process属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</p>
<p>此外，<a href=""><application></application></a> 元素还支持 android:process属性，以设置适用于所有组件的默认值。</p>
<p>如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。</p>
<p>决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面为决定终止进程所用的规则。</p>
<h3 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h3><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p>
<p>重要性层次结构一共有 5级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：</p>
<ol>
<li><p>前台进程</p>
<p> 用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>托管用户正在交互的 <a href="">Activity</a>（已调用 <a href="">Activity</a> 的 <a href="">onResume()</a> 方法）</li>
<li>托管某个 <a href="">Service</a>，后者绑定到用户正在交互的 Activity</li>
<li>托管正在“前台”运行的 <a href="">Service</a>（服务已调用 <a href="">startForeground()</a>）</li>
<li>托管正执行一个生命周期回调的 <a href="">Service</a>（<a href="">onCreate()</a>、<a href="">onStart()</a> 或 <a href="">onDestroy()</a>）</li>
<li><p>托管正执行其 <a href="">onReceive()</a> 方法的 <a href="">BroadcastReceiver</a></p>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>
</li>
</ul>
</li>
<li><p>可见进程</p>
<p> 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程：</p>
<ul>
<li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause()方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li>
<li><p>托管绑定到可见（或前台）Activity 的 <a href="">Service</a>。</p>
<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
</li>
</ul>
</li>
<li><p>服务进程</p>
<p> 正在运行已使用 <a href="">startService()</a>方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
</li>
<li><p>后台进程</p>
<p> 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 <a href="">onStop()</a> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息。</p>
</li>
<li><p>空进程</p>
<p> 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
</li>
</ol>
<p>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。 这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。</p>
<p>要执行 IPC，必须使用 bindService() 将应用绑定到服务上。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。</p>
<p>系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。</p>
<p>例如，当用户触摸屏幕上的按钮时，应用的 UI 线程会将触摸事件分派给小部件，而小部件反过来又设置其按下状态，并将失效请求发布到事件队列中。 UI 线程从队列中取消该请求并通知小部件应该重绘自身。</p>
<p>在应用执行繁重的任务以响应用户交互时，除非正确实现应用，否则这种单线程模式可能会导致性能低下。 具体地讲，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。 一旦线程被阻塞，将无法分派任何事件，包括绘图事件。 从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。</p>
<p>此外，Android UI 工具包并非线程安全工具包。因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。 因此，Android 的单线程模式必须遵守两条规则：</p>
<ol>
<li>不要阻塞 UI 线程</li>
<li>不要在 UI 线程之外访问 Android UI 工具包</li>
</ol>
<h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>根据上述单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。 如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。</p>
<p>例如，以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在 ImageView 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void onClick(View v) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            Bitmap b = loadImageFromNetwork(&quot;http://example.com/image.png&quot;);</div><div class="line">            mImageView.setImageBitmap(b);</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：<em>不要在 UI 线程之外访问 Android UI 工具包</em> — 此示例从工作线程（而不是 UI 线程）修改了 ImageView。 这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。</p>
<p>为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法：</p>
<ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable)</li>
<li>View.postDelayed(Runnable, long)</li>
</ul>
<p>例如，您可以通过使用 View.post(Runnable) 方法修复上述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void onClick(View v) &#123;</div><div class="line">    new Thread(new Runnable() &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            final Bitmap bitmap =</div><div class="line">                    loadImageFromNetwork(&quot;http://example.com/image.png&quot;);</div><div class="line">            mImageView.post(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    mImageView.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，上述实现属于线程安全型：在单独的线程中完成网络操作，而在 UI 线程中操纵 ImageView。</p>
<p>但是，随着操作日趋复杂，这类代码也会变得复杂且难以维护。 要通过工作线程处理更复杂的交互，可以考虑在工作线程中使用 Handler 处理来自 UI 线程的消息。当然，最好的解决方案或许是扩展 AsyncTask 类，此类简化了与 UI 进行交互所需执行的工作线程任务。</p>
<h3 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h3><p>AsyncTask 允许对用户界面执行异步操作。 它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。</p>
<p>要使用它，必须创建 AsyncTask 的子类并实现 doInBackground() 回调方法，该方法将在后台线程池中运行。 要更新 UI，应该实现 onPostExecute() 以传递 doInBackground() 返回的结果并在 UI 线程中运行，以便您安全地更新 UI。 稍后，您可以通过从 UI 线程调用 execute() 来运行任务。</p>
<p>例如，您可以通过以下方式使用 AsyncTask 来实现上述示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void onClick(View v) &#123;</div><div class="line">    new DownloadImageTask().execute(&quot;http://example.com/image.png&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123;</div><div class="line">    /** The system calls this to perform work in a worker thread and</div><div class="line">      * delivers it the parameters given to AsyncTask.execute() */</div><div class="line">    protected Bitmap doInBackground(String... urls) &#123;</div><div class="line">        return loadImageFromNetwork(urls[0]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** The system calls this to perform work in the UI thread and delivers</div><div class="line">      * the result from doInBackground() */</div><div class="line">    protected void onPostExecute(Bitmap result) &#123;</div><div class="line">        mImageView.setImageBitmap(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在 UI 是安全的，代码也得到简化，因为任务分解成了两部分：一部分应在工作线程内完成，另一部分应在 UI 线程内完成。</p>
<p>下面简要概述了 AsyncTask 的工作方法，但要全面了解如何使用此类，应阅读 AsyncTask 参考文档：</p>
<ul>
<li>可以使用泛型指定参数类型、进度值和任务最终值</li>
<li>方法 doInBackground() 会在工作线程上自动执行</li>
<li>onPreExecute()、onPostExecute() 和 onProgressUpdate() 均在 UI 线程中调用</li>
<li>doInBackground() 返回的值将发送到 onPostExecute()</li>
<li>可以随时在 doInBackground() 中调用publishProgress()，以在 UI 线程中执行 onProgressUpdate()</li>
<li>可以随时取消任何线程中的任务</li>
</ul>
<blockquote>
<p>使用工作线程时可能会遇到另一个问题，即：运行时配置变更（例如，用户更改了屏幕方向）导致 Activity 意外重启，这可能会销毁工作线程。</p>
</blockquote>
<h3 id="线程安全方法"><a href="#线程安全方法" class="headerlink" title="线程安全方法"></a>线程安全方法</h3><p>在某些情况下，您实现的方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。</p>
<p>这一点主要适用于可以远程调用的方法，如绑定服务中的方法。如果对 IBinder 中所实现方法的调用源自运行 IBinder 的同一进程，则该方法在调用方的线程中执行。但是，如果调用源自其他进程，则该方法将在从线程池选择的某个线程中执行（而不是在进程的 UI 线程中执行），线程池由系统在与 IBinder 相同的进程中维护。 例如，即使服务的 onBind() 方法将从服务进程的 UI 线程调用，在 onBind() 返回的对象中实现的方法（例如，实现 RPC 方法的子类）仍会从线程池中的线程调用。 由于一个服务可以有多个客户端，因此可能会有多个池线程在同一时间使用同一 IBinder 方法。因此，IBinder 方法必须实现为线程安全方法。</p>
<p>同样，内容提供程序也可接收来自其他进程的数据请求。尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法（query()、insert()、delete()、update() 和 getType() 方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的 UI 线程调用。 由于这些方法可能会同时从任意数量的线程调用，因此它们也必须实现为线程安全方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-context/" itemprop="url">Android的Context及其子类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:12:37+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android的Context及其子类"><a href="#Android的Context及其子类" class="headerlink" title="Android的Context及其子类"></a>Android的Context及其子类</h1><p>Android的系统组件很多，Activity、Service、BroadcastReceiver等都是很常用的，这些组件的创建都不能是凭空的，都需要借助Context这个核心功能类或者其子类。</p>
<h2 id="Context继承结构"><a href="#Context继承结构" class="headerlink" title="Context继承结构"></a>Context继承结构</h2><p><img src="http://img.blog.csdn.net/20151022212109519?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>Context（android.content）是一个抽象类，它有两个继承类，分别是上下文封装的封装类ContextWrapper和上下文功能的实现类ContextImpl（可以从命名看出，Wrapper和Implments）。</p>
<p>ContextWrapper有三个子类，分别是Application，Service，ContextThemeWrapper，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity。</p>
<p>从以上的继承关系上总结，Context有三种类型，分别是Apllication、Activity、Service。三个类分别承担着不同的任务，而他们具体的Context功能有ContextImpl去实现。</p>
<h2 id="Context的功能"><a href="#Context的功能" class="headerlink" title="Context的功能"></a>Context的功能</h2><p>Context的功能很多，很强大。Toast、启动Activity、启动Service、发送广播、操作数据库等都需要用到Context。</p>
<p>由于Context的具体能力是由ContextImpl去实现的，所以绝大多数场景下，Apllication、Activity、Service三类的Context是可以通用的。</p>
<p>出于安全的考虑，Android做了一些限制，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p>
<h2 id="Context的数量"><a href="#Context的数量" class="headerlink" title="Context的数量"></a>Context的数量</h2><p>Context数量 = Activity数量 + Service数量 + 1</p>
<p>一个应用只能有一个Application，但是活动和服务可以有多个。</p>
<h2 id="Application-Context"><a href="#Application-Context" class="headerlink" title="Application Context"></a>Application Context</h2><p>每个应用程序都会在AndroidManifest.xml上注册一个Application，默认是没有指定名字的。在Activity上获取Context的相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        Application application = (Application)getApplication();</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;getApplication is&quot; + application);</div><div class="line"></div><div class="line">        Context appContext = getApplicationContext();</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;getApplicationContext is&quot; + appContext);</div><div class="line"></div><div class="line">        Context baseContext = getBaseContext();</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;getBaseContext is&quot; + baseContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>logcat输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">com.example.linzh.contexttest D/MainActivity: getApplication isandroid.app.Application@421b137</div><div class="line">com.example.linzh.contexttest D/MainActivity: getApplicationContext isandroid.app.Application@421b137</div><div class="line">com.example.linzh.contexttest D/MainActivity: getBaseContext isandroid.app.ContextImpl@de166a4</div></pre></td></tr></table></figure></p>
<p>输出结果分析：</p>
<p>在输出的结果里，getApplication和getApplicationContext的结果是一样的，因为Application本身也是Context（其子类）。所以这里获取的getApplicationContext就是Application本身的实例。</p>
<p>但是，getApplicationContext和getApplication两者的应用范围是不一样的。getApplication只能在Activity和Service中被调用，而getApplicationContext适用范围更广，比如BroadcastReceiver是不能调用getApplication的，但是getApplicationContext可以。</p>
<p>在输出的log里还有baseContext，这个是ContextImpl功能实现类的。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>Application不能被new，不能和单例混在一起。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-activity-communication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-activity-communication/" itemprop="url">Android中Activity之间的通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:11:37+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android中Activity之间的通信"><a href="#Android中Activity之间的通信" class="headerlink" title="Android中Activity之间的通信"></a>Android中Activity之间的通信</h1><blockquote>
<p>此篇随笔将总结Activity之间的通信，数据交流，如何保存Activity的状态。</p>
</blockquote>
<h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent，即意图，用于描述你想在某个Intent对象的简单操作，再通过startActivity或者startActivityForResult方法来启动这个意图所对应的活动。</p>
<p>意图有隐式和显式之分。显式的意图是在java文件中直接调用指定的活动类，隐式的意图是现在AndroidManifest.xml中指定uri，然后在活动中指定此uri来启动所对应的活动。</p>
<p>Android自带的库中有很多通用的隐式意图，具体的参考<a href="https://developer.android.com/guide/components/intents-common.html" target="_blank" rel="external">Android官方文档</a>。</p>
<p>此外，意图还可以指定意图过滤器，来筛选自己想要的意图。</p>
<h3 id="传递信息"><a href="#传递信息" class="headerlink" title="传递信息"></a>传递信息</h3><p>意图不仅可以用来启动活动，还可以用来做活动之间的传信者。</p>
<p>在用意图启动一个活动之前，调用intent的putExtra方法来存储键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String value = &quot;hello&quot;;</div><div class="line">Intent intent = new Intent(ThisActivity.this, OtherActivity.class);</div><div class="line">intent.putExtra(&quot;key&quot;, value);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>完成启动后，即可将数据取出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = getIntent();</div><div class="line">String data = intent.getStringExtra(&quot;key&quot;);</div></pre></td></tr></table></figure></p>
<p>当然，传递的信息不仅仅只能是String，其他基本类型都是可以的，相应的把getXXX的XXX置为相应的类型即可。</p>
<p>同理，用startActivityForResult启动的活动，也可以通过Intent传递回一些信息。返回的信息通过setResult来设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.putExtra(&quot;data_return&quot;, &quot;Hello&quot;);</div><div class="line">intent.putExtra(&quot;int_data&quot;, 100);</div><div class="line">setResult(RESULT_OK, intent);//RESULT_OK是返回的编码，可以自定义</div><div class="line">finish();</div></pre></td></tr></table></figure></p>
<p>在接收返回的活动中取出信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getIntent().getStringExtra(&quot;data_return&quot;);</div><div class="line">getIntent().getIntExtra(&quot;int_data&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>在用Intent来启动的时候顺便传递一些信息，是很便捷的，但是Intent所传递的信息非常有限，它只能传递基本数据类型。</p>
<p>默认的Intent传递信息有所限制，但是可以自己定制传递的信息机制，那就是用序列化机制。序列化后对象即可储存在本地，也可以通过网络流进行传输。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Android提供的序列化机制是比较丰富的，Java默认支持Serializable接口，只要类去implements它，就具备了序列化能力，而且可以不去实现Serializable的方法，如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Person implements Serializable &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    </div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    publci void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过Intent传递，传递的方式和普通的intent传递并没有什么差别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Person person = new Person();</div><div class="line">person.setName(&quot;Tom&quot;);</div><div class="line">person.setAge(20);</div><div class="line">Intent intent = new Intent(ThisActivity.this, OtherActivity.class);</div><div class="line">intent.putExtra(&quot;person_data&quot;, person);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>获取也是一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person person = (Person)getIntent().getSerializableExtra(&quot;person_data&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="Percelable"><a href="#Percelable" class="headerlink" title="Percelable"></a>Percelable</h3><p>Android除了支持Serializable，还自己实现了另一个序列化机制，Percelable接口。Percelable的实现相比Serializable复杂，需要去重写describeContents和writeToParcel两个方法，还得创建一个Parcelable.Creator接口的实现。例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Person implements Parcelable &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public int describeContents() &#123;</div><div class="line">        return 0;//包含特殊对象的种类，这里返回0即可</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">        dest.writeString(name);</div><div class="line">        dest.writeInt(age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public Person createFromParcel(Parcel source) &#123;//用于反序列化读取数据</div><div class="line">            Person person = new Person();</div><div class="line">            person.name = source.readString();</div><div class="line">            person.age = source.readInt();</div><div class="line">            return person;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        @Override</div><div class="line">        public Person[] newArray(int size) &#123;//创建序列化对象数组</div><div class="line">            return new Person[size];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来的序列化和传递都和Serializable的一致，反序列化有点差别的地方在于下面例子，其他的没什么差别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person person = (Person)getIntent().getParcelableExtra(&quot;person_data&quot;);</div></pre></td></tr></table></figure></p>
<p>Parcelable的序列化操作相比Serializable麻烦了不少，但其效率更好，Serializable的序列化是把整个对象都序列化了，不管信息有没有用，而Parcelable是根据自己去实现相应的操作定制相应的数据进行序列化。所以通常情况下更加推荐使用Parcelable进行Intent传递数据。</p>
<h2 id="保存Activity的状态"><a href="#保存Activity的状态" class="headerlink" title="保存Activity的状态"></a>保存Activity的状态</h2><p>当一个任务中的一个Activity停止时，系统的默认行为是会保留它的状态的，这样一来，当用户从上一个活动中返回时，其用户界面与用户离开该活动时才一致，这样才不会影响到用户的体验，效率也更快。但是，若该活动在返回栈中很久没有重新回到栈顶工作，那么系统GC会回收并且销毁它，重新需要工作的时候就是重新实例了，这样会丢失已有的状态信息，这个时候我们需要给Activity的状态做保留。</p>
<p>保存Activity的状态信息通过<a href="">onSavaInstanceState()</a>这个回调方法来完成。</p>
<p>系统会在onPause回调方法被调用前去调用onSaveInstanceState方法，然后再使Activity进行后面的方法回调，以至于活动变得易于销毁，保证内存的充足使用。</p>
<p>在调用onSavaInstanceState方法的时候，系统会向其传递一个Bundle类对象，可以在其中使用putString()和putInt等方法以键值对的形式保存有关Activity状态信息。</p>
<p>若是Activity被GC回收，也就是系统终止了本应用进程，而后用户又返回到该Activity，系统会重建Activity，在回调完onCreate()和onStart()方法后去回调onRestoreInstanceState()方法。</p>
<p>在onRestoreInstanceState()方法中会有一个Bundle对象，若为空则没有状态信息需要恢复，若是不为空则要提取保存状态的信息。</p>
<p>其实，即使我们不做保存状态信息的操作，系统默认也会在onSavaInstanceState()方法上实现部分Activity状态的保存。具体讲，默认实现会为布局中的每个View调用相应的onSaveInstanceState()方法，让每个视图都能提供有关自身应保存的信息。Android框架中几乎每个小部件都会根据需要实现此方法，以便在重建Activity时自动保存和恢复对UI所做的任何可见更改。例如，EditText会保存用户输入的任何文本，CheckBox则会保存复选框的选中或未选中状态。系统默认实现此方法需要有每个小部件的唯一ID，若是没有指定ID，则不会保存其状态。</p>
<p>尽管onSavaInstanceState()方法的默认实现会保存一些UI有关的状态信息，但是有时候并不能满足需求，所以才需要自己去定制，从而保存更多的信息。例如，有可能需要保存在Activity生命周期内发生了变化的成员值。</p>
<p>在重写onSavaInstanceState方法时，正确的做法应该是先去调用super类的此方法，然后再作品定制操作，一遍默认实现能够恢复视图的状态，还能传递信息。</p>
<p>切记，onSavaInstanceState()方法是不能保证一定会被调用的，若是用户按下“返回”键显示关闭活动，那就没法保存了。所以，此方法应该只利用来记录Activity的瞬态（UI状态），而不是用来保存一些持久性的数据。保存持久性数据可以在onPause方法中将数据存入数据库等容器中。</p>
<h3 id="Bundle类"><a href="#Bundle类" class="headerlink" title="Bundle类"></a>Bundle类</h3><p>Bundle类是final的，也就是无法被继承，其实现了克隆和Parcelable序列化接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final class Bundle extends BaseBundle implements Cloneable, Parcelable &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>信息传递例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setClass(ThisActivity.this, TargetActivity.class);</div><div class="line">Bundle bundle = new Bundle();</div><div class="line">bundle.putString(&quot;data&quot;, &quot;hello&quot;);</div><div class="line">intent.putExtras(bundle);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>在TargetActivity.java中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void onCreate(Bundle savadInstanceState) &#123;</div><div class="line">    ...</div><div class="line">    Bundle bundle = getIntent().getExtras();</div><div class="line">    String data = bundle.getString(&quot;data&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="保存Activiyt状态"><a href="#保存Activiyt状态" class="headerlink" title="保存Activiyt状态"></a>保存Activiyt状态</h3><p>在onPause前调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static final String STATE_SCORE = &quot;playerScore&quot;;</div><div class="line">static final String STATE_LEVEL = &quot;playerLevel&quot;;</div><div class="line">...</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onSaveInstanceState(Bundle savaInstanceState) &#123;</div><div class="line">    //保存用户当前的游戏状态</div><div class="line">    savaInstanceState.putInt(STATE_SCORE, mCurrentScore);</div><div class="line">    savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);</div><div class="line">    </div><div class="line">    //调用系统默认实现的onSavaInstanceState来保存UI状态</div><div class="line">    super.onSaveInstanceState(savedInstanceState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="恢复Acitivity状态"><a href="#恢复Acitivity状态" class="headerlink" title="恢复Acitivity状态"></a>恢复Acitivity状态</h3><p>Activity在先前销毁后重新创建时（非用户主动销毁），可以从系统向Activity传递的Bundle对象恢复已保存的状态，onCreate()和onRestoreInstanceState()回调方法均接收包含实例状态信息的相同Bundle。</p>
<p>无论是新创建还是重建Activity，系统都会调用onCreate()方法，所以如果是在onCreate方法中去恢复信息，那必须在读取Bundle信息前去检测Bundle是否为null。如果为null，则系统将创建Activity的新实例，而不是恢复已销毁的先前实例。</p>
<p>例如以下例子，在onCreate()方法中去识别Bundle是否为null，然后再选择去恢复与否<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState); // Always call the superclass first</div><div class="line"></div><div class="line">    // Check whether we&apos;re recreating a previously destroyed instance</div><div class="line">    if (savedInstanceState != null) &#123;</div><div class="line">        // Restore value of members from saved state</div><div class="line">        mCurrentScore = savedInstanceState.getInt(STATE_SCORE);</div><div class="line">        mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Probably initialize members with default values for a new instance</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以选择实现系统在 onStart()方法之后调用的onRestoreInstanceState()来实现恢复状态信息，而不是在 onCreate()期间恢复状态。系统只在存在要恢复的已保存状态时调用onRestoreInstanceState()，因此此时无需检查 Bundle 是否为 null：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void onRestoreInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">    // Always call the superclass so it can restore the view hierarchy</div><div class="line">    super.onRestoreInstanceState(savedInstanceState);</div><div class="line"></div><div class="line">    // Restore state members from saved instance</div><div class="line">    mCurrentScore = savedInstanceState.getInt(STATE_SCORE);</div><div class="line">    mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他信息传递方法"><a href="#其他信息传递方法" class="headerlink" title="其他信息传递方法"></a>其他信息传递方法</h2><p>详见Android的广播机制和Android的数据存储。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-broadcast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-broadcast/" itemprop="url">Android的广播机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:10:10+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android的广播机制"><a href="#Android的广播机制" class="headerlink" title="Android的广播机制"></a>Android的广播机制</h1><p>Android的广播机制Broadcast Receiver可以实现应用程序之间、Activity之间的信息传递。广播的通信是跨进程的。</p>
<h2 id="广播类型"><a href="#广播类型" class="headerlink" title="广播类型"></a>广播类型</h2><p>Android提供的广播类型有两种，标准广播和有序广播。</p>
<p>标准广播是一种完全异步执行的广播，其是无序的，在发出后，所有接收器都能在同一时刻接收到此广播。这种广播的效率比较高，但同时也意味着无法被截断，也就是可能是不安全的。</p>
<p>有序广播正如其名，其是有序的。在广播发出后，同一时刻只能有一个广播接收器能够接收到，且根据优先级来传递此广播，若在中间被截断，则后面的广播接收器无法接收到此广播。</p>
<h2 id="动态注册广播"><a href="#动态注册广播" class="headerlink" title="动态注册广播"></a>动态注册广播</h2><p>动态注册广播的方法是在Java代码中实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private IntentFilter intentFilter;</div><div class="line">    private NetworkChangeReceiver networkChangeReceiver;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        intentFilter = new IntentFilter();</div><div class="line">        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);</div><div class="line">        networkChangeReceiver = new NetworkChangeReceiver();</div><div class="line">        registerReceiver(networkChangeReceiver, intentFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        unregisterReceiver(networkChangeReceiver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class NetworkChangeReceiver extends BroadcastReceiver &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onReceive(Context context, Intent intent) &#123;</div><div class="line">            ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">            NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();</div><div class="line">            if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123;</div><div class="line">                Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125; else &#123;</div><div class="line">                Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子中的内部类NetworkChangeReceiver继承自BroadcastReceiver，并且重写了onReceive方法，其实就是作为了广播接收器。在初始化的时候我们用意图筛选器筛选出了网络状态变化这个广播，并且将意图筛选器和广播接收器注册，所以当网络变化的时候，相应的接收器的onReceive方法就会被回调。</p>
<blockquote>
<p>注意，竟然注册了广播，那么在销毁此活动时，广播接收器也要取消注册。</p>
</blockquote>
<h2 id="静态注册广播"><a href="#静态注册广播" class="headerlink" title="静态注册广播"></a>静态注册广播</h2><p>静态注册广播就是在清单元件中去注册，其优点在于可以快速响应。动态注册比较灵活，可控，但是在一些情况下，就力不从心了，比如程序启动前我们要接收到广播后作出响应，但是动态注册只能等到程序启动后才能实现，而静态就不一样了。</p>
<p>例子：接收开机广播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class BootCompleteReceiver extends BroadcastReceiver &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        // TODO: This method is called when the BroadcastReceiver is receiving</div><div class="line">        // an Intent broadcast.</div><div class="line">        Toast.makeText(context, &quot;Boot Complete&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//AndroidManifest.xml</div><div class="line">...</div><div class="line">&lt;receiver</div><div class="line">    android:name=&quot;.BootCompleteReceiver&quot;</div><div class="line">    android:enabled=&quot;true&quot;</div><div class="line">    android:exported=&quot;true&quot;&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上操作注意权限问题</p>
</blockquote>
<h2 id="自定义发送广播"><a href="#自定义发送广播" class="headerlink" title="自定义发送广播"></a>自定义发送广播</h2><p>以上的操作都是接收广播，接下来自定义标准和有序广播的发送。</p>
<h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><p>定制接收器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MyBroadcastReceiver extends BroadcastReceiver &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;</div><div class="line">    android:enabled=&quot;true&quot;</div><div class="line">    android:exported=&quot;true&quot; &gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure></p>
<p>发送标准广播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Button button = (Button)findViewById(R.id.button);</div><div class="line">button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;);</div><div class="line">        sendBroadcast(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><p>广播的信息传递是跨进程的，有序广播可以在优先级不同的进程中不断传递。有序的广播和标准广播的配置差不多，唯一的区别在于sendBroadcast方法变成了sendOrderBroadcast。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendOrderBroadcast(intent, null);</div></pre></td></tr></table></figure></p>
<p>有序广播是有优先级的，可以在清单文件中设置优先级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;</div><div class="line">    android:enabled=&quot;true&quot;</div><div class="line">    android:exported=&quot;true&quot; &gt;</div><div class="line">    &lt;intent-filter android:priority=&quot;100&quot;&gt;</div><div class="line">        &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure></p>
<p>截断广播传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyBroadcastReceiver extends BroadcastReceiver &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        abortBroadcast();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h2><p>前面所涉及的发送和接收广播都是全局的，也就是发出的广播可以被其他任何应用程序所接收，这是非常不安全的。Android提供了另一种安全的广播机制，本地广播，使用这个机制发出的广播智能在本应用程序内部传递。</p>
<p>使用例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private IntentFilter intentFilter;</div><div class="line">    private LocalReceiver localReceiver;</div><div class="line">    private LocalBroadcastManager localBroadcastManager;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        localBroadcastManager = LocalBroadcastManager.getInstance(this);</div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Intent intent = new Intent(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;);</div><div class="line">                localBroadcastManager.sendBroadcast(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        intentFilter = new IntentFilter();</div><div class="line">        intentFilter.addAction(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;);</div><div class="line">        localReceiver = new LocalReceiver();</div><div class="line">        localBroadcastManager.registerReceiver(localReceiver, intentFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        unregisterReceiver(localReceiver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class LocalReceiver extends BroadcastReceiver &#123;</div><div class="line">        @Override</div><div class="line">        public void onReceive(Context context, Intent intent) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本地广播借助的是LocalBroadcastManager来传递传播，其他和有序、标准广播用法差不多。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>广播机制传播的这些信息往往是轻量级的，因为广播接受者的生命周期非常短。当执行onReceiver方法之后，广播就会被销毁。</p>
<p>在广播接受者中不能进行耗时较长的操作，也不要在Receiver中创建子线程，Receiver在接收完成后，所有进程都会变成空进程，很容易被GC回收掉。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-listview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-listview/" itemprop="url">Android的ListView实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:07:58+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android自定义View和ViewGroup"><a href="#Android自定义View和ViewGroup" class="headerlink" title="Android自定义View和ViewGroup"></a>Android自定义View和ViewGroup</h1><blockquote>
<p>Android中提供了丰富、复杂的视图系统，widget类的组件：Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner都是直接或间接继承于super类View，布局类：LinearLayout, FrameLayout, RelativeLayout等则继承于ViewGroup， ViewGroup则继承于View。</p>
<p>所以，要设计构建自己的视图或者布局，就要去继承View或者ViewGroup。本文从使用的角度来总结自定制View和ViewGroup。</p>
</blockquote>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>自定义View，最基本的就是继承Android提供的基本视图类View。<br>自定义步骤：</p>
<ul>
<li>自定义View的属性 编写attr.xml文件 </li>
<li>在layout布局文件中引用，同时引用命名空间 </li>
<li>在View的构造方法中获得我们自定义的属性，在自定义控件中进行读取（构造方法拿到attr.xml文件值） </li>
<li>重写onMesure </li>
<li>重写onDraw</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyView extends View &#123;</div><div class="line">    public MyView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承了View类，还需要重写2个以上的构造方法（以上示例为常用重写构造方法）和onMeasure(), onDraw()方法，在View继承中，onLayout()是非必须的。</p>
<h3 id="拓展onMeasure"><a href="#拓展onMeasure" class="headerlink" title="拓展onMeasure()"></a>拓展onMeasure()</h3><p>自定义View都要自己来测量控制宽高尺寸，算出自己需要占用多大的面积。我们常在xml布局文件中用match_parent和wrap_content，这两属性都是依赖于父布局的，没有父布局就没法正确定位宽高。</p>
<p>这里存在一个疑问，就是如果我们在activity_main.xml中的代码如下，layout_width和layout_height指定的值也都为match_parent，其父布局又在哪呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:id=&quot;@+id/main_layout&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>我们在MainActivity.java中进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private LinearLayout linearLayout;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        linearLayout = (LinearLayout)findViewById(R.id.main_layout);</div><div class="line">        LayoutInflater layoutInflater = LayoutInflater.from(this);</div><div class="line">        View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null);</div><div class="line">        linearLayout.addView(buttonLayout);</div><div class="line"></div><div class="line">        ViewParent viewParent = linearLayout.getParent();//获取父布局的名字</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;The parent of main linear layout is &quot; + viewParent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上App，可以在logcat中打印出如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The parent of main linear layout is android.support.v7.widget.ContentFrameLayout&#123;2ef2e36 V.E...... ......I. 0,0-0,0 #1020002 android:id/content&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：以上运行API level 为25</p>
</blockquote>
<p>从logcat的信息可知，我们在每个xml文件的布局的最外层，Android还自动帮我们加了一个FrameLayout/ContentFrameLayout，在自动嵌套的父布局里，有一部分是content，就是默认放label的地方，对应setContentView方法，在此之下才是我们自己定义的布局文件的内容。</p>
<p>onMeasure方法的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div></pre></td></tr></table></figure></p>
<p>在参数中，widthMeasureSpec和heightMeasureSpec都为int，但是每个int都包含着两个信息，分别是尺寸和测量模式，一般情况下，int是32位的，Android把其中的30位用做尺寸大小存储，2bit用做测量模式存储。</p>
<p>2bit来存测量模式信息，也就是最多有4种模式，Android提供了3种测量模式，如下：</p>
<table>
<thead>
<tr>
<th>测量模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNSPECIFIED</td>
<td>父容器没有对当前View有任何限制，当前View可以任意取尺寸 极少用</td>
</tr>
<tr>
<td>EXACTLY</td>
<td>父布局要求的精确尺寸，必须用这个尺寸作为View尺寸</td>
</tr>
<tr>
<td>AT_MOST</td>
<td>父布局给予View最大的尺寸，当前的View能取的尺寸为这个</td>
</tr>
</tbody>
</table>
<p>测量模式和实际布局应用的属性值的关系：</p>
<ul>
<li>match_parent  -&gt;  EXACTLY</li>
<li>wrap_content  -&gt;  AT_MOST</li>
<li>指定尺寸      -&gt;  EXACTLY</li>
</ul>
<p>如何获取widthMeasureSpec和heightMeasureSpec中的测量模式和尺寸大小？Android库中提供了两个方法，用来提取这两个信息，其实现细节就是进行了位运算，将前2-bit当做测量模式，后30-bit作为尺寸大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div></pre></td></tr></table></figure></p>
<p>重写onMeasure方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size</div><div class="line">                //我们将大小取最大值,你也可以取其他值</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mySize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        int width = getMySize(100, widthMeasureSpec);</div><div class="line">        int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);//设置测量尺寸</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成自定义类的继承拓展后，就可以使用该View了，在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;[package name].MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:background=&quot;#ff0000&quot; /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="拓展onDraw"><a href="#拓展onDraw" class="headerlink" title="拓展onDraw()"></a>拓展onDraw()</h3><p>onDraw方法用于绘制效果图，super类默认提供了Canvas对象，其具备基本的绘图功能，比如绘制背景颜色、背景图片等，可以直接使用。</p>
<p>若是在上面的onMeasure例子上，在正方形的基础上画圆，可以重写onDraw方法为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        //调用父View的onDraw函数，因为View这个类帮我们实现了一些</div><div class="line">        // 基本的而绘制功能，比如绘制背景颜色、背景图片等</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了</div><div class="line">        int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径</div><div class="line">        int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        canvas.drawCircle(centerX, centerY, radius, paint);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义布局属性"><a href="#自定义布局属性" class="headerlink" title="自定义布局属性"></a>自定义布局属性</h3><p>可以在res/values/styles.xml文件中定义自己的属性（或者新建attr.xml文件），在需要用户来指定某些属性的值的时候，这个是很有用的。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line"></div><div class="line">    &lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt;</div><div class="line">    &lt;declare-styleable name=&quot;MyView&quot;&gt;</div><div class="line">        &lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt;</div><div class="line">        &lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;[package name].MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        hc:default_size=&quot;100dp&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>在Java文件中解析获取该属性的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private int defalutSize;</div><div class="line">  public MyView(Context context, AttributeSet attrs) &#123;</div><div class="line">      super(context, attrs);</div><div class="line">      //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</div><div class="line">        //即属性集合的标签，在R文件中名称为R.styleable+name</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);</div><div class="line"></div><div class="line">        //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</div><div class="line">        //第二个参数为，如果没有设置这个属性，则设置的默认的值</div><div class="line">        defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</div><div class="line"></div><div class="line">        //最后记得将TypedArray对象回收</div><div class="line">        a.recycle();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义View完整示例代码"><a href="#自定义View完整示例代码" class="headerlink" title="自定义View完整示例代码"></a>自定义View完整示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">package com.example.linzh.myview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by linzh on 2017/3/28.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyView extends View &#123;//继承View至少实现两个构造方法</div><div class="line"></div><div class="line">    private int defaultSize;</div><div class="line"></div><div class="line">    public MyView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</div><div class="line">        //即属性集合的标签，在R文件中名称为R.styleable+name</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);</div><div class="line"></div><div class="line">        //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</div><div class="line">        //第二个参数为，如果没有设置这个属性，则设置的默认的值</div><div class="line">        defaultSize = typedArray.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</div><div class="line"></div><div class="line">        typedArray.recycle();//回收</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = getMySize(100, widthMeasureSpec);</div><div class="line">        int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        //调用父View的onDraw函数，因为View这个类帮我们实现了一些</div><div class="line">        // 基本的而绘制功能，比如绘制背景颜色、背景图片等</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了</div><div class="line">        int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径</div><div class="line">        int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        canvas.drawCircle(centerX, centerY, radius, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            case MeasureSpec.UNSPECIFIED://如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.AT_MOST://如果测量模式是最大取值为size 类似于wrap_content</div><div class="line">                mySize = size;//这里把值去最大，也可以取其他值</div><div class="line">                break;</div><div class="line">            case MeasureSpec.EXACTLY://如果是固定大小，拿就不要去改变它， 类似于match_parent</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return mySize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><p>ViewGroup是一到多个View的容器，ViewGroup多大也是要测量好的，而且要根据View来测量。</p>
<h3 id="重写onMeasure"><a href="#重写onMeasure" class="headerlink" title="重写onMeasure"></a>重写onMeasure</h3><p>逐个测量View的大小，并且设定ViewGroup的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       //将所有的子View进行测量，这会触发每个子View的onMeasure函数</div><div class="line">       //注意要与measureChild区分，measureChild是对单个view进行测量</div><div class="line">       measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">       int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">       int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">       int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">       int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">       int childCount = getChildCount();</div><div class="line"></div><div class="line">       if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间</div><div class="line">           setMeasuredDimension(0, 0);</div><div class="line">       &#125; else &#123;</div><div class="line">           //如果宽高都是包裹内容</div><div class="line">           if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">               //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</div><div class="line">               int height = getTotleHeight();</div><div class="line">               int width = getMaxChildWidth();</div><div class="line">               setMeasuredDimension(width, height);</div><div class="line"></div><div class="line">           &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</div><div class="line">               //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</div><div class="line">               setMeasuredDimension(widthSize, getTotleHeight());</div><div class="line">           &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</div><div class="line">               //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</div><div class="line">               setMeasuredDimension(getMaxChildWidth(), heightSize);</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   /***</div><div class="line">    * 获取子View中宽度最大的值</div><div class="line">    */</div><div class="line">   private int getMaxChildWidth() &#123;</div><div class="line">       int childCount = getChildCount();</div><div class="line">       int maxWidth = 0;</div><div class="line">       for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">           View childView = getChildAt(i);</div><div class="line">           if (childView.getMeasuredWidth() &gt; maxWidth)</div><div class="line">               maxWidth = childView.getMeasuredWidth();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return maxWidth;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /***</div><div class="line">    * 将所有子View的高度相加</div><div class="line">    **/</div><div class="line">   private int getTotleHeight() &#123;</div><div class="line">       int childCount = getChildCount();</div><div class="line">       int height = 0;</div><div class="line">       for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">           View childView = getChildAt(i);</div><div class="line">           height += childView.getMeasuredHeight();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return height;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="重写onLayout"><a href="#重写onLayout" class="headerlink" title="重写onLayout"></a>重写onLayout</h3><p>自定义ViewGroup，重写onLayout方法是有用的，在此方法我们将View逐个摆放到设定好大小的ViewGroup中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    int count = getChildCount();</div><div class="line">    //记录当前的高度位置</div><div class="line">    int curHeight = t;</div><div class="line">    //将子View逐个摆放</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        int height = child.getMeasuredHeight();</div><div class="line">        int width = child.getMeasuredWidth();</div><div class="line">        //摆放子View，参数分别是子View矩形区域的左、上、右、下边</div><div class="line">        child.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">        curHeight += height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成Java代码的定制，即可在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.example.linzh.myview.MyViewGroup</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:background=&quot;#ff9900&quot;&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;200dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;/com.example.linzh.myview.MyViewGroup&gt;</div><div class="line"></div><div class="line">    &lt;com.example.linzh.myview.MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        linzh:default_size=&quot;100dp&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<h3 id="自定制ViewGroup完成示例代码"><a href="#自定制ViewGroup完成示例代码" class="headerlink" title="自定制ViewGroup完成示例代码"></a>自定制ViewGroup完成示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">package com.example.linzh.myview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by linzh on 2017/3/28.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyViewGroup extends ViewGroup &#123;//至少实现两个Super类的构造器</div><div class="line"></div><div class="line"></div><div class="line">    public MyViewGroup(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyViewGroup(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        //将所有的子View进行测量，这会触发每个子View的onMeasure函数</div><div class="line">        //注意要与measureChild区分，measureChild是对单个view进行测量</div><div class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        int childCount = getChildCount();</div><div class="line">        if (childCount == 0) &#123;//如果没有子view，当前ViewGroup没有存在的意义，不用占用空间</div><div class="line">            setMeasuredDimension(0, 0);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//如果宽高都是包裹内容</div><div class="line">                //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</div><div class="line">                int height = getTotleHeight();</div><div class="line">                int width = getMaxChildWidth();</div><div class="line">                setMeasuredDimension(width, height);</div><div class="line">            &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</div><div class="line">                //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</div><div class="line">                setMeasuredDimension(widthSize, getTotleHeight());</div><div class="line">            &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</div><div class="line">                //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</div><div class="line">                setMeasuredDimension(getMaxChildWidth(), heightSize);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        int curHeight = t;//记录当前的高度位置</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;//将View逐个摆放</div><div class="line">            View view = getChildAt(i);</div><div class="line">            int height = view.getMeasuredHeight();</div><div class="line">            int width = view.getMeasuredWidth();</div><div class="line">            //摆放子View，参数分别是子View矩形区域的左、上、右、下边</div><div class="line">            view.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">            curHeight += height;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取子View中宽度最大的值</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private int getMaxChildWidth() &#123;</div><div class="line">        int childCount = getChildCount();</div><div class="line">        int maxWidth = 0;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            if (childView.getMeasuredWidth() &gt; maxWidth) &#123;</div><div class="line">                maxWidth = childView.getMeasuredWidth();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return maxWidth;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 将所有子View的高度相加</div><div class="line">     **/</div><div class="line">    private int getTotleHeight() &#123;</div><div class="line">        int childCount = getChildCount();</div><div class="line">        int height = 0;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            height += childView.getMeasuredHeight();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/guide/topics/ui/custom-components.html#custom" target="_blank" rel="external">Android API指南 Custom Components</a></li>
<li><a href="http://www.jianshu.com/p/c84693096e41" target="_blank" rel="external">自定义View，有这一篇就够了</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linzhs.cm/2017/05/26/android-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Linzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linzh's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/android-test/" itemprop="url">Android的单元测试和UI测试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T02:07:10+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android自定义View和ViewGroup"><a href="#Android自定义View和ViewGroup" class="headerlink" title="Android自定义View和ViewGroup"></a>Android自定义View和ViewGroup</h1><blockquote>
<p>Android中提供了丰富、复杂的视图系统，widget类的组件：Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner都是直接或间接继承于super类View，布局类：LinearLayout, FrameLayout, RelativeLayout等则继承于ViewGroup， ViewGroup则继承于View。</p>
<p>所以，要设计构建自己的视图或者布局，就要去继承View或者ViewGroup。本文从使用的角度来总结自定制View和ViewGroup。</p>
</blockquote>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>自定义View，最基本的就是继承Android提供的基本视图类View。<br>自定义步骤：</p>
<ul>
<li>自定义View的属性 编写attr.xml文件 </li>
<li>在layout布局文件中引用，同时引用命名空间 </li>
<li>在View的构造方法中获得我们自定义的属性，在自定义控件中进行读取（构造方法拿到attr.xml文件值） </li>
<li>重写onMesure </li>
<li>重写onDraw</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyView extends View &#123;</div><div class="line">    public MyView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承了View类，还需要重写2个以上的构造方法（以上示例为常用重写构造方法）和onMeasure(), onDraw()方法，在View继承中，onLayout()是非必须的。</p>
<h3 id="拓展onMeasure"><a href="#拓展onMeasure" class="headerlink" title="拓展onMeasure()"></a>拓展onMeasure()</h3><p>自定义View都要自己来测量控制宽高尺寸，算出自己需要占用多大的面积。我们常在xml布局文件中用match_parent和wrap_content，这两属性都是依赖于父布局的，没有父布局就没法正确定位宽高。</p>
<p>这里存在一个疑问，就是如果我们在activity_main.xml中的代码如下，layout_width和layout_height指定的值也都为match_parent，其父布局又在哪呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:id=&quot;@+id/main_layout&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>我们在MainActivity.java中进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private LinearLayout linearLayout;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        linearLayout = (LinearLayout)findViewById(R.id.main_layout);</div><div class="line">        LayoutInflater layoutInflater = LayoutInflater.from(this);</div><div class="line">        View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null);</div><div class="line">        linearLayout.addView(buttonLayout);</div><div class="line"></div><div class="line">        ViewParent viewParent = linearLayout.getParent();//获取父布局的名字</div><div class="line">        Log.d(&quot;MainActivity&quot;, &quot;The parent of main linear layout is &quot; + viewParent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上App，可以在logcat中打印出如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The parent of main linear layout is android.support.v7.widget.ContentFrameLayout&#123;2ef2e36 V.E...... ......I. 0,0-0,0 #1020002 android:id/content&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：以上运行API level 为25</p>
</blockquote>
<p>从logcat的信息可知，我们在每个xml文件的布局的最外层，Android还自动帮我们加了一个FrameLayout/ContentFrameLayout，在自动嵌套的父布局里，有一部分是content，就是默认放label的地方，对应setContentView方法，在此之下才是我们自己定义的布局文件的内容。</p>
<p>onMeasure方法的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div></pre></td></tr></table></figure></p>
<p>在参数中，widthMeasureSpec和heightMeasureSpec都为int，但是每个int都包含着两个信息，分别是尺寸和测量模式，一般情况下，int是32位的，Android把其中的30位用做尺寸大小存储，2bit用做测量模式存储。</p>
<p>2bit来存测量模式信息，也就是最多有4种模式，Android提供了3种测量模式，如下：</p>
<table>
<thead>
<tr>
<th>测量模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNSPECIFIED</td>
<td>父容器没有对当前View有任何限制，当前View可以任意取尺寸 极少用</td>
</tr>
<tr>
<td>EXACTLY</td>
<td>父布局要求的精确尺寸，必须用这个尺寸作为View尺寸</td>
</tr>
<tr>
<td>AT_MOST</td>
<td>父布局给予View最大的尺寸，当前的View能取的尺寸为这个</td>
</tr>
</tbody>
</table>
<p>测量模式和实际布局应用的属性值的关系：</p>
<ul>
<li>match_parent  -&gt;  EXACTLY</li>
<li>wrap_content  -&gt;  AT_MOST</li>
<li>指定尺寸      -&gt;  EXACTLY</li>
</ul>
<p>如何获取widthMeasureSpec和heightMeasureSpec中的测量模式和尺寸大小？Android库中提供了两个方法，用来提取这两个信息，其实现细节就是进行了位运算，将前2-bit当做测量模式，后30-bit作为尺寸大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div></pre></td></tr></table></figure></p>
<p>重写onMeasure方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size</div><div class="line">                //我们将大小取最大值,你也可以取其他值</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mySize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        int width = getMySize(100, widthMeasureSpec);</div><div class="line">        int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);//设置测量尺寸</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成自定义类的继承拓展后，就可以使用该View了，在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;[package name].MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:background=&quot;#ff0000&quot; /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="拓展onDraw"><a href="#拓展onDraw" class="headerlink" title="拓展onDraw()"></a>拓展onDraw()</h3><p>onDraw方法用于绘制效果图，super类默认提供了Canvas对象，其具备基本的绘图功能，比如绘制背景颜色、背景图片等，可以直接使用。</p>
<p>若是在上面的onMeasure例子上，在正方形的基础上画圆，可以重写onDraw方法为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        //调用父View的onDraw函数，因为View这个类帮我们实现了一些</div><div class="line">        // 基本的而绘制功能，比如绘制背景颜色、背景图片等</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了</div><div class="line">        int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径</div><div class="line">        int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        canvas.drawCircle(centerX, centerY, radius, paint);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义布局属性"><a href="#自定义布局属性" class="headerlink" title="自定义布局属性"></a>自定义布局属性</h3><p>可以在res/values/styles.xml文件中定义自己的属性（或者新建attr.xml文件），在需要用户来指定某些属性的值的时候，这个是很有用的。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line"></div><div class="line">    &lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt;</div><div class="line">    &lt;declare-styleable name=&quot;MyView&quot;&gt;</div><div class="line">        &lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt;</div><div class="line">        &lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;[package name].MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        hc:default_size=&quot;100dp&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>在Java文件中解析获取该属性的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private int defalutSize;</div><div class="line">  public MyView(Context context, AttributeSet attrs) &#123;</div><div class="line">      super(context, attrs);</div><div class="line">      //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</div><div class="line">        //即属性集合的标签，在R文件中名称为R.styleable+name</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);</div><div class="line"></div><div class="line">        //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</div><div class="line">        //第二个参数为，如果没有设置这个属性，则设置的默认的值</div><div class="line">        defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</div><div class="line"></div><div class="line">        //最后记得将TypedArray对象回收</div><div class="line">        a.recycle();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义View完整示例代码"><a href="#自定义View完整示例代码" class="headerlink" title="自定义View完整示例代码"></a>自定义View完整示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">package com.example.linzh.myview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.res.TypedArray;</div><div class="line">import android.graphics.Canvas;</div><div class="line">import android.graphics.Color;</div><div class="line">import android.graphics.Paint;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by linzh on 2017/3/28.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyView extends View &#123;//继承View至少实现两个构造方法</div><div class="line"></div><div class="line">    private int defaultSize;</div><div class="line"></div><div class="line">    public MyView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        //第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</div><div class="line">        //即属性集合的标签，在R文件中名称为R.styleable+name</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);</div><div class="line"></div><div class="line">        //第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</div><div class="line">        //第二个参数为，如果没有设置这个属性，则设置的默认的值</div><div class="line">        defaultSize = typedArray.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</div><div class="line"></div><div class="line">        typedArray.recycle();//回收</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int width = getMySize(100, widthMeasureSpec);</div><div class="line">        int height = getMySize(100, heightMeasureSpec);</div><div class="line"></div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            width = height;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        //调用父View的onDraw函数，因为View这个类帮我们实现了一些</div><div class="line">        // 基本的而绘制功能，比如绘制背景颜色、背景图片等</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        int radius = getMeasuredHeight() / 2;//也可以是getMeasuredWidth()/2,本例中已经将宽高设置相等了</div><div class="line">        int centerX = getLeft() + radius;//圆心的横坐标为当前的View的左边起始位置+半径</div><div class="line">        int centerY = getTop() + radius;//圆心的纵坐标为当前的View的顶部起始位置+半径</div><div class="line"></div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setColor(Color.GREEN);</div><div class="line">        canvas.drawCircle(centerX, centerY, radius, paint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getMySize(int defaultSize, int measureSpec) &#123;</div><div class="line">        int mySize = defaultSize;</div><div class="line"></div><div class="line">        int mode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int size = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (mode) &#123;</div><div class="line">            case MeasureSpec.UNSPECIFIED://如果没有指定大小，就设置为默认大小</div><div class="line">                mySize = defaultSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.AT_MOST://如果测量模式是最大取值为size 类似于wrap_content</div><div class="line">                mySize = size;//这里把值去最大，也可以取其他值</div><div class="line">                break;</div><div class="line">            case MeasureSpec.EXACTLY://如果是固定大小，拿就不要去改变它， 类似于match_parent</div><div class="line">                mySize = size;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return mySize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><p>ViewGroup是一到多个View的容器，ViewGroup多大也是要测量好的，而且要根据View来测量。</p>
<h3 id="重写onMeasure"><a href="#重写onMeasure" class="headerlink" title="重写onMeasure"></a>重写onMeasure</h3><p>逐个测量View的大小，并且设定ViewGroup的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       //将所有的子View进行测量，这会触发每个子View的onMeasure函数</div><div class="line">       //注意要与measureChild区分，measureChild是对单个view进行测量</div><div class="line">       measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">       int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">       int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">       int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">       int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">       int childCount = getChildCount();</div><div class="line"></div><div class="line">       if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间</div><div class="line">           setMeasuredDimension(0, 0);</div><div class="line">       &#125; else &#123;</div><div class="line">           //如果宽高都是包裹内容</div><div class="line">           if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">               //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</div><div class="line">               int height = getTotleHeight();</div><div class="line">               int width = getMaxChildWidth();</div><div class="line">               setMeasuredDimension(width, height);</div><div class="line"></div><div class="line">           &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</div><div class="line">               //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</div><div class="line">               setMeasuredDimension(widthSize, getTotleHeight());</div><div class="line">           &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</div><div class="line">               //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</div><div class="line">               setMeasuredDimension(getMaxChildWidth(), heightSize);</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   /***</div><div class="line">    * 获取子View中宽度最大的值</div><div class="line">    */</div><div class="line">   private int getMaxChildWidth() &#123;</div><div class="line">       int childCount = getChildCount();</div><div class="line">       int maxWidth = 0;</div><div class="line">       for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">           View childView = getChildAt(i);</div><div class="line">           if (childView.getMeasuredWidth() &gt; maxWidth)</div><div class="line">               maxWidth = childView.getMeasuredWidth();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return maxWidth;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /***</div><div class="line">    * 将所有子View的高度相加</div><div class="line">    **/</div><div class="line">   private int getTotleHeight() &#123;</div><div class="line">       int childCount = getChildCount();</div><div class="line">       int height = 0;</div><div class="line">       for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">           View childView = getChildAt(i);</div><div class="line">           height += childView.getMeasuredHeight();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return height;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="重写onLayout"><a href="#重写onLayout" class="headerlink" title="重写onLayout"></a>重写onLayout</h3><p>自定义ViewGroup，重写onLayout方法是有用的，在此方法我们将View逐个摆放到设定好大小的ViewGroup中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    int count = getChildCount();</div><div class="line">    //记录当前的高度位置</div><div class="line">    int curHeight = t;</div><div class="line">    //将子View逐个摆放</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        int height = child.getMeasuredHeight();</div><div class="line">        int width = child.getMeasuredWidth();</div><div class="line">        //摆放子View，参数分别是子View矩形区域的左、上、右、下边</div><div class="line">        child.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">        curHeight += height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成Java代码的定制，即可在xml布局文件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:linzh=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.example.linzh.myview.MyViewGroup</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:background=&quot;#ff9900&quot;&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;200dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;Button</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;button&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;/com.example.linzh.myview.MyViewGroup&gt;</div><div class="line"></div><div class="line">    &lt;com.example.linzh.myview.MyView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        linzh:default_size=&quot;100dp&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<h3 id="自定制ViewGroup完成示例代码"><a href="#自定制ViewGroup完成示例代码" class="headerlink" title="自定制ViewGroup完成示例代码"></a>自定制ViewGroup完成示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">package com.example.linzh.myview;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by linzh on 2017/3/28.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyViewGroup extends ViewGroup &#123;//至少实现两个Super类的构造器</div><div class="line"></div><div class="line"></div><div class="line">    public MyViewGroup(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyViewGroup(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        //将所有的子View进行测量，这会触发每个子View的onMeasure函数</div><div class="line">        //注意要与measureChild区分，measureChild是对单个view进行测量</div><div class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        int childCount = getChildCount();</div><div class="line">        if (childCount == 0) &#123;//如果没有子view，当前ViewGroup没有存在的意义，不用占用空间</div><div class="line">            setMeasuredDimension(0, 0);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//如果宽高都是包裹内容</div><div class="line">                //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</div><div class="line">                int height = getTotleHeight();</div><div class="line">                int width = getMaxChildWidth();</div><div class="line">                setMeasuredDimension(width, height);</div><div class="line">            &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</div><div class="line">                //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</div><div class="line">                setMeasuredDimension(widthSize, getTotleHeight());</div><div class="line">            &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</div><div class="line">                //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</div><div class="line">                setMeasuredDimension(getMaxChildWidth(), heightSize);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        int curHeight = t;//记录当前的高度位置</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;//将View逐个摆放</div><div class="line">            View view = getChildAt(i);</div><div class="line">            int height = view.getMeasuredHeight();</div><div class="line">            int width = view.getMeasuredWidth();</div><div class="line">            //摆放子View，参数分别是子View矩形区域的左、上、右、下边</div><div class="line">            view.layout(l, curHeight, l + width, curHeight + height);</div><div class="line">            curHeight += height;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取子View中宽度最大的值</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private int getMaxChildWidth() &#123;</div><div class="line">        int childCount = getChildCount();</div><div class="line">        int maxWidth = 0;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            if (childView.getMeasuredWidth() &gt; maxWidth) &#123;</div><div class="line">                maxWidth = childView.getMeasuredWidth();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return maxWidth;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 将所有子View的高度相加</div><div class="line">     **/</div><div class="line">    private int getTotleHeight() &#123;</div><div class="line">        int childCount = getChildCount();</div><div class="line">        int height = 0;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            height += childView.getMeasuredHeight();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/guide/topics/ui/custom-components.html#custom" target="_blank" rel="external">Android API指南 Custom Components</a></li>
<li><a href="http://www.jianshu.com/p/c84693096e41" target="_blank" rel="external">自定义View，有这一篇就够了</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Linzh</p>
              <p class="site-description motion-element" itemprop="description">Standing on Shoulders of Giants</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linzh</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
